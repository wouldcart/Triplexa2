{"version":3,"mappings":"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","names":["count","toastTimeouts","Map","addToRemoveQueue","toastId","has","timeout","setTimeout","delete","dispatch","type","set","reducer","state","action","toasts","toast","slice","map","t","id","forEach","open","filter","listeners","memoryState","listener","variant","props","Number","MAX_VALUE","toString","dismiss","onOpenChange","update","useToast","setState","React.useState","React.useEffect","push","index","indexOf","splice","useAccessControl","currentUser","hasPermission","useApp","isSuperAdmin","role","isManager","isStaff","isAgent","isUser","isAdmin","hasAdminAccess","canAccessModule","module","savedDashboardAccess","localStorage","getItem","dashboardAccessConfig","JSON","parse","error","dashboardConfig","find","config","dashboardId","allowedRoles","includes","restrictByDepartment","department","allowedDepartments","requiredPermissions","payroll","attendance","queries","bookings","inventory","agents","reports","settings","Operations","Sales","Marketing","Support","Finance","some","permission","canAccessDepartmentFeature","feature","HR","canCreateAgent","staffAgentCapabilities","canViewAgents","canEditAgents","canDeleteOwnAgents","canAssignStaff","canResetPasswords","canTrackActivity","defaultActiveStatus","canPerformAction","context","managerCapabilities","canAssignQueries","canApproveProposals","canManageStaff","canViewReports","canAccessSettings","canBulkOperations","canManageAgents","canAccessFinancials","currentUserRole","currentUserDepartment","canManageAgent","agentId","agent","a","isCreator","createdBy","staffId","parseInt","isAssigned","staffAssignments","assignment","getAccessibleAgents","allAgents","useIsMobile","isMobile","setIsMobile","window","innerWidth","checkIfMobile","addEventListener","removeEventListener","useSEODatabase","pageRoute","seoSettings","setSeoSettings","useState","loading","setLoading","setError","loadSEOSettings","useCallback","async","seoService","getSEOSettings","err","Error","message","updateSEOSettings","updates","updatedSettings","upsertSEOSettings","page_route","useEffect","subscription","subscribeToSEOSettings","unsubscribe","refreshSEOSettings","default","success","useDashboardData","tasks","setTasks","alerts","setAlerts","stats","setStats","totalEnquiries","totalBookings","totalRevenue","pendingFollowUps","activeTasks","hotLeads","fetchDashboardData","data","tasksData","tasksError","supabase","from","select","order","ascending","alertsData","alertsError","eq","enquiriesResult","bookingsResult","followUpsResult","leadsResult","Promise","all","length","reduce","sum","booking","total_amount","task","status","errorMessage","title","description","createTask","taskData","user","auth","getUser","insert","created_by","single","prev","updateTask","markAlertAsRead","is_read","alert","useLocalAgentData","localAgents","setLocalAgents","storedAgents","AgentStorageService","getAgents","loadAgents","useMemo","defaultAgents","saveAgent","agentData","savedAgent","updateAgent","updatedAgent","deleteAgent","useAgentData","activeAgents","getAgentsByCountry","country","toLowerCase","getAgentsByCity","city","getAgentById","getHighPerformingAgents","conversionRate","sort","b","totalActiveAgents","totalAgents","useEnhancedStaffData","enhancedStaffMembers","setEnhancedStaffMembers","ignore","staff","fetchEnhancedStaff","e","activeStaff","active","allStaff","getBestStaffForQuery","destinations","packageType","score","dest","expertise","exp","packageMatch","specializations","spec","assigned","workloadCapacity","experience","matchScore","getStaffByDepartment","getAvailableStaff","autoAssignEnabled","totalActiveStaff","totalAvailableCapacity","useManagerDashboardData","hotels","useSupabaseHotelsData","s","activeQueriesList","mockQueries","q","confirmedBookings","pendingProposals","query","paxDetails","adults","tripDuration","nights","totalStaff","activeQueries","totalHotels","h","revenue","toFixed","pendingApprovals","completedBookings","Math","round","quickActions","path","priority","recentActivities","activities","destination","agentName","timestamp","createdAt","split","name","Date","toISOString","getTime","isLoading","defaultSettings","enableWebSocket","enablePushNotifications","enableSoundNotifications","enableToastNotifications","autoConnect","simulationMode","useRealTimeNotifications","addNotification","useStaffNotifications","isConnected","setIsConnected","connectionStatus","setConnectionStatus","realTimeNotificationService","getConnectionStatus","setSettings","saved","subscriberRef","useRef","simulationIntervalRef","setItem","stringify","updateConfig","connect","disconnect","subscriber","callback","handleNewNotification","filters","staffIds","current","subscribe","interval","setInterval","clearInterval","notification","duration","requestPermissions","granted","requestNotificationPermission","subscribeToPush","subscribeToPushNotifications","sendTestNotification","testNotification","queryId","read","actionRequired","actionUrl","sendNotification","startSimulation","stopSimulation","updateSettings","newSettings","useAgentProfileGuard","thresholdPercent","setAgent","fetchAgent","uid","agentErr","maybeSingle","completion","fields","filled","acc","key","v","Array","isArray","trim","shouldRedirect","shouldPopup","refresh","useCountriesEnquiryIntegration","addCountry","updateCountry","removeCountry","setDefaultCountry","useApplicationSettings","activeCountries","setActiveCountries","activeCountriesFromModule","initialCountries","countryOptions","enquiryConfig","enquirySettings","countries","countryCode","code","isConfigured","availableCountries","option","configuredCountries","getCountryDetailsForConfig","c","countryName","prefix","yearFormat","yearSeparator","numberLength","numberSeparator","startingNumber","isDefault","isActive","validateCountryForEnquiry","syncEnquiryWithActiveCountries","activeCountryCodes","addCountryWithDetails","customConfig","baseConfig","finalConfig","useEnhancedProfile","userId","profile","setProfile","saving","setSaving","lastSaved","setLastSaved","autoSaveRef","loadProfile","profileData","getEnhancedProfile","saveProfile","updatedProfile","upsertEnhancedProfile","user_id","autoSave","updateField","field","value","updateFields","createAutoSave","subscribeToEnhancedProfile","refreshProfile","useProfileActivity","limit","activityLog","setActivityLog","loadActivityLog","logs","getProfileActivityLog","refreshActivityLog","useProfileValidation","validateEmail","email","test","validatePhone","phone","replace","validateRequired","validateProfile","errors","first_name","last_name","bio","isValid","Object","keys","AUTO_ASSIGN_SETTING_ID","useQueryAssignment","assigningQuery","setAssigningQuery","isAssigning","setIsAssigning","selectedStaffId","setSelectedStaffId","setAutoAssignEnabledState","autoAssignHydrated","setAutoAssignHydrated","enhancedStaff","byId","AppSettingsService","getSettingById","raw","setting_value","setting_json","enabled","String","val","getSettingValue","setAutoAssignEnabled","checked","updateSettingById","is_active","AppSettingsHelpers","upsertSetting","category","setting_key","assignQueryToStaff","assignedBy","staffIdentifier","uuid","recommended","findBestStaffMatchService","selectionPrefix","safeReason","getAssignmentReason","assignEnquiry","autoAssignQueries","successCount","assignQueryEngine","findBestStaffMatch","getApplicableRule","getBestCountryMatch","useActiveStaffData","useRealTimeCountriesData","setCountries","loadCountries","response","CountriesService","getAllCountries","mappedCountries","mapDbCountriesToFrontend","refreshCountries","getCountryByCode","getCountryByName","getCountryById","useSupabaseAgentsList","setAgents","mapLocalAgent","agencyName","contact","agent_code","profile_image","profileImage","totalQueries","revenueGenerated","averageBookingValue","activeCustomers","mapRow","row","profiles","agency_name","business_phone","agency_code","client","agentsOnly","fallbackErr","localStored","localOptions","options","searchAgents","term","like","or","join","lower","Boolean","reload","useCitiesData","cities","setCities","citiesResponse","CitiesService","getActiveCities","transformedCities","region","has_airport","is_popular","created_at","updated_at","hasAirport","isPopular","countriesResponse","getActiveCountries","transformedCountries","loadData","getCitiesByCountry","useProposalPersistence","draftType","setData","itineraryData","sightseeingOptions","citySelection","itineraryOther","accommodationData","selectedAccommodations","markupData","termsConditions","paymentTerms","cancellationPolicy","additionalTerms","inclusions","exclusions","emailData","to","subject","agentPhone","agentEmail","pricingConfig","mode","adultMarkup","childMarkup","childDiscountPercent","pricingData","transportOptions","version","storageKey","proposalId","SupabaseProposalService","getDraftByProposalId","itineraryRaw","itinerary_data","days","sightseeing_options","city_selection","fromEntries","entries","k","pricingRaw","pricing_data","transport_options","remoteData","accommodation_data","terms","email_data","last_saved","prevData","cacheString","storageKeys","parsedData","saveData","nowIso","nextData","updatedData","prevDataString","newDataString","supabasePatch","updateDraftFields","patch","updateItineraryData","updateSightseeingOptions","updateCitySelection","updateTermsConditions","updateEmailData","updatePricingConfig","updateTransportOptions","updateAccommodationData","useProposalBuilder","setDays","selectedDayId","setSelectedDayId","loadDraftData","specificDraftType","savedDraft","parsedDraft","daysData","validatedDays","day","now","dayNumber","date","transport","accommodations","accommodation","meals","breakfast","lunch","dinner","totalCost","removeItem","loadSpecificDraft","draftId","startsWith","supabaseDraft","urlParams","URLSearchParams","location","search","shouldAutoLoad","autoLoadDraft","get","catch","addDay","newDay","addMultipleDays","newDays","i","autoGenerateDaysFromQuery","calculateTripDuration","travelDates","startDate","generatedDays","currentDate","setDate","getDate","isFirstDay","isLastDay","defaultCity","cityIndex","floor","max","generateDaysFromCityAllocations","allocations","currentDayNumber","totalNights","totalDays","allocation","allocationIndex","isFirstDayInCity","isLastDayInCity","isFirstDayOverall","arrivalCity","departureDate","departureDay","updateDay","dayId","removeDay","reorderDay","direction","currentIndex","findIndex","newIndex","reorderedDays","movedDay","addHotelToDay","hotel","price","finalPrice","minRate","roomType","roomTypes","d","activitiesCost","cost","transportCost","accommodationsCost","addTransportToDay","transportActivity","transportType","vehicleType","seatingCapacity","vehicleCount","pickupLocation","dropoffLocation","pickupTime","dropTime","routeCode","dataSource","originalData","priceBreakdown","basePrice","existingActivitiesCost","accommodationCost","existingTransportCost","updatedActivities","addSightseeingToDay","activity","adult","newActivity","effectivePax","startTime","endTime","pricingSelection","transferOption","transportLabel","priceUnit","selectedOptions","packageOptions","pricingOptions","transferOptions","totalActivityCost","saveDraft","targetDraftType","finalDraftType","saveActivityDataWithValidation","__vitePreload","import","then","n","a4","__VITE_PRELOAD__","draftData","savedAt","allAccommodations","flatMap","checkIn","checkOut","starRating","pricePerNight","totalPrice","amenities","address","dayIds","saveAccommodationData","ProposalService","getQueryByIdAsync","upsertDraftProposal","generateProposal","modules","pricing","currency","metadata","supplier","confirmationRequired","tags","proposalData","totals","subtotal","discountAmount","total","moduleCount","updatedAt","saveProposal","createProposal","saveAccommodations","updatedDays","dayAccommodations","useAutoSaveProposal","debounceMs","showToast","isValidQueryId","hasLoggedMissingQuery","saveTimeoutRef","lastSavedRef","isInitialMount","isSavingRef","saveError","setSaveError","dataString","proposal_id","supabaseProposalService","dispatchEvent","CustomEvent","fallbackError","triggerAutoSave","clearTimeout","manualSave","isSaving","useEnhancedInventoryData","restaurants","sightseeing","transportRoutes","initialCities","currencySymbol","refreshData","hotelData","getEnhancedHotelData","sightseeingDataFromStorage","sightseeingData","getEnhancedSightseeingData","restaurantData","initialRestaurants","restaurant","vegOptions","dietaryOptions","vegetarian","currencyCode","getEnhancedRestaurantData","transportData","route","distance","getEnhancedTransportData","finalHotelData","processedSightseeingData","item","child","filteredData","filterByLocation","items","locationFields","itemLocations","locationStr","countryStr","cityStr","routeCountry","routeFrom","routeTo","matchesCountry","matchesCity","handleStorageChange","handleCustomUpdate","useDebounce","fn","delay","timeoutRef","debouncedFn","args","cancel","UUID_REGEX","ENQUIRY_REGEX","DEQ_ENQUIRY_REGEX","DRAFT_REGEX","getOptionalRecordsDirect","optional_records","mapItemTypeToRecordType","itemType","useOptionalItem","itemId","updateOptionalItem","getOptionalStatus","useAuth","DEFAULT_OPTIONAL_RECORDS_CONFIG","optionalRecords","setOptionalRecords","setIsLoading","isOnline","setIsOnline","navigator","onLine","pendingUpdates","subscriptionRef","isMounted","initializeOptionalRecords","records","handleOnline","handleOffline","enableRealTimeSync","channel","on","event","schema","table","payload","newOptionalRecords","new","setupSubscription","isOptional","updateKey","enableDebouncing","newRecords","recordType","existingIndex","r","optionId","updatedRecord","updatedBy","currentRecords","record","updateQuery","updateOptionalItemDirect","refreshOptionalRecords","clear","useOptionalRecords","updateItem","newOptional","useProposalRealtimeSync","persistenceData","snapshot","setSnapshot","lastUpdate","setLastUpdate","newSnapshot","baseCost","baseTotal","serviceCosts","perPersonCost","dining","totalRooms","accommodationOptions","lastCalculated","handleProposalUpdate","eventQueryId","detail","handlePricingUpdate","handleTermsUpdate","hasData","useSupabaseAgentContact","setContact","agentKey","agentUuid","cancelled","agentRecord","candidateUuid","sb","supErr","byUser","supErr2","byName","nameErr","managedRes","AgentManagementService","managed","company_name","business_address","website","alternate_email","mobile_numbers","_","mapped","company","alternateEmail","mobileNumbers","useProposalValidation","skippedRules","proposalManagementData","validationRules","rules","label","daysWithoutActivities","expectedDays","accommodationActivities","skippable","skipped","allActivities","sightseeingActivities","transportActivities","incompleteActivities","completeSightseeing","completeTransport","hasErrors","rule","hasWarnings","useProposalGeneration","navigate","useNavigate","isGenerating","setIsGenerating","currentProgress","setCurrentProgress","generationSteps","setGenerationSteps","updateStepStatus","stepId","step","simulateProgressSteps","steps","totalSteps","resolve","random","handleGenerateWithProgress","progressPromise","resetGeneration","useAutoSave","onSave","onRestore","setIsSaving","intervalRef","restoreData","clearAutoSave","ALLOWED_ROLES","useAppSettingsAccess","hasAccess","setHasAccess","userRole","setUserRole","checkAccess","roleData","roleError","rpc","profileError","hasRequiredRole","onAuthStateChange","session","useTranslation","translatedText","detectedSourceLanguage","translate","text","targetLanguage","sourceLanguage","sourceLang","detectLanguage","result","translateText","apiError","fallbackResult","fallbackTranslate","clearTranslation","useCurrency","defaultCurrency","setDefaultCurrency","symbol","enhancedSettings","EnhancedPricingService","getEnhancedSettings","currencyConversion","baseCurrency","defaultCountry","CountryCurrencyService","getAllCountriesWithCurrency","effectiveCurrency","pricingCurrency","effectiveSymbol","pricingCurrencySymbol","formatCurrency","amount","toLocaleString","minimumFractionDigits","maximumFractionDigits","convertCurrency","fromCurrency","toCurrency","targetCurrency","PricingService","getCurrencyByCountryCode","getCurrencyByCountryName","useComprehensiveTransportRoutes","autoFetch","routes","setRoutes","transportTypes","setTransportTypes","statistics","setStatistics","fetchRoutes","abortController","AbortController","ComprehensiveTransportService","getCompleteRoutes","signal","aborted","abort","fetchTransportTypes","getTransportTypes","fetchStatistics","getRouteStatistics","createRoute","formData","validation","validateRouteData","createCompleteRoute","updateRoute","routeId","updateCompleteRoute","deleteRoute","deleteCompleteRoute","getRoute","getCompleteRoute","manageIntermediateStops","stops","intermediate_stops","manageSightseeingOptions","getRoutesByCountry","getRoutesByTransferType","transferType","transfer_type","getRoutesWithSightseeing","enable_sightseeing","getRoutesWithIntermediateStops","clearError","mapCountryRow","continent","currency_symbol","flag_url","visa_required","languages","pricing_currency_override","pricing_currency","pricing_currency_symbol","useRealTimeCountries","fetchCountries","popularCountries","currencies","values","eventType","newCountry","updatedCountry","old","updateCountryCurrency","countryId","overridePricingCurrency","useOptionalCities","cityAllocations","setCityAllocations","isOptionalEnabled","setOptionalEnabled","onCityAllocationsChange","getCityAllocation","cityId","alloc","updateCityAllocation","updated","useAutomatedProposalStatus","trackingData","setTrackingData","proposalStatus","currentStatus","handleProposalCreated","automatedProposalStatusService","newTrackingData","getProposalTracking","handleProposalSent","sendMethod","updatedTrackingData","handleProposalViewed","clientId","viewSource","handleClientFeedback","feedbackType","interested","negotiation","rejection","handlePaymentReceived","paymentType","advance","full","checkFollowUpRequired","getProposalsNeedingFollowUp","getProposalStats","loadProposalTracking","loadQueryTracking","getTrackingByQueryId","useReportingManagers","excludeId","reportingManagers","setReportingManagers","in","rows","isAdminClientConfigured","adminSupabase","adminData","managers","manager","self","m","localeCompare","loadReportingManagers","useSightseeingCurrency","currencyInfo","setCurrencyInfo","fetchCurrencyData","fetchError","countryCurrency","displayText","refetch","useTravelerData","currentTrip","getCurrentTrip","currentTripActivities","getActivitiesForTrip","todayActivities","getTodayActivities","upcomingActivities","today","threeDaysFromNow","activityDate","tripHistory","mockTravelerTrips","trip","unreadNotificationsCount","mockTravelerNotifications","notif","isRead","actionRequiredNotifications","tripProgress","tripStart","tripEnd","endDate","totalDuration","elapsed","completedActivitiesCount","notifications","totalActivitiesCount","DEFAULT_SETTINGS","requireCountryMatch","fallbackToAnyStaff","useAutoAssignmentSettings","toggleAutoAssignment","isAutoAssignmentEnabled","localLoading","apiAgents","setApiAgents","queryAgents","setQueryAgents","apiLoading","setApiLoading","queryLoading","setQueryLoading","AgentApiService","fetchAgents","loadApiAgents","savedQueries","currentQuery","queryAgent","commissionType","commissionValue","joinDate","recentActivity","agentMap","searchTerm","localResults","apiResults","resultMap","sources","local","api"],"ignoreList":[],"sources":["../../src/hooks/use-toast.ts","../../src/hooks/use-access-control.ts","../../src/hooks/use-mobile.tsx","../../src/hooks/useSEODatabase.ts","../../src/hooks/useDashboardData.ts","../../src/hooks/useLocalAgentData.ts","../../src/hooks/useAgentData.ts","../../src/hooks/useEnhancedStaffData.ts","../../src/hooks/useManagerDashboardData.ts","../../src/hooks/useRealTimeNotifications.ts","../../src/hooks/useAgentProfileGuard.ts","../../src/hooks/useCountriesEnquiryIntegration.ts","../../src/hooks/useEnhancedProfile.ts","../../src/hooks/useQueryAssignment.ts","../../src/hooks/useActiveStaffData.ts","../../src/hooks/useRealTimeCountriesData.ts","../../src/hooks/useSupabaseAgentsList.ts","../../src/hooks/useCitiesData.ts","../../src/hooks/useProposalPersistence.ts","../../src/hooks/useProposalBuilder.ts","../../src/hooks/useAutoSaveProposal.ts","../../src/hooks/useEnhancedInventoryData.ts","../../src/hooks/useDebounce.ts","../../src/hooks/useOptionalRecords.ts","../../src/hooks/useProposalRealtimeSync.ts","../../src/hooks/useSupabaseAgentContact.ts","../../src/hooks/useProposalValidation.ts","../../src/hooks/useProposalGeneration.ts","../../src/hooks/useAutoSave.ts","../../src/hooks/useAppSettingsAccess.ts","../../src/hooks/useTranslation.ts","../../src/hooks/useCurrency.ts","../../src/hooks/useComprehensiveTransportRoutes.ts","../../src/hooks/useRealTimeCountries.ts","../../src/hooks/useOptionalCities.ts","../../src/hooks/useAutomatedProposalStatus.ts","../../src/hooks/useReportingManagers.ts","../../src/hooks/useSightseeingCurrency.ts","../../src/hooks/useTravelerData.ts","../../src/hooks/useAutoAssignmentSettings.ts","../../src/hooks/useEnhancedAgentData.ts"],"sourcesContent":["\n// This file was previously missing but is needed for the toast component\nimport { type ToastProps, type ToastActionElement } from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 10\nconst TOAST_REMOVE_DELAY = 1000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n  variant?: \"default\" | \"destructive\" | \"success\" | undefined\n  duration?: number\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_VALUE\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast> & Pick<ToasterToast, \"id\">\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nimport * as React from \"react\"\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n    default:\n      return state\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ninterface Toast extends Omit<ToasterToast, \"id\"> {}\n\nfunction toast({ variant = \"default\", ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      variant,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\n// Add this line to create a toast.default method that matches what's being used\ntoast.default = (props: Toast) => toast({ ...props, variant: \"default\" });\n\n// Custom success toast variant\ntoast.success = ({ ...props }: Toast) => toast({ ...props, variant: \"success\" })\n\n// Custom error toast variant\ntoast.error = ({ ...props }: Toast) => toast({ ...props, variant: \"destructive\" })\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\nexport type { ToasterToast, Toast }\n","\nimport { useApp } from \"@/contexts/AppContext\";\n\nexport function useAccessControl() {\n  const { currentUser, hasPermission } = useApp();\n  \n  const isSuperAdmin = currentUser?.role === 'super_admin';\n  const isManager = currentUser?.role === 'manager';\n  const isStaff = currentUser?.role === 'staff';\n  const isAgent = currentUser?.role === 'agent';\n  const isUser = currentUser?.role === 'user';\n  \n  // Super admin and manager have identical access to all modules\n  const isAdmin = isSuperAdmin || isManager;\n  \n  // Managers now have the same permissions as super admins\n  const hasAdminAccess = isSuperAdmin || isManager;\n  \n  const canAccessModule = (module: string): boolean => {\n    if (!currentUser) return false;\n    \n    // Super admin and manager have identical access to all modules\n    if (hasAdminAccess) return true;\n    \n    // Staff can now access agents module with full CRUD permissions\n    if (module === 'agents' && isStaff) return true;\n    \n    // Get saved dashboard access configuration from localStorage (in real app, this would come from API)\n    const savedDashboardAccess = localStorage.getItem('dashboard_access_config');\n    let dashboardAccessConfig = [];\n    \n    if (savedDashboardAccess) {\n      try {\n        dashboardAccessConfig = JSON.parse(savedDashboardAccess);\n      } catch (error) {\n        console.error('Error parsing dashboard access config:', error);\n      }\n    }\n    \n    // Check dashboard-specific access\n    const dashboardConfig = dashboardAccessConfig.find((config: any) => config.dashboardId === module);\n    if (dashboardConfig) {\n      // Check role access\n      if (!dashboardConfig.allowedRoles.includes(currentUser.role)) {\n        return false;\n      }\n      \n      // Check department access if restrictions are enabled\n      if (dashboardConfig.restrictByDepartment && currentUser.role === 'staff') {\n        if (!currentUser.department || !dashboardConfig.allowedDepartments.includes(currentUser.department)) {\n          return false;\n        }\n      }\n      \n      return true;\n    }\n    \n    // Module-specific access control based on user permissions and department\n    const modulePermissions: Record<string, string[]> = {\n      'hr-dashboard': ['staff.manage', 'hr.view'],\n      'staff-management': ['staff.view', 'staff.manage'],\n      'payroll': ['payroll.view', 'payroll.manage'],\n      'attendance': ['attendance.view', 'staff.view'],\n      'leave-management': ['leave.manage', 'staff.manage'],\n      'salary-structure': ['payroll.manage', 'finance.manage'],\n      'queries': ['queries.view'],\n      'bookings': ['bookings.view'],\n      'inventory': ['inventory.view'],\n      'agents': ['agents.view', 'staff.manage', 'agents.create', 'agents.edit', 'agents.delete'], // Enhanced agent permissions for staff\n      'reports': ['reports.view'],\n      'settings': ['settings.view'],\n      'access-control': ['settings.access'],\n      'language-settings': ['settings.languages'],\n      'api-settings': ['settings.api'],\n      'query-assignment': ['queries.assign', 'staff.manage'],\n      'proposal-management': ['queries.edit', 'proposals.manage'],\n      'bulk-operations': ['admin.bulk'],\n      // dashboard permissions with fallback logic\n      'operations-dashboard': ['dashboard.operations', 'bookings.view'],\n      'sales-dashboard': ['dashboard.sales', 'queries.view'],\n      'content-dashboard': ['dashboard.content', 'inventory.view'],\n      'support-dashboard': ['dashboard.support', 'tickets.view'],\n      'finance-dashboard': ['dashboard.finance', 'finance.view']\n    };\n    \n    const requiredPermissions = modulePermissions[module] || [];\n    \n    // For staff users, also check department-specific access (fallback when no dashboard config)\n    if (isStaff && currentUser.department && !dashboardConfig) {\n      const departmentDashboards: Record<string, string[]> = {\n        'Operations': ['operations-dashboard'],\n        'Sales': ['sales-dashboard'],\n        'Marketing': ['content-dashboard'],\n        'Customer Support': ['support-dashboard'],\n        'Support': ['support-dashboard'],\n        'Finance': ['finance-dashboard']\n      };\n      \n      const allowedDashboards = departmentDashboards[currentUser.department] || [];\n      if (allowedDashboards.includes(module)) {\n        return true;\n      }\n    }\n    \n    return requiredPermissions.some(permission => hasPermission(permission));\n  };\n\n  // Department-specific access for staff\n  const canAccessDepartmentFeature = (feature: string): boolean => {\n    if (!currentUser || !isStaff) return false;\n    if (hasAdminAccess) return true;\n\n    const department = currentUser.department;\n    if (!department) return false;\n\n    const departmentFeatures: Record<string, string[]> = {\n      \"Sales\": [\n        \"customer-management\", \"query-handling\", \"booking-creation\",\n        \"sales-reports\", \"commission-tracking\", \"agent-management\" // Added agent management for sales\n      ],\n      \"Marketing\": [\n        \"package-creation\", \"content-management\", \"campaign-management\",\n        \"marketing-reports\", \"social-media\"\n      ],\n      \"Operations\": [\n        \"inventory-management\", \"supplier-management\", \"logistics\",\n        \"operations-reports\", \"quality-control\"\n      ],\n      \"HR\": [\n        \"employee-management\", \"payroll\", \"attendance\", \"leave-management\",\n        \"performance-tracking\", \"recruitment\"\n      ],\n      \"Finance\": [\n        \"financial-reports\", \"budget-management\", \"invoice-management\",\n        \"payment-processing\", \"audit-trails\"\n      ],\n      \"Field Sales\": [\n        \"agent-acquisition\", \"lead-generation\", \"territory-management\",\n        \"agent-management\", \"commission-tracking\" // Added agent management for field sales\n      ],\n      \"Customer Support\": [\n        \"agent-support\", \"ticket-management\", \"communication\",\n        \"agent-management\" // Added agent management for support\n      ]\n    };\n\n    const allowedFeatures = departmentFeatures[department] || [];\n    return allowedFeatures.includes(feature);\n  };\n\n  // Check if user can perform specific action - managers have same access as super admins\n  const canPerformAction = (action: string, context?: string): boolean => {\n    if (!currentUser) return false;\n    if (hasAdminAccess) return true; // Both super admin and manager\n\n    // Staff can only edit their own profile\n    if (action === 'edit-profile' && context) {\n      return context === currentUser.id;\n    }\n\n    // Agent can only view their own data\n    if (isAgent && action.includes('view') && context) {\n      return context === currentUser.id;\n    }\n\n    return hasPermission(action);\n  };\n\n  // Enhanced agent-specific access control methods for staff users\n  const canManageAgent = (agentId: number, action: 'view' | 'edit' | 'delete' | 'assign'): boolean => {\n    if (!currentUser) return false;\n    \n    // Admin users have full access\n    if (hasAdminAccess) return true;\n    \n    // Staff users have enhanced permissions for agent management\n    if (isStaff) {\n      // Check if staff created this agent or is assigned to it\n      const agents = JSON.parse(localStorage.getItem('agents') || '[]');\n      const agent = agents.find((a: any) => a.id === agentId);\n      \n      if (!agent) return false;\n      \n      const isCreator = agent.createdBy?.staffId === parseInt(currentUser.id);\n      const isAssigned = agent.staffAssignments?.some((assignment: any) => \n        assignment.staffId === parseInt(currentUser.id)\n      );\n      \n      // Staff can perform most actions on agents they created or are assigned to\n      if (isCreator || isAssigned) {\n        switch (action) {\n          case 'view':\n            return true; // Staff can view any agent they created or are assigned to\n          case 'edit':\n            return true; // Staff can edit agents they created or are assigned to\n          case 'delete':\n            return isCreator && hasPermission('agents.delete.own'); // Only creator can delete\n          case 'assign':\n            return isCreator && hasPermission('agents.assign.staff'); // Only creator can assign staff\n          default:\n            return false;\n        }\n      }\n      \n      // Additional check for department-specific access\n      if (canAccessDepartmentFeature('agent-management')) {\n        return action === 'view' || action === 'edit'; // Department-based access for view/edit\n      }\n    }\n    \n    return false;\n  };\n\n  const getAccessibleAgents = (allAgents: any[]): any[] => {\n    if (!currentUser) return [];\n    \n    // Admin users see all agents\n    if (hasAdminAccess) return allAgents;\n    \n    // Staff users see agents they created, are assigned to, or have department access to\n    if (isStaff) {\n      return allAgents.filter(agent => {\n        const isCreator = agent.createdBy?.staffId === parseInt(currentUser.id);\n        const isAssigned = agent.staffAssignments?.some((assignment: any) => \n          assignment.staffId === parseInt(currentUser.id)\n        );\n        \n        // Allow access if creator, assigned, or has department-level access\n        return isCreator || isAssigned || canAccessDepartmentFeature('agent-management');\n      });\n    }\n    \n    return [];\n  };\n\n  const canCreateAgent = (): boolean => {\n    if (!currentUser) return false;\n    // Staff users can now create agents\n    return hasAdminAccess || (isStaff && (hasPermission('agents.create') || canAccessDepartmentFeature('agent-management')));\n  };\n\n  // Enhanced staff capabilities for agent management\n  const staffAgentCapabilities = {\n    canCreateAgent: canCreateAgent(),\n    canViewAgents: isStaff && (canAccessModule('agents') || canAccessDepartmentFeature('agent-management')),\n    canEditAgents: isStaff && (hasPermission('agents.edit') || canAccessDepartmentFeature('agent-management')),\n    canDeleteOwnAgents: isStaff && hasPermission('agents.delete.own'),\n    canAssignStaff: isStaff && hasPermission('agents.assign.staff'),\n    canResetPasswords: isStaff && hasPermission('agents.reset.password'),\n    canTrackActivity: isStaff && hasPermission('agents.track.activity'),\n    defaultActiveStatus: isStaff // Staff-created agents default to active\n  };\n\n  // Manager-specific capabilities (same as super admin)\n  const managerCapabilities = {\n    canAssignQueries: hasAdminAccess,\n    canApproveProposals: hasAdminAccess,\n    canManageStaff: hasAdminAccess,\n    canViewReports: hasAdminAccess,\n    canAccessSettings: hasAdminAccess,\n    canBulkOperations: hasAdminAccess,\n    canManageAgents: hasAdminAccess,\n    canAccessFinancials: hasAdminAccess\n  };\n\n  return {\n    isSuperAdmin,\n    isManager,\n    isStaff,\n    isAgent,\n    isUser,\n    isAdmin,\n    hasAdminAccess,\n    hasPermission,\n    canAccessModule,\n    canAccessDepartmentFeature,\n    canPerformAction,\n    managerCapabilities,\n    staffAgentCapabilities,\n    currentUserRole: currentUser?.role || 'guest',\n    currentUserDepartment: currentUser?.department,\n    // Enhanced agent-specific methods\n    canManageAgent,\n    getAccessibleAgents,\n    canCreateAgent\n  };\n}\n","\nimport * as React from \"react\"\n\n// Update mobile breakpoint to match mobile-first approach\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean>(\n    typeof window !== 'undefined' ? window.innerWidth < MOBILE_BREAKPOINT : false\n  )\n\n  React.useEffect(() => {\n    const checkIfMobile = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    \n    checkIfMobile()\n    window.addEventListener(\"resize\", checkIfMobile)\n    \n    return () => window.removeEventListener(\"resize\", checkIfMobile)\n  }, [])\n\n  return isMobile\n}\n","import { useState, useEffect, useCallback } from 'react';\nimport { seoService, SEOSettings } from '@/services/seoService';\n\nexport function useSEODatabase(pageRoute: string) {\n  const [seoSettings, setSeoSettings] = useState<SEOSettings | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load SEO settings for the current page\n  const loadSEOSettings = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const settings = await seoService.getSEOSettings(pageRoute);\n      setSeoSettings(settings);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load SEO settings');\n    } finally {\n      setLoading(false);\n    }\n  }, [pageRoute]);\n\n  // Update SEO settings\n  const updateSEOSettings = useCallback(async (updates: Partial<SEOSettings>) => {\n    try {\n      setError(null);\n      const updatedSettings = await seoService.upsertSEOSettings({\n        ...updates,\n        page_route: pageRoute\n      });\n      \n      if (updatedSettings) {\n        setSeoSettings(updatedSettings);\n        return updatedSettings;\n      }\n      throw new Error('Failed to update SEO settings');\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to update SEO settings');\n      throw err;\n    }\n  }, [pageRoute]);\n\n  // Load settings on mount and when pageRoute changes\n  useEffect(() => {\n    loadSEOSettings();\n  }, [loadSEOSettings]);\n\n  // Subscribe to real-time updates\n  useEffect(() => {\n    const subscription = seoService.subscribeToSEOSettings((updatedSettings) => {\n      if (updatedSettings.page_route === pageRoute) {\n        setSeoSettings(updatedSettings);\n      }\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [pageRoute]);\n\n  return {\n    seoSettings,\n    loading,\n    error,\n    updateSEOSettings,\n    refreshSEOSettings: loadSEOSettings\n  };\n}\n\nexport function useAllSEOSettings() {\n  const [allSettings, setAllSettings] = useState<SEOSettings[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const loadAllSettings = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const settings = await seoService.getAllSEOSettings();\n      setAllSettings(settings);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load SEO settings');\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    loadAllSettings();\n  }, [loadAllSettings]);\n\n  return {\n    allSettings,\n    loading,\n    error,\n    refreshAllSettings: loadAllSettings\n  };\n}","import { useState, useEffect } from 'react';\nimport { supabase } from '@/lib/supabaseClient';\nimport { useToast } from '@/hooks/use-toast';\n\nexport interface DashboardTask {\n  id: string;\n  title: string;\n  description: string | null;\n  priority: 'low' | 'medium' | 'high';\n  status: 'pending' | 'in_progress' | 'completed';\n  due_date: string | null;\n  assigned_to: string | null;\n  created_by: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface DashboardAlert {\n  id: string;\n  message: string;\n  details: string | null;\n  type: 'info' | 'warning' | 'error' | 'success';\n  is_read: boolean;\n  expires_at: string | null;\n  created_at: string;\n}\n\nexport interface DashboardStats {\n  totalEnquiries: number;\n  totalBookings: number;\n  totalRevenue: number;\n  pendingFollowUps: number;\n  activeTasks: number;\n  hotLeads: number;\n}\n\nexport const useDashboardData = () => {\n  const [tasks, setTasks] = useState<DashboardTask[]>([]);\n  const [alerts, setAlerts] = useState<DashboardAlert[]>([]);\n  const [stats, setStats] = useState<DashboardStats>({\n    totalEnquiries: 0,\n    totalBookings: 0,\n    totalRevenue: 0,\n    pendingFollowUps: 0,\n    activeTasks: 0,\n    hotLeads: 0\n  });\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const { toast } = useToast();\n\n  const fetchDashboardData = async () => {\n    try {\n      setLoading(true);\n\n      // Fetch tasks\n      const { data: tasksData, error: tasksError } = await supabase\n        .from('dashboard_tasks')\n        .select('*')\n        .order('due_date', { ascending: true });\n\n      if (tasksError) throw tasksError;\n\n      // Fetch alerts\n      const { data: alertsData, error: alertsError } = await supabase\n        .from('dashboard_alerts')\n        .select('*')\n        .eq('is_read', false)\n        .order('created_at', { ascending: false });\n\n      if (alertsError) throw alertsError;\n\n      // Fetch stats\n      const [enquiriesResult, bookingsResult, followUpsResult, leadsResult] = await Promise.all([\n        supabase.from('sales_enquiries').select('id, status'),\n        supabase.from('sales_bookings').select('id, total_amount'),\n        supabase.from('follow_ups').select('id').eq('status', 'pending'),\n        supabase.from('sales_leads').select('id').eq('status', 'qualified')\n      ]);\n\n      const totalEnquiries = enquiriesResult.data?.length || 0;\n      const totalBookings = bookingsResult.data?.length || 0;\n      const totalRevenue = bookingsResult.data?.reduce((sum, booking) => sum + (booking.total_amount || 0), 0) || 0;\n      const pendingFollowUps = followUpsResult.data?.length || 0;\n      const activeTasks = tasksData?.filter(task => task.status !== 'completed').length || 0;\n      const hotLeads = leadsResult.data?.length || 0;\n\n      setTasks((tasksData || []) as DashboardTask[]);\n      setAlerts((alertsData || []) as DashboardAlert[]);\n      setStats({\n        totalEnquiries,\n        totalBookings,\n        totalRevenue,\n        pendingFollowUps,\n        activeTasks,\n        hotLeads\n      });\n\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch dashboard data';\n      setError(errorMessage);\n      toast({\n        title: \"Error\",\n        description: errorMessage,\n        variant: \"destructive\",\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const createTask = async (taskData: Omit<DashboardTask, 'id' | 'created_at' | 'updated_at'>) => {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) throw new Error('User not authenticated');\n\n      const { data, error } = await supabase\n        .from('dashboard_tasks')\n        .insert([{\n          ...taskData,\n          created_by: user.id\n        }])\n        .select()\n        .single();\n\n      if (error) throw error;\n      \n      setTasks(prev => [data as DashboardTask, ...prev]);\n      \n      toast({\n        title: \"Success\",\n        description: \"Task created successfully\",\n      });\n      \n      return data;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to create task';\n      toast({\n        title: \"Error\",\n        description: errorMessage,\n        variant: \"destructive\",\n      });\n      throw err;\n    }\n  };\n\n  const updateTask = async (id: string, updates: Partial<DashboardTask>) => {\n    try {\n      const { data, error } = await supabase\n        .from('dashboard_tasks')\n        .update(updates)\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (error) throw error;\n      \n      setTasks(prev => prev.map(task => \n        task.id === id ? data as DashboardTask : task\n      ));\n      \n      toast({\n        title: \"Success\",\n        description: \"Task updated successfully\",\n      });\n      \n      return data;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to update task';\n      toast({\n        title: \"Error\",\n        description: errorMessage,\n        variant: \"destructive\",\n      });\n      throw err;\n    }\n  };\n\n  const markAlertAsRead = async (id: string) => {\n    try {\n      const { data, error } = await supabase\n        .from('dashboard_alerts')\n        .update({ is_read: true })\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (error) throw error;\n      \n      setAlerts(prev => prev.filter(alert => alert.id !== id));\n      \n      return data;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to mark alert as read';\n      toast({\n        title: \"Error\",\n        description: errorMessage,\n        variant: \"destructive\",\n      });\n      throw err;\n    }\n  };\n\n  useEffect(() => {\n    fetchDashboardData();\n  }, []);\n\n  return {\n    tasks,\n    alerts,\n    stats,\n    loading,\n    error,\n    fetchDashboardData,\n    createTask,\n    updateTask,\n    markAlertAsRead\n  };\n};","\nimport { useState, useEffect, useMemo } from 'react';\nimport { Agent } from '@/types/agent';\nimport { AgentStorageService } from '@/services/agentStorageService';\nimport { agents as defaultAgents } from '@/data/agentData';\n\nexport const useLocalAgentData = () => {\n  const [localAgents, setLocalAgents] = useState<Agent[]>([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const loadAgents = () => {\n      try {\n        const storedAgents = AgentStorageService.getAgents();\n        setLocalAgents(storedAgents);\n      } catch (error) {\n        console.error('Error loading agents:', error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadAgents();\n  }, []);\n\n  // Combine default agents with locally stored agents\n  const allAgents = useMemo(() => {\n    return [...defaultAgents, ...localAgents];\n  }, [localAgents]);\n\n  const saveAgent = (agentData: Omit<Agent, 'id'>) => {\n    try {\n      const savedAgent = AgentStorageService.saveAgent(agentData);\n      setLocalAgents(prev => [...prev, savedAgent]);\n      return savedAgent;\n    } catch (error) {\n      console.error('Error saving agent:', error);\n      throw error;\n    }\n  };\n\n  const updateAgent = (id: number, updates: Partial<Agent>) => {\n    try {\n      const updatedAgent = AgentStorageService.updateAgent(id, updates);\n      if (updatedAgent) {\n        setLocalAgents(prev => \n          prev.map(agent => agent.id === id ? updatedAgent : agent)\n        );\n      }\n      return updatedAgent;\n    } catch (error) {\n      console.error('Error updating agent:', error);\n      return null;\n    }\n  };\n\n  const deleteAgent = (id: number) => {\n    try {\n      const success = AgentStorageService.deleteAgent(id);\n      if (success) {\n        setLocalAgents(prev => prev.filter(agent => agent.id !== id));\n      }\n      return success;\n    } catch (error) {\n      console.error('Error deleting agent:', error);\n      return false;\n    }\n  };\n\n  return {\n    agents: allAgents,\n    localAgents,\n    saveAgent,\n    updateAgent,\n    deleteAgent,\n    loading\n  };\n};\n","\nimport { useMemo } from 'react';\nimport { useLocalAgentData } from '@/hooks/useLocalAgentData';\nimport { Agent } from '@/types/agent';\n\nexport const useAgentData = () => {\n  const { agents } = useLocalAgentData();\n\n  // Get active agents from the combined agent data (default + local)\n  const activeAgents = useMemo(() => {\n    return agents.filter((agent: Agent) => agent.status === 'active');\n  }, [agents]);\n\n  // Get agents by country\n  const getAgentsByCountry = (country: string) => {\n    return activeAgents.filter((agent: Agent) => \n      agent.country.toLowerCase() === country.toLowerCase()\n    );\n  };\n\n  // Get agents by city\n  const getAgentsByCity = (city: string) => {\n    return activeAgents.filter((agent: Agent) => \n      agent.city.toLowerCase() === city.toLowerCase()\n    );\n  };\n\n  // Get agent by ID\n  const getAgentById = (agentId: number) => {\n    return agents.find((agent: Agent) => agent.id === agentId);\n  };\n\n  // Get high-performing agents (based on conversion rate)\n  const getHighPerformingAgents = () => {\n    return activeAgents.filter((agent: Agent) => \n      agent.stats.conversionRate > 15\n    ).sort((a, b) => b.stats.conversionRate - a.stats.conversionRate);\n  };\n\n  return {\n    activeAgents,\n    getAgentsByCountry,\n    getAgentsByCity,\n    getAgentById,\n    getHighPerformingAgents,\n    totalActiveAgents: activeAgents.length,\n    totalAgents: agents.length\n  };\n};\n","\nimport { useEffect, useMemo, useState } from 'react';\nimport { StaffMember } from '@/types/assignment';\nimport { fetchEnhancedStaff } from '@/services/staffAssignmentService';\n\nexport const useEnhancedStaffData = () => {\n  const [enhancedStaffMembers, setEnhancedStaffMembers] = useState<StaffMember[]>([]);\n\n  useEffect(() => {\n    let ignore = false;\n    (async () => {\n      try {\n        const staff = await fetchEnhancedStaff();\n        if (!ignore) setEnhancedStaffMembers(staff);\n      } catch (e) {\n        if (!ignore) setEnhancedStaffMembers([]);\n      }\n    })();\n    return () => { ignore = true; };\n  }, []);\n\n  const activeStaff = useMemo(() => {\n    return enhancedStaffMembers.filter(staff => staff.active);\n  }, [enhancedStaffMembers]);\n\n  const getBestStaffForQuery = (destinations: string[], packageType: string) => {\n    // Enhanced matching logic\n    const scoredStaff = activeStaff.map(staff => {\n      let score = 0;\n      \n      // Destination expertise match\n      const destinationMatch = destinations.some(dest =>\n        staff.expertise.some(exp => \n          exp.toLowerCase().includes(dest.toLowerCase()) ||\n          dest.toLowerCase().includes(exp.toLowerCase())\n        )\n      );\n      if (destinationMatch) score += 50;\n      \n      // Package type match\n      const packageMatch = staff.specializations?.some(spec =>\n        spec.toLowerCase().includes(packageType.toLowerCase())\n      );\n      if (packageMatch) score += 30;\n      \n      // Workload factor (lower is better)\n      const workloadRatio = staff.assigned / staff.workloadCapacity;\n      score += (1 - workloadRatio) * 20;\n      \n      // Experience bonus\n      score += (staff.experience || 0) * 2;\n      \n      return { ...staff, matchScore: score };\n    });\n\n    return scoredStaff\n      .filter(staff => staff.assigned < staff.workloadCapacity)\n      .sort((a, b) => b.matchScore - a.matchScore);\n  };\n\n  const getStaffByDepartment = (department: string) => {\n    return activeStaff.filter(staff => staff.department === department);\n  };\n\n  const getAvailableStaff = () => {\n    return activeStaff.filter(staff => \n      staff.assigned < staff.workloadCapacity && staff.autoAssignEnabled\n    );\n  };\n\n  return {\n    activeStaff,\n    allStaff: enhancedStaffMembers,\n    enhancedStaffMembers,\n    getBestStaffForQuery,\n    getStaffByDepartment,\n    getAvailableStaff,\n    totalActiveStaff: activeStaff.length,\n    totalAvailableCapacity: activeStaff.reduce((sum, staff) =>\n      sum + (staff.workloadCapacity - staff.assigned), 0\n    )\n  };\n};\n","\nimport { useMemo } from 'react';\nimport { useSupabaseHotelsData } from '@/components/inventory/hotels/hooks/useSupabaseHotelsData';\nimport { useAgentData } from '@/hooks/useAgentData';\nimport { useEnhancedStaffData } from '@/hooks/useEnhancedStaffData';\nimport { mockQueries } from '@/data/queryData';\n\nexport interface ManagerDashboardStats {\n  totalStaff: number;\n  activeQueries: number;\n  totalHotels: number;\n  revenue: string;\n  pendingApprovals: number;\n  activeAgents: number;\n  completedBookings: number;\n  conversionRate: number;\n}\n\nexport interface QuickAction {\n  title: string;\n  description: string;\n  path: string;\n  count?: number;\n  priority?: 'high' | 'medium' | 'low';\n}\n\nexport interface ActivityItem {\n  id: string;\n  type: 'query' | 'booking' | 'staff' | 'system';\n  message: string;\n  user: string;\n  timestamp: string;\n  priority: 'high' | 'medium' | 'low';\n}\n\nexport const useManagerDashboardData = () => {\n  const { hotels } = useSupabaseHotelsData();\n  const { activeAgents, totalAgents } = useAgentData();\n  const { enhancedStaffMembers } = useEnhancedStaffData();\n\n  // Calculate real-time stats\n  const stats: ManagerDashboardStats = useMemo(() => {\n    const activeStaff = enhancedStaffMembers.filter(s => s.active);\n    const activeQueriesList = mockQueries.filter(q => \n      q.status === 'new' || q.status === 'assigned' || q.status === 'in-progress'\n    );\n    const confirmedBookings = mockQueries.filter(q => \n      q.status === 'confirmed' || q.status === 'converted'\n    );\n    const pendingProposals = mockQueries.filter(q => q.status === 'proposal-sent');\n    \n    // Calculate revenue from confirmed bookings\n    const totalRevenue = confirmedBookings.reduce((sum, query) => {\n      const basePrice = query.packageType === 'luxury' ? 2000 : \n                       query.packageType === 'business' ? 1500 : 1000;\n      return sum + (basePrice * query.paxDetails.adults * query.tripDuration.nights);\n    }, 0);\n\n    const conversionRate = mockQueries.length > 0 ? \n      (confirmedBookings.length / mockQueries.length) * 100 : 0;\n\n    return {\n      totalStaff: activeStaff.length,\n      activeQueries: activeQueriesList.length,\n      totalHotels: hotels.filter(h => h.status === 'active').length,\n      revenue: `$${(totalRevenue / 1000).toFixed(0)}K`,\n      pendingApprovals: pendingProposals.length + 5, // Include other approvals\n      activeAgents: activeAgents.length,\n      completedBookings: confirmedBookings.length,\n      conversionRate: Math.round(conversionRate)\n    };\n  }, [hotels, activeAgents, enhancedStaffMembers]);\n\n  // Generate quick actions with real counts\n  const quickActions: QuickAction[] = useMemo(() => [\n    {\n      title: 'Assign Queries',\n      description: 'Assign pending queries to staff',\n      path: '/queries/assign',\n      count: mockQueries.filter(q => q.status === 'new').length,\n      priority: 'high'\n    },\n    {\n      title: 'Staff Management',\n      description: 'Manage employees and departments',\n      path: '/management/staff',\n      count: enhancedStaffMembers.length\n    },\n    {\n      title: 'Proposal Management',\n      description: 'Review and approve proposals',\n      path: '/queries?status=proposal-sent',\n      count: mockQueries.filter(q => q.status === 'proposal-sent').length,\n      priority: 'medium'\n    },\n    {\n      title: 'Agent Management',\n      description: 'Manage travel agents',\n      path: '/management/agents',\n      count: totalAgents\n    },\n    {\n      title: 'Booking Management',\n      description: 'Monitor active bookings',\n      path: '/bookings',\n      count: mockQueries.filter(q => q.status === 'confirmed').length\n    },\n    {\n      title: 'HR Dashboard',\n      description: 'View HR analytics and reports',\n      path: '/management/staff/hr-dashboard'\n    }\n  ], [enhancedStaffMembers, totalAgents]);\n\n  // Generate recent activities from real data\n  const recentActivities: ActivityItem[] = useMemo(() => {\n    const activities: ActivityItem[] = [];\n    \n    // Add query-based activities\n    mockQueries.slice(0, 3).forEach(query => {\n      if (query.status === 'new') {\n        activities.push({\n          id: `query-${query.id}`,\n          type: 'query',\n          message: `New query received for ${query.destination.country}`,\n          user: query.agentName,\n          timestamp: query.createdAt.split('T')[0],\n          priority: 'high'\n        });\n      } else if (query.status === 'confirmed') {\n        activities.push({\n          id: `booking-${query.id}`,\n          type: 'booking',\n          message: `Booking confirmed for ${query.destination.country}`,\n          user: query.agentName,\n          timestamp: query.createdAt.split('T')[0],\n          priority: 'medium'\n        });\n      }\n    });\n\n    // Add staff activities\n    enhancedStaffMembers.slice(0, 2).forEach(staff => {\n      activities.push({\n        id: `staff-${staff.id}`,\n        type: 'staff',\n        message: `${staff.name} ${staff.active ? 'logged in' : 'went offline'}`,\n        user: staff.name,\n        timestamp: new Date().toISOString().split('T')[0],\n        priority: 'low'\n      });\n    });\n\n    return activities.sort((a, b) => \n      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n    ).slice(0, 6);\n  }, [enhancedStaffMembers]);\n\n  return {\n    stats,\n    quickActions,\n    recentActivities,\n    isLoading: false\n  };\n};\n","import { useEffect, useCallback, useState, useRef } from 'react';\nimport { StaffNotification } from '@/types/query';\nimport { realTimeNotificationService, NotificationSubscriber } from '@/services/realTimeNotificationService';\nimport { useStaffNotifications } from '@/contexts/StaffNotificationContext';\nimport { useApp } from '@/contexts/AppContext';\nimport { useToast } from '@/hooks/use-toast';\n\nexport interface RealTimeNotificationSettings {\n  enableWebSocket: boolean;\n  enablePushNotifications: boolean;\n  enableSoundNotifications: boolean;\n  enableToastNotifications: boolean;\n  autoConnect: boolean;\n  simulationMode: boolean;\n}\n\nexport interface UseRealTimeNotificationsReturn {\n  isConnected: boolean;\n  connectionStatus: any;\n  settings: RealTimeNotificationSettings;\n  updateSettings: (newSettings: Partial<RealTimeNotificationSettings>) => void;\n  connect: () => void;\n  disconnect: () => void;\n  requestPermissions: () => Promise<boolean>;\n  subscribeToPush: () => Promise<boolean>;\n  sendTestNotification: () => void;\n  startSimulation: () => void;\n  stopSimulation: () => void;\n}\n\nconst defaultSettings: RealTimeNotificationSettings = {\n  enableWebSocket: false, // Disabled by default since no WebSocket server is running\n  enablePushNotifications: true,\n  enableSoundNotifications: true,\n  enableToastNotifications: true,\n  autoConnect: true,\n  simulationMode: false\n};\n\nexport const useRealTimeNotifications = (): UseRealTimeNotificationsReturn => {\n  const { currentUser } = useApp();\n  const { addNotification } = useStaffNotifications();\n  const { toast } = useToast();\n  \n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState(realTimeNotificationService.getConnectionStatus());\n  const [settings, setSettings] = useState<RealTimeNotificationSettings>(() => {\n    const saved = localStorage.getItem('realTimeNotificationSettings');\n    return saved ? { ...defaultSettings, ...JSON.parse(saved) } : defaultSettings;\n  });\n  \n  const subscriberRef = useRef<(() => void) | null>(null);\n  const simulationIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Save settings to localStorage whenever they change\n  useEffect(() => {\n    localStorage.setItem('realTimeNotificationSettings', JSON.stringify(settings));\n    realTimeNotificationService.updateConfig({\n      enableWebSocket: settings.enableWebSocket,\n      enablePushNotifications: settings.enablePushNotifications,\n      enableSoundNotifications: settings.enableSoundNotifications\n    });\n  }, [settings]);\n\n  // Auto-connect when user is available and settings allow\n  useEffect(() => {\n    if (currentUser && settings.autoConnect && settings.enableWebSocket) {\n      connect();\n    }\n\n    return () => {\n      disconnect();\n    };\n  }, [currentUser, settings.autoConnect, settings.enableWebSocket]);\n\n  // Subscribe to real-time notifications\n  useEffect(() => {\n    if (currentUser) {\n      const subscriber: NotificationSubscriber = {\n        id: `user_${currentUser.id}`,\n        callback: handleNewNotification,\n        filters: {\n          staffIds: [currentUser.id]\n        }\n      };\n\n      subscriberRef.current = realTimeNotificationService.subscribe(subscriber);\n\n      return () => {\n        if (subscriberRef.current) {\n          subscriberRef.current();\n        }\n      };\n    }\n  }, [currentUser]);\n\n  // Update connection status periodically\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setConnectionStatus(realTimeNotificationService.getConnectionStatus());\n      setIsConnected(realTimeNotificationService.getConnectionStatus().isConnected);\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, []);\n\n  // Handle new notification\n  const handleNewNotification = useCallback((notification: StaffNotification) => {\n    // Add to notification context\n    addNotification(notification);\n\n    // Show toast notification if enabled\n    if (settings.enableToastNotifications) {\n      toast({\n        title: notification.title,\n        description: notification.message,\n        variant: notification.priority === 'urgent' ? 'destructive' : 'default',\n        duration: notification.priority === 'urgent' ? 0 : 5000, // Urgent notifications don't auto-dismiss\n      });\n    }\n  }, [addNotification, toast, settings.enableToastNotifications]);\n\n  // Connect to real-time service\n  const connect = useCallback(() => {\n    if (currentUser && settings.enableWebSocket) {\n      realTimeNotificationService.connect(currentUser.id);\n    }\n  }, [currentUser, settings.enableWebSocket]);\n\n  // Disconnect from real-time service\n  const disconnect = useCallback(() => {\n    realTimeNotificationService.disconnect();\n    setIsConnected(false);\n  }, []);\n\n  // Request notification permissions\n  const requestPermissions = useCallback(async (): Promise<boolean> => {\n    try {\n      const granted = await realTimeNotificationService.requestNotificationPermission();\n      \n      if (granted) {\n        toast({\n          title: 'Notifications Enabled',\n          description: 'You will now receive real-time notifications',\n        });\n      } else {\n        toast({\n          title: 'Notifications Disabled',\n          description: 'Please enable notifications in your browser settings',\n          variant: 'destructive',\n        });\n      }\n      \n      return granted;\n    } catch (error) {\n      console.error('Failed to request notification permissions:', error);\n      toast({\n        title: 'Permission Error',\n        description: 'Failed to request notification permissions',\n        variant: 'destructive',\n      });\n      return false;\n    }\n  }, [toast]);\n\n  // Subscribe to push notifications\n  const subscribeToPush = useCallback(async (): Promise<boolean> => {\n    if (!currentUser) return false;\n\n    try {\n      const subscription = await realTimeNotificationService.subscribeToPushNotifications(currentUser.id);\n      \n      if (subscription) {\n        toast({\n          title: 'Push Notifications Enabled',\n          description: 'You will receive notifications even when the app is closed',\n        });\n        return true;\n      } else {\n        toast({\n          title: 'Push Notifications Failed',\n          description: 'Could not enable push notifications',\n          variant: 'destructive',\n        });\n        return false;\n      }\n    } catch (error) {\n      console.error('Failed to subscribe to push notifications:', error);\n      toast({\n        title: 'Push Subscription Error',\n        description: 'Failed to enable push notifications',\n        variant: 'destructive',\n      });\n      return false;\n    }\n  }, [currentUser, toast]);\n\n  // Send test notification\n  const sendTestNotification = useCallback(() => {\n    if (!currentUser) return;\n\n    const testNotification: Omit<StaffNotification, 'id' | 'timestamp'> = {\n      staffId: currentUser.id,\n      queryId: 'test_query',\n      type: 'assignment',\n      title: 'Test Notification',\n      message: 'This is a test notification to verify your settings are working correctly.',\n      read: false,\n      actionRequired: false,\n      priority: 'normal',\n      actionUrl: '/notifications'\n    };\n\n    realTimeNotificationService.sendNotification(testNotification);\n    \n    toast({\n      title: 'Test Notification Sent',\n      description: 'Check if you received the test notification',\n    });\n  }, [currentUser, toast]);\n\n  // Start simulation mode\n  const startSimulation = useCallback(() => {\n    if (!currentUser) return;\n\n    realTimeNotificationService.startSimulation(currentUser.id);\n    setSettings(prev => ({ ...prev, simulationMode: true }));\n    \n    toast({\n      title: 'Simulation Started',\n      description: 'Demo notifications will be generated every 10 seconds',\n    });\n  }, [currentUser, toast]);\n\n  // Stop simulation mode\n  const stopSimulation = useCallback(() => {\n    if (simulationIntervalRef.current) {\n      clearInterval(simulationIntervalRef.current);\n      simulationIntervalRef.current = null;\n    }\n    \n    setSettings(prev => ({ ...prev, simulationMode: false }));\n    \n    toast({\n      title: 'Simulation Stopped',\n      description: 'Demo notifications have been disabled',\n    });\n  }, [toast]);\n\n  // Update settings\n  const updateSettings = useCallback((newSettings: Partial<RealTimeNotificationSettings>) => {\n    setSettings(prev => ({ ...prev, ...newSettings }));\n  }, []);\n\n  return {\n    isConnected,\n    connectionStatus,\n    settings,\n    updateSettings,\n    connect,\n    disconnect,\n    requestPermissions,\n    subscribeToPush,\n    sendTestNotification,\n    startSimulation,\n    stopSimulation\n  };\n};","import { useCallback, useEffect, useMemo, useState } from 'react';\nimport { supabase } from '@/lib/supabaseClient';\n\nexport interface AgentProfileRow {\n  id?: string;\n  user_id?: string;\n  name?: string | null;\n  email?: string | null;\n  profile_image?: string | null;\n  agency_name?: string | null;\n  business_type?: string | null;\n  business_phone?: string | null;\n  business_address?: string | null;\n  country?: string | null;\n  city?: string | null;\n  status?: 'pending' | 'active' | 'inactive' | 'approved' | 'rejected' | 'suspended' | string | null;\n  updated_at?: string | null;\n}\n\nexport interface AgentProfileGuardResult {\n  loading: boolean;\n  error: string | null;\n  agent: AgentProfileRow | null;\n  completion: number; // 0..100\n  status: string | null;\n  shouldRedirect: boolean;\n  shouldPopup: boolean;\n  refresh: () => Promise<void>;\n}\n\nfunction isFilled(v: any): boolean {\n  if (v === null || v === undefined) return false;\n  if (Array.isArray(v)) return v.length > 0;\n  if (typeof v === 'string') return v.trim().length > 0;\n  return true;\n}\n\nexport function useAgentProfileGuard(thresholdPercent: number = 50): AgentProfileGuardResult {\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [agent, setAgent] = useState<AgentProfileRow | null>(null);\n\n  const fetchAgent = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const { data: auth } = await supabase.auth.getUser();\n      const uid = auth?.user?.id;\n      if (!uid) {\n        setAgent(null);\n        setError('Not authenticated');\n        return;\n      }\n      const { data, error: agentErr } = await supabase\n        .from('agents')\n        .select('*')\n        .eq('user_id', uid)\n        .maybeSingle();\n      if (agentErr) {\n        setError(agentErr.message || 'Failed to load agent');\n        setAgent(null);\n      } else {\n        setAgent((data || null) as AgentProfileRow | null);\n      }\n    } catch (e: any) {\n      setError(e?.message || 'Unexpected error');\n      setAgent(null);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => { fetchAgent(); }, [fetchAgent]);\n\n  const completion = useMemo(() => {\n    const fields: (keyof AgentProfileRow)[] = [\n      'profile_image',\n      'agency_name',\n      'business_type',\n      'business_phone',\n      'name',\n      'city',\n      'country',\n      'business_address',\n    ];\n    if (!agent) return 0;\n    const filled = fields.reduce((acc, key) => acc + (isFilled((agent as any)[key]) ? 1 : 0), 0);\n    return Math.round((filled / fields.length) * 100);\n  }, [agent]);\n\n  const status = useMemo(() => (agent?.status ?? null) as string | null, [agent]);\n\n  // Business rules:\n  // - Redirect if status is not 'active'.\n  // - Show popup if status is 'active' but completion < threshold.\n  const shouldRedirect = useMemo(() => {\n    if (status === null) return false; // unknown -> let them pass\n    return (status?.toLowerCase() !== 'active');\n  }, [status]);\n\n  const shouldPopup = useMemo(() => {\n    if ((status || '').toLowerCase() !== 'active') return false;\n    return completion < thresholdPercent;\n  }, [status, completion, thresholdPercent]);\n\n  return { loading, error, agent, completion, status, shouldRedirect, shouldPopup, refresh: fetchAgent };\n}","import { useState, useEffect, useMemo } from 'react';\nimport { CountryEnquirySettings } from '../types/enquiry';\nimport { Country } from '../pages/inventory/countries/types/country';\nimport { initialCountries } from '../pages/inventory/countries/data/countryData';\nimport { useApplicationSettings } from '../contexts/ApplicationSettingsContext';\n\nexport interface CountryOption {\n  id: string;\n  name: string;\n  code: string;\n  isConfigured: boolean;\n  enquiryConfig?: CountryEnquirySettings;\n}\n\nexport const useCountriesEnquiryIntegration = () => {\n  const { settings, addCountry, updateCountry, removeCountry, setDefaultCountry } = useApplicationSettings();\n  const [activeCountries, setActiveCountries] = useState<Country[]>([]);\n\n  // Load active countries from Countries Management module\n  useEffect(() => {\n    const activeCountriesFromModule = initialCountries.filter(country => country.status === 'active');\n    setActiveCountries(activeCountriesFromModule);\n  }, []);\n\n  // Create country options that combine inventory countries with enquiry settings\n  const countryOptions = useMemo(() => {\n    return activeCountries.map(country => {\n      const enquiryConfig = settings.enquirySettings.countries.find(\n        config => config.countryCode === country.code\n      );\n      \n      return {\n        id: country.id,\n        name: country.name,\n        code: country.code,\n        isConfigured: !!enquiryConfig,\n        enquiryConfig\n      };\n    });\n  }, [activeCountries, settings.enquirySettings.countries]);\n\n  // Get available countries for new enquiry configuration (not yet configured)\n  const availableCountries = useMemo(() => {\n    return countryOptions.filter(option => !option.isConfigured);\n  }, [countryOptions]);\n\n  // Get configured countries\n  const configuredCountries = useMemo(() => {\n    return settings.enquirySettings.countries.filter(config => {\n      // Only include configurations for countries that are still active in inventory\n      return activeCountries.some(country => country.code === config.countryCode && country.status === 'active');\n    });\n  }, [settings.enquirySettings.countries, activeCountries]);\n\n  // Auto-populate country details when creating new enquiry config\n  const getCountryDetailsForConfig = (countryCode: string) => {\n    const country = activeCountries.find(c => c.code === countryCode);\n    if (!country) return null;\n\n    return {\n      countryCode: country.code,\n      countryName: country.name,\n      prefix: country.code + 'Q', // Auto-suggest prefix\n      yearFormat: 'YYYY' as const,\n      yearSeparator: 'none' as const,\n      numberLength: 4,\n      numberSeparator: 'none' as const,\n      startingNumber: 1,\n      isDefault: false,\n      isActive: true\n    };\n  };\n\n  // Validate if country is still active when processing enquiry\n  const validateCountryForEnquiry = (countryCode: string): boolean => {\n    const country = activeCountries.find(c => c.code === countryCode);\n    const enquiryConfig = settings.enquirySettings.countries.find(c => c.countryCode === countryCode);\n    \n    return !!(country && country.status === 'active' && enquiryConfig && enquiryConfig.isActive);\n  };\n\n  // Sync enquiry configurations with active countries\n  const syncEnquiryWithActiveCountries = () => {\n    // Avoid deactivating configs during initial load before active countries are available\n    if (activeCountries.length === 0) {\n      return;\n    }\n    const activeCountryCodes = activeCountries.map(c => c.code);\n    const currentEnquiryCountries = settings.enquirySettings.countries;\n\n    // Mark configurations as inactive if their countries are no longer active\n    currentEnquiryCountries.forEach(config => {\n      if (!activeCountryCodes.includes(config.countryCode) && config.isActive) {\n        updateCountry(config.countryCode, { isActive: false });\n      }\n    });\n  };\n\n  // Enhanced add country with auto-population\n  const addCountryWithDetails = (countryCode: string, customConfig?: Partial<CountryEnquirySettings>) => {\n    const baseConfig = getCountryDetailsForConfig(countryCode);\n    if (!baseConfig) {\n      throw new Error('Country not found in active countries');\n    }\n\n    const finalConfig = { ...baseConfig, ...customConfig };\n    return addCountry(finalConfig);\n  };\n\n  return {\n    activeCountries,\n    countryOptions,\n    availableCountries,\n    configuredCountries,\n    getCountryDetailsForConfig,\n    validateCountryForEnquiry,\n    syncEnquiryWithActiveCountries,\n    addCountryWithDetails,\n    updateCountry,\n    removeCountry,\n    setDefaultCountry,\n    enquirySettings: settings.enquirySettings\n  };\n};","import { useState, useEffect, useCallback, useRef } from 'react';\nimport { seoService, EnhancedProfile, ProfileActivityLog } from '@/services/seoService';\n\nexport function useEnhancedProfile(userId?: string) {\n  const [profile, setProfile] = useState<EnhancedProfile | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [saving, setSaving] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [lastSaved, setLastSaved] = useState<Date | null>(null);\n  \n  // Auto-save functionality\n  const autoSaveRef = useRef<((data: Partial<EnhancedProfile>) => void) | null>(null);\n\n  // Load profile\n  const loadProfile = useCallback(async () => {\n    if (!userId) return;\n    \n    try {\n      setLoading(true);\n      setError(null);\n      const profileData = await seoService.getEnhancedProfile(userId);\n      setProfile(profileData);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load profile');\n    } finally {\n      setLoading(false);\n    }\n  }, [userId]);\n\n  // Save profile\n  const saveProfile = useCallback(async (updates: Partial<EnhancedProfile>) => {\n    if (!userId) return null;\n    \n    try {\n      setSaving(true);\n      setError(null);\n      \n      const updatedProfile = await seoService.upsertEnhancedProfile({\n        ...updates,\n        user_id: userId\n      });\n      \n      if (updatedProfile) {\n        setProfile(updatedProfile);\n        setLastSaved(new Date());\n        return updatedProfile;\n      }\n      throw new Error('Failed to save profile');\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to save profile');\n      throw err;\n    } finally {\n      setSaving(false);\n    }\n  }, [userId]);\n\n  // Auto-save with debouncing\n  const autoSave = useCallback((updates: Partial<EnhancedProfile>) => {\n    if (autoSaveRef.current) {\n      autoSaveRef.current(updates);\n    }\n  }, []);\n\n  // Update profile field (with auto-save)\n  const updateField = useCallback((field: keyof EnhancedProfile, value: any) => {\n    if (!profile) return;\n    \n    const updatedProfile = { ...profile, [field]: value };\n    setProfile(updatedProfile);\n    \n    // Trigger auto-save\n    autoSave({ [field]: value });\n  }, [profile, autoSave]);\n\n  // Update multiple fields at once\n  const updateFields = useCallback((updates: Partial<EnhancedProfile>) => {\n    if (!profile) return;\n    \n    const updatedProfile = { ...profile, ...updates };\n    setProfile(updatedProfile);\n    \n    // Trigger auto-save\n    autoSave(updates);\n  }, [profile, autoSave]);\n\n  // Initialize auto-save\n  useEffect(() => {\n    if (userId) {\n      autoSaveRef.current = seoService.createAutoSave(\n        `profile_${userId}`,\n        saveProfile,\n        1500 // 1.5 second debounce\n      );\n    }\n  }, [userId, saveProfile]);\n\n  // Load profile on mount\n  useEffect(() => {\n    loadProfile();\n  }, [loadProfile]);\n\n  // Subscribe to real-time updates\n  useEffect(() => {\n    if (!userId) return;\n\n    const subscription = seoService.subscribeToEnhancedProfile(userId, (updatedProfile) => {\n      setProfile(updatedProfile);\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [userId]);\n\n  return {\n    profile,\n    loading,\n    saving,\n    error,\n    lastSaved,\n    saveProfile,\n    updateField,\n    updateFields,\n    refreshProfile: loadProfile\n  };\n}\n\nexport function useProfileActivity(userId?: string, limit: number = 50) {\n  const [activityLog, setActivityLog] = useState<ProfileActivityLog[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const loadActivityLog = useCallback(async () => {\n    if (!userId) return;\n    \n    try {\n      setLoading(true);\n      setError(null);\n      const logs = await seoService.getProfileActivityLog(userId, limit);\n      setActivityLog(logs);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load activity log');\n    } finally {\n      setLoading(false);\n    }\n  }, [userId, limit]);\n\n  useEffect(() => {\n    loadActivityLog();\n  }, [loadActivityLog]);\n\n  return {\n    activityLog,\n    loading,\n    error,\n    refreshActivityLog: loadActivityLog\n  };\n}\n\n// Hook for form validation and enhanced features\nexport function useProfileValidation() {\n  const validateEmail = useCallback((email: string): boolean => {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }, []);\n\n  const validatePhone = useCallback((phone: string): boolean => {\n    const phoneRegex = /^[\\+]?[1-9][\\d]{0,15}$/;\n    return phoneRegex.test(phone.replace(/[\\s\\-\\(\\)]/g, ''));\n  }, []);\n\n  const validateRequired = useCallback((value: any): boolean => {\n    return value !== null && value !== undefined && value !== '';\n  }, []);\n\n  const validateProfile = useCallback((profile: Partial<EnhancedProfile>) => {\n    const errors: Record<string, string> = {};\n\n    if (profile.first_name && profile.first_name.length < 2) {\n      errors.first_name = 'First name must be at least 2 characters';\n    }\n\n    if (profile.last_name && profile.last_name.length < 2) {\n      errors.last_name = 'Last name must be at least 2 characters';\n    }\n\n    if (profile.phone && !validatePhone(profile.phone)) {\n      errors.phone = 'Please enter a valid phone number';\n    }\n\n    if (profile.bio && profile.bio.length > 500) {\n      errors.bio = 'Bio must be less than 500 characters';\n    }\n\n    return {\n      isValid: Object.keys(errors).length === 0,\n      errors\n    };\n  }, [validatePhone]);\n\n  return {\n    validateEmail,\n    validatePhone,\n    validateRequired,\n    validateProfile\n  };\n}","\nimport { useEffect, useState } from 'react';\nimport { AssignmentRule, AssignmentRuleType, StaffMember } from '@/types/assignment';\nimport { Query } from '@/types/query';\nimport { useToast } from '@/hooks/use-toast';\nimport { useEnhancedStaffData } from '@/hooks/useEnhancedStaffData';\nimport { useAgentData } from '@/hooks/useAgentData';\nimport { getBestCountryMatch, getAssignmentReason } from '@/services/countryAssignmentService';\nimport { agentStaffRelationships } from '@/data/staffData';\nimport { assignEnquiry } from '@/services/enquiriesService';\nimport { assignQuery as assignQueryEngine } from '@/services/autoAssignmentEngine';\nimport { findBestStaffMatch as findBestStaffMatchService } from '@/services/staffAssignmentService';\nimport { AppSettingsService, AppSettingsHelpers } from '@/services/appSettingsService_database';\n\nconst AUTO_ASSIGN_SETTING_ID = 'b57de51f-9bb0-4a1f-b89a-415c9c57ad3f';\n\nexport const useQueryAssignment = () => {\n  const [assigningQuery, setAssigningQuery] = useState<Query | null>(null);\n  const [isAssigning, setIsAssigning] = useState(false);\n  const [selectedStaffId, setSelectedStaffId] = useState<number | null>(null);\n  const [autoAssignEnabled, setAutoAssignEnabledState] = useState<boolean | null>(null);\n  const [autoAssignHydrated, setAutoAssignHydrated] = useState(false);\n  const { toast } = useToast();\n  \n  const { getBestStaffForQuery, enhancedStaffMembers: enhancedStaff, activeStaff } = useEnhancedStaffData();\n  const { getAgentById } = useAgentData();\n\n  // Hydrate auto-assign enabled from App Settings by UUID (with safe fallback)\n  useEffect(() => {\n    (async () => {\n      try {\n        const byId = await AppSettingsService.getSettingById(AUTO_ASSIGN_SETTING_ID);\n        if (byId.success && byId.data) {\n          const raw = byId.data.setting_value ?? byId.data.setting_json;\n          const enabled = typeof raw === 'boolean' ? raw : String(raw ?? '').toLowerCase() === 'true';\n          setAutoAssignEnabledState(enabled);\n          setAutoAssignHydrated(true);\n          return;\n        }\n        // Fallback to category/key value if ID lookup didn't find data\n        const val = await AppSettingsService.getSettingValue('assignment', 'auto_assign_enabled');\n        const enabled = typeof val === 'boolean' ? val : String(val ?? '').toLowerCase() === 'true';\n        setAutoAssignEnabledState(enabled);\n        setAutoAssignHydrated(true);\n      } catch (e) {\n        console.warn('useQueryAssignment: failed to hydrate auto_assign_enabled', e);\n        // Default safely to disabled when hydration fails\n        setAutoAssignEnabledState(false);\n        setAutoAssignHydrated(true);\n      }\n    })();\n  }, []);\n\n  // Setter that also persists to App Settings\n  const setAutoAssignEnabled = async (checked: boolean) => {\n    setAutoAssignEnabledState(checked);\n    try {\n      // Prefer updating the specific record by UUID\n      const res = await AppSettingsService.updateSettingById(AUTO_ASSIGN_SETTING_ID, {\n        setting_value: checked ? 'true' : 'false',\n        is_active: true\n      });\n      if (!res.success) {\n        // Fallback to upsert by category/key\n        await AppSettingsHelpers.upsertSetting({\n          category: 'assignment',\n          setting_key: 'auto_assign_enabled',\n          setting_value: checked ? 'true' : 'false',\n          is_active: true\n        });\n      }\n    } catch (e) {\n      console.warn('useQueryAssignment: failed to persist auto_assign_enabled', e);\n    }\n  };\n\n  // Enhanced function to find the best staff match with country priority\n  const findBestStaffMatch = (query: Query): StaffMember | null => {\n    // Use service-level matching with country priority and enhanced scoring\n    return findBestStaffMatchService(query, enhancedStaff);\n  };\n\n  // Enhanced assignment rule application\n  const applyAssignmentRule = (\n    rule: AssignmentRule, \n    query: Query, \n    staff: StaffMember[]\n  ): StaffMember | null => {\n    switch (rule.type) {\n      case 'agent-staff-relationship':\n        // Check if the agent has a dedicated staff member\n        const relationship = agentStaffRelationships.find(rel => \n          rel.agentId === Number(query.agentId) && \n          staff.some(s => s.id === rel.staffId)\n        );\n        if (relationship) {\n          const dedicatedStaff = staff.find(s => s.id === relationship.staffId);\n          if (dedicatedStaff && dedicatedStaff.assigned < dedicatedStaff.workloadCapacity) {\n            return dedicatedStaff;\n          }\n        }\n        return null;\n\n      case 'expertise-match':\n        // Enhanced expertise matching for destinations\n        const destinations = [query.destination.country, ...query.destination.cities];\n        const expertsForDestination = staff.filter(s => \n          destinations.some(dest =>\n            s.expertise.some(exp => \n              exp.toLowerCase().includes(dest.toLowerCase())\n            )\n          )\n        );\n        \n        if (expertsForDestination.length > 0) {\n          // Sort by experience and workload\n          return expertsForDestination.sort((a, b) => {\n            const aLoad = a.assigned / a.workloadCapacity;\n            const bLoad = b.assigned / b.workloadCapacity;\n            const expertiseMatch = b.expertise.length - a.expertise.length;\n            return aLoad - bLoad + (expertiseMatch * 0.1);\n          })[0];\n        }\n        return null;\n\n      case 'workload-balance':\n        return staff\n          .filter(s => s.assigned < s.workloadCapacity)\n          .sort((a, b) => (a.assigned / a.workloadCapacity) - (b.assigned / b.workloadCapacity))[0];\n\n      case 'round-robin':\n        const sequencedStaff = [...staff]\n          .filter(s => s.assigned < s.workloadCapacity)\n          .sort((a, b) => (a.sequenceOrder || 999) - (b.sequenceOrder || 999));\n        return sequencedStaff[0];\n\n      default:\n        return null;\n    }\n  };\n\n  // Assign a query to staff (manual)\n  const assignQueryToStaff = async (query: Query, staffId: number, assignedBy?: string) => {\n    setIsAssigning(true);\n    try {\n      const staff = activeStaff.find(s => s.id === staffId) || enhancedStaff.find(s => s.id === staffId);\n      if (!staff) throw new Error('Staff not found');\n      // Always use the Supabase UUID when available to avoid collisions\n      const staffIdentifier = String((staff as any)?.uuid ?? staff.id);\n      // Prefix reason to track whether the user selected the recommended staff or made a manual selection\n      const recommended = findBestStaffMatchService(query, enhancedStaff);\n      const selectionPrefix = recommended && recommended.id === staff.id ? 'Recommended' : 'Manual Selection';\n      const reason = `${selectionPrefix} \u0013 ${getAssignmentReason(staff, query)}`;\n\n      const safeReason = `${selectionPrefix} - ${getAssignmentReason(staff, query)}`;\n      const { error } = await assignEnquiry(query.id, staffIdentifier, assignedBy, safeReason, false);\n      if (error) throw error;\n\n      const agent = getAgentById(Number(query.agentId) || 0);\n      toast({\n        title: 'Query Assigned Successfully',\n        description: `Query ${query.id} assigned to ${staff.name} (${safeReason})${agent ? ` for agent ${agent.name}` : ''}`,\n      });\n    } catch (e: any) {\n      toast({\n        title: 'Assignment Failed',\n        description: e?.message || 'Unable to assign enquiry',\n        variant: 'destructive',\n      });\n    } finally {\n      setIsAssigning(false);\n      setAssigningQuery(null);\n      setSelectedStaffId(null);\n    }\n  };\n\n  // Enhanced auto-assign with country-based matching\n  const autoAssignQueries = async (queries: Query[]) => {\n    if (!autoAssignHydrated || autoAssignEnabled !== true) {\n      toast({\n        title: !autoAssignHydrated ? 'Settings loading' : 'Auto-assignment disabled',\n        description: !autoAssignHydrated ? 'Please wait while settings load' : 'Please enable auto-assignment to use this feature',\n        variant: 'destructive',\n      });\n      return;\n    }\n\n    setIsAssigning(true);\n    try {\n      let successCount = 0;\n      for (const query of queries) {\n        // Use the new engine which applies: Country Expertise  AgentStaff Relationship  Workload Balance  Round Robin\n        await assignQueryEngine(query.id);\n        // We assume success if engine runs without throwing; the engine internally persists via assignEnquiry\n        successCount += 1;\n      }\n\n      toast({\n        title: 'Auto-Assignment Completed',\n        description: `Processed ${successCount} queries using advanced rule hierarchy`,\n      });\n    } finally {\n      setIsAssigning(false);\n    }\n  };\n\n  // Get assignment rule that would apply to this query with country priority\n  const getApplicableRule = (query: Query): AssignmentRuleType | null => {\n    const active = enhancedStaff.filter(staff => staff.active);\n    const countryMatch = getBestCountryMatch(active, query);\n    if (countryMatch) return 'expertise-match';\n    return 'workload-balance';\n  };\n\n  return {\n    assigningQuery,\n    isAssigning,\n    selectedStaffId,\n    autoAssignEnabled,\n    autoAssignHydrated,\n    setAssigningQuery,\n    setSelectedStaffId,\n    setAutoAssignEnabled,\n    assignQueryToStaff,\n    autoAssignQueries,\n    findBestStaffMatch,\n    getApplicableRule\n  };\n};\n","\nimport { useMemo } from 'react';\nimport { useEnhancedStaffData } from '@/hooks/useEnhancedStaffData';\nimport { StaffMember } from '@/types/assignment';\n\nexport interface EnhancedStaffWithWorkload extends StaffMember {\n  id: number;\n  name: string;\n  role: string;\n  email: string;\n  department: string;\n  status: string;\n  assigned: number;\n  workloadCapacity: number;\n  expertise: string[];\n  active: boolean;\n  avatar: string;\n  availability: any[];\n  autoAssignEnabled: boolean;\n  sequenceOrder?: number;\n}\n\nexport const useActiveStaffData = () => {\n  const { enhancedStaffMembers } = useEnhancedStaffData();\n\n  const activeStaff = useMemo(() => {\n    return enhancedStaffMembers.map((staff): EnhancedStaffWithWorkload => ({\n      ...staff,\n      status: staff.active ? 'active' : 'inactive'\n    }));\n  }, [enhancedStaffMembers]);\n\n  const getAvailableStaff = () => {\n    return activeStaff.filter(staff => staff.assigned < staff.workloadCapacity && staff.active);\n  };\n\n  return {\n    activeStaff,\n    getAvailableStaff\n  };\n};\n","import { useState, useEffect } from 'react';\nimport { CountriesService } from '@/services/countriesService';\nimport { mapDbCountriesToFrontend } from '@/services/countryMapper';\nimport { Country } from '@/pages/inventory/countries/types/country';\n\ninterface UseRealTimeCountriesDataReturn {\n  countries: Country[];\n  activeCountries: Country[];\n  loading: boolean;\n  error: string | null;\n  refreshCountries: () => Promise<void>;\n  getCountryByCode: (code: string) => Country | undefined;\n  getCountryByName: (name: string) => Country | undefined;\n  getCountryById: (id: string) => Country | undefined;\n}\n\n/**\n * Centralized hook for accessing real-time countries data from Supabase\n * This replaces the need for static initialCountries data across the application\n */\nexport const useRealTimeCountriesData = (): UseRealTimeCountriesDataReturn => {\n  const [countries, setCountries] = useState<Country[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const loadCountries = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const response = await CountriesService.getAllCountries();\n      \n      if (response.success && response.data) {\n        const mappedCountries = mapDbCountriesToFrontend(response.data);\n        setCountries(mappedCountries);\n      } else {\n        setError(response.error || 'Failed to load countries');\n        setCountries([]);\n      }\n    } catch (err) {\n      console.error('Error loading countries:', err);\n      setError('An unexpected error occurred while loading countries');\n      setCountries([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    loadCountries();\n  }, []);\n\n  // Derived data\n  const activeCountries = countries.filter(country => country.status === 'active');\n\n  // Helper functions\n  const getCountryByCode = (code: string): Country | undefined => {\n    return countries.find(country => \n      country.code.toLowerCase() === code.toLowerCase()\n    );\n  };\n\n  const getCountryByName = (name: string): Country | undefined => {\n    return countries.find(country => \n      country.name.toLowerCase() === name.toLowerCase()\n    );\n  };\n\n  const getCountryById = (id: string): Country | undefined => {\n    return countries.find(country => country.id === id);\n  };\n\n  const refreshCountries = async () => {\n    await loadCountries();\n  };\n\n  return {\n    countries,\n    activeCountries,\n    loading,\n    error,\n    refreshCountries,\n    getCountryByCode,\n    getCountryByName,\n    getCountryById\n  };\n};\n\n// Export a singleton instance for components that need immediate access\nlet cachedCountriesData: Country[] = [];\nlet isLoading = false;\n\nexport const getCachedCountriesData = async (): Promise<Country[]> => {\n  if (cachedCountriesData.length > 0) {\n    return cachedCountriesData;\n  }\n\n  if (isLoading) {\n    // Wait for the current loading to complete\n    while (isLoading) {\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    return cachedCountriesData;\n  }\n\n  try {\n    isLoading = true;\n    const response = await CountriesService.getAllCountries();\n    \n    if (response.success && response.data) {\n      cachedCountriesData = mapDbCountriesToFrontend(response.data);\n    }\n    \n    return cachedCountriesData;\n  } catch (error) {\n    console.error('Error loading cached countries data:', error);\n    return [];\n  } finally {\n    isLoading = false;\n  }\n};\n\n// Helper function to get active countries from cache\nexport const getCachedActiveCountries = async (): Promise<Country[]> => {\n  const countries = await getCachedCountriesData();\n  return countries.filter(country => country.status === 'active');\n};","import { useEffect, useState, useCallback } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { Agent } from '@/types/agent';\nimport { agents as defaultAgents } from '@/data/agentData';\nimport { AgentStorageService } from '@/services/agentStorageService';\n\nexport interface SupabaseAgentOption {\n  id: string;\n  name: string;\n  agencyName?: string;\n  email?: string;\n  phone?: string;\n  agent_code?: string;\n  country?: string;\n  city?: string;\n  status?: string;\n  profile_image?: string;\n  // Keep shape compatible with UI that expects stats\n  stats: {\n    totalQueries: number;\n    totalBookings: number;\n    conversionRate: number;\n    revenueGenerated: number;\n    averageBookingValue: number;\n    activeCustomers: number;\n  };\n}\n\n/**\n * Loads active agents from Supabase by joining public.agents with public.profiles.\n * Filters to status = 'active' (and optionally profiles.status = 'active').\n * Returns a simplified list of agent options for dropdown usage.\n */\nexport function useSupabaseAgentsList() {\n  const [agents, setAgents] = useState<SupabaseAgentOption[]>([]);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Map local Agent type to SupabaseAgentOption for UI compatibility\n  const mapLocalAgent = (agent: Agent): SupabaseAgentOption => {\n    return {\n      id: String(agent.id),\n      name: agent.name,\n      agencyName: agent.type === 'company' ? agent.name : undefined,\n      email: agent.email || agent.contact?.email,\n      phone: agent.contact?.phone,\n      agent_code: undefined,\n      country: agent.country,\n      city: agent.city,\n      status: agent.status,\n      profile_image: agent.profileImage,\n      stats: {\n        totalQueries: agent.stats?.totalQueries ?? 0,\n        totalBookings: agent.stats?.totalBookings ?? 0,\n        conversionRate: agent.stats?.conversionRate ?? 0,\n        revenueGenerated: agent.stats?.revenueGenerated ?? 0,\n        averageBookingValue: agent.stats?.averageBookingValue ?? 0,\n        activeCustomers: agent.stats?.activeCustomers ?? 0,\n      },\n    };\n  };\n\n  const mapRow = (row: any): SupabaseAgentOption => {\n    const profile = row?.profiles || row?.profile || null;\n    const name = row?.name || row?.agency_name || profile?.name || 'Unknown Agent';\n    const agencyName = row?.agency_name || undefined;\n    const email = row?.email || profile?.email || undefined;\n    const phone = row?.business_phone || profile?.phone || undefined;\n    return {\n      id: String(row?.id || row?.user_id || profile?.id || ''),\n      name,\n      agencyName,\n      email,\n      phone,\n      agent_code: row?.agency_code || row?.agent_code || undefined,\n      country: row?.country || undefined,\n      city: row?.city || undefined,\n      status: row?.status || profile?.status || undefined,\n      profile_image: row?.profile_image || undefined,\n      stats: {\n        totalQueries: 0,\n        totalBookings: 0,\n        conversionRate: 0,\n        revenueGenerated: 0,\n        averageBookingValue: 0,\n        activeCustomers: 0,\n      },\n    };\n  };\n\n  const loadAgents = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      // Primary: join agents with profiles to get full name and contact info\n      const client: any = supabase as any;\n      const { data, error: err } = await client\n        .from('agents')\n        .select(`\n          id,\n          status,\n          agency_code,\n          name,\n          email,\n          business_phone,\n          profile_image,\n          country,\n          city,\n          profiles:profiles(id, name, email, phone, status)\n        `)\n        .eq('status', 'active');\n\n      if (err) {\n        // Fallback: fetch agents without join (RLS or schema mismatch)\n        const { data: agentsOnly, error: fallbackErr } = await client\n          .from('agents')\n          .select('id, status, agency_code, name, email, business_phone, profile_image, country, city')\n          .eq('status', 'active');\n\n        if (fallbackErr) {\n          // If Supabase fetch completely fails, use local fallback sources\n          const localStored = AgentStorageService.getAgents();\n          const combinedLocal = [...defaultAgents, ...localStored];\n          const localOptions = combinedLocal.map(mapLocalAgent);\n          setAgents(localOptions);\n          setLoading(false);\n          return;\n        }\n        const options = (agentsOnly || []).map(mapRow);\n        if (!options || options.length === 0) {\n          const localStored = AgentStorageService.getAgents();\n          const combinedLocal = [...defaultAgents, ...localStored];\n          const localOptions = combinedLocal.map(mapLocalAgent);\n          setAgents(localOptions);\n        } else {\n          setAgents(options);\n        }\n        setLoading(false);\n        return;\n      }\n\n      const options = (data || []).map(mapRow);\n      if (!options || options.length === 0) {\n        const localStored = AgentStorageService.getAgents();\n        const combinedLocal = [...defaultAgents, ...localStored];\n        const localOptions = combinedLocal.map(mapLocalAgent);\n        setAgents(localOptions);\n      } else {\n        setAgents(options);\n      }\n    } catch (e: any) {\n      // On any error, attempt local fallback so UI still has data\n      try {\n        const localStored = AgentStorageService.getAgents();\n        const combinedLocal = [...defaultAgents, ...localStored];\n        const localOptions = combinedLocal.map(mapLocalAgent);\n        setAgents(localOptions);\n      } catch (fallbackErr) {\n        console.warn('Local agent fallback failed', fallbackErr);\n      }\n      setError(e?.message || 'Failed to load agents');\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    loadAgents();\n  }, [loadAgents]);\n\n  // Multi-field search across common agent attributes (name, agency, email, phone, city, country)\n  const searchAgents = useCallback(async (term: string): Promise<SupabaseAgentOption[]> => {\n    const q = (term || '').trim();\n    if (!q) return agents;\n    const like = `%${q}%`;\n    try {\n      const client: any = supabase as any;\n      const { data, error: err } = await client\n        .from('agents')\n        .select(`\n          id,\n          status,\n          agency_code,\n          name,\n          email,\n          business_phone,\n          country,\n          city,\n          alternate_email,\n          mobile_numbers,\n          profiles:profiles(id, name, email, phone, status)\n        `)\n        .or(\n          [\n            `name.ilike.${like}`,\n            `agency_name.ilike.${like}`,\n            `email.ilike.${like}`,\n            `business_phone.ilike.${like}`,\n            `alternate_email.ilike.${like}`,\n            `mobile_numbers.ilike.${like}`,\n            `city.ilike.${like}`,\n            `country.ilike.${like}`,\n          ].join(',')\n        )\n        .limit(50);\n\n      if (err) throw err;\n      return (data || []).map(mapRow);\n    } catch (e) {\n      // Fallback to client-side filtering of currently loaded list\n      const lower = q.toLowerCase();\n      return agents.filter((a) => {\n        return [\n          a.name,\n          a.agencyName,\n          a.email,\n          a.phone,\n          a.city,\n          a.country,\n          a.agent_code,\n        ]\n          .filter(Boolean)\n          .some((v) => String(v).toLowerCase().includes(lower));\n      });\n    }\n  }, [agents]);\n\n  return { agents, loading, error, reload: loadAgents, searchAgents };\n}\n\n// Helper: find an agent by a numeric ID coming from Query.agentId\n// Matches against stringified `id` or `agent_code` for flexibility\nexport function findSupabaseAgentByNumericId(\n  agents: SupabaseAgentOption[],\n  numericId?: number | null\n): SupabaseAgentOption | undefined {\n  if (numericId == null) return undefined;\n  const idStr = String(numericId);\n  return agents.find((a) => a.id === idStr || a.agent_code === idStr);\n}","\nimport { useState, useEffect } from 'react';\nimport { CitiesService, CityRow } from '@/services/citiesService';\nimport { CountriesService, CountryRow } from '@/services/countriesService';\n\nexport interface City {\n  id: string;\n  name: string;\n  region: string;\n  country: string;\n  has_airport: boolean;\n  is_popular: boolean;\n  status: \"active\" | \"disabled\";\n  created_at: string;\n  updated_at: string;\n  // Legacy compatibility fields\n  hasAirport?: boolean;\n  isPopular?: boolean;\n}\n\nexport interface Country {\n  id: string;\n  name: string;\n  code: string;\n  status: \"active\" | \"inactive\";\n}\n\nexport const useCitiesData = () => {\n  const [cities, setCities] = useState<City[]>([]);\n  const [countries, setCountries] = useState<Country[]>([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    const loadData = async () => {\n      try {\n        setLoading(true);\n        \n        // Load cities from CitiesService\n        const citiesResponse = await CitiesService.getActiveCities();\n        if (citiesResponse.success && citiesResponse.data) {\n          const transformedCities: City[] = citiesResponse.data.map((city: CityRow) => ({\n            id: city.id,\n            name: city.name,\n            region: city.region,\n            country: city.country,\n            has_airport: city.has_airport,\n            is_popular: city.is_popular,\n            status: city.status,\n            created_at: city.created_at,\n            updated_at: city.updated_at,\n            // Legacy compatibility\n            hasAirport: city.has_airport,\n            isPopular: city.is_popular\n          }));\n          setCities(transformedCities);\n        }\n\n        // Load active countries from CitiesService\n        const countriesResponse = await CitiesService.getActiveCountries();\n        if (countriesResponse.success && countriesResponse.data) {\n          const transformedCountries: Country[] = countriesResponse.data.map((country: CountryRow) => ({\n            id: country.id,\n            name: country.name,\n            code: country.code,\n            status: country.status as \"active\" | \"inactive\"\n          }));\n          setCountries(transformedCountries);\n        }\n      } catch (error) {\n        console.error('Error loading cities and countries data:', error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadData();\n  }, []);\n\n  // Get active cities for a specific region/country\n  const getCitiesByCountry = (countryName: string): City[] => {\n    return cities.filter(city => \n      (city.country === countryName || city.region === countryName) && \n      city.status === 'active'\n    );\n  };\n\n  // Get all active cities\n  const getActiveCities = (): City[] => {\n    return cities.filter(city => city.status === 'active');\n  };\n\n  // Get all active countries\n  const getActiveCountries = (): Country[] => {\n    return countries.filter(country => country.status === 'active');\n  };\n\n  return {\n    cities,\n    countries,\n    loading,\n    getCitiesByCountry,\n    getActiveCities,\n    getActiveCountries,\n    setCities,\n    setCountries\n  };\n};\n","import { useState, useEffect, useCallback } from 'react';\nimport { ItineraryDay } from '@/components/proposal/DayByDayItineraryBuilder';\nimport { AccommodationOption, EnhancedMarkupData } from '@/types/enhancedMarkup';\nimport SupabaseProposalService from '@/services/supabaseProposalService';\n\ninterface ProposalPersistenceData {\n  itineraryData: ItineraryDay[];\n  // Optional enhancements stored within itinerary_data JSONB\n  sightseeingOptions?: Array<{\n    option_label: string;\n    activities: Array<{ name: string; cost: number; type: string; description?: string }>;\n  }>;\n  citySelection?: string | null;\n  // Raw/other keys from itinerary_data to preserve unknown fields during merge\n  itineraryOther?: Record<string, any>;\n  accommodationData: {\n    selectedAccommodations: AccommodationOption[];\n    markupData: EnhancedMarkupData | null;\n  };\n  termsConditions: {\n    paymentTerms: string;\n    cancellationPolicy: string;\n    additionalTerms: string;\n    inclusions: string[];\n    exclusions: string[];\n  };\n  emailData: {\n    to: string;\n    subject: string;\n    message: string;\n    agentName: string;\n    agentPhone: string;\n    agentEmail: string;\n  };\n  pricingConfig: {\n    mode: 'combined' | 'separate';\n    adultMarkup: number;\n    childMarkup: number;\n    childDiscountPercent: number;\n  };\n  // Preserve full pricing_data for safe merges\n  pricingData?: Record<string, any> | null;\n  // Optional transport options stored under pricing_data\n  transportOptions?: Array<{\n    option_label: string;\n    vehicle_type: string;\n    capacity: number;\n    cost: number;\n    remarks?: string;\n  }>;\n  lastSaved: string;\n  queryId: string;\n  draftType?: 'daywise' | 'enhanced';\n  version?: number;\n}\n\nexport const useProposalPersistence = (queryId: string, draftType: 'daywise' | 'enhanced' = 'daywise') => {\n  const [data, setData] = useState<ProposalPersistenceData>({\n    itineraryData: [],\n    sightseeingOptions: [],\n    citySelection: null,\n    itineraryOther: {},\n    accommodationData: {\n      selectedAccommodations: [],\n      markupData: null\n    },\n    termsConditions: {\n      paymentTerms: '',\n      cancellationPolicy: '',\n      additionalTerms: '',\n      inclusions: [],\n      exclusions: []\n    },\n    emailData: {\n      to: '',\n      subject: '',\n      message: '',\n      agentName: '',\n      agentPhone: '',\n      agentEmail: ''\n    },\n    pricingConfig: {\n      mode: 'separate',\n      adultMarkup: 15,\n      childMarkup: 10,\n      childDiscountPercent: 25\n    },\n    pricingData: null,\n    transportOptions: [],\n    lastSaved: '',\n    queryId,\n    draftType,\n    version: 1\n  });\n\n  const storageKey = `proposal_persistence_${queryId}_${draftType}`;\n\n  // Enhanced load data with Supabase remote-first and local fallback\n  const loadData = useCallback(async () => {\n    try {\n      const proposalId = `DRAFT-${queryId}-${draftType}`;\n      const { data: row, error } = await SupabaseProposalService.getDraftByProposalId(proposalId);\n      if (!error && row) {\n        const itineraryRaw = row?.itinerary_data || {};\n        const itineraryData = Array.isArray(itineraryRaw)\n          ? itineraryRaw\n          : Array.isArray(itineraryRaw?.days)\n            ? itineraryRaw.days\n            : [];\n        const sightseeingOptions = Array.isArray(itineraryRaw?.sightseeing_options)\n          ? itineraryRaw.sightseeing_options\n          : [];\n        const citySelection = itineraryRaw?.city_selection ?? null;\n        const itineraryOther = Array.isArray(itineraryRaw) ? {} : Object.fromEntries(\n          Object.entries(itineraryRaw || {}).filter(([k]) => !['days', 'sightseeing_options', 'city_selection'].includes(k))\n        );\n\n        const pricingRaw = row?.pricing_data || {};\n        const transportOptions = Array.isArray(pricingRaw?.transport_options) ? pricingRaw.transport_options : [];\n\n        const remoteData = {\n          itineraryData,\n          sightseeingOptions,\n          citySelection,\n          itineraryOther,\n          accommodationData: {\n            selectedAccommodations: Array.isArray(row?.accommodation_data?.selectedAccommodations)\n              ? row.accommodation_data.selectedAccommodations\n              : Array.isArray(row?.accommodation_data?.options)\n                ? row.accommodation_data.options\n                : [],\n            markupData: row?.accommodation_data?.markupData || null\n          },\n          termsConditions: {\n            paymentTerms: row?.terms || '',\n            cancellationPolicy: '',\n            additionalTerms: '',\n            inclusions: Array.isArray(row?.inclusions) ? row.inclusions : [],\n            exclusions: Array.isArray(row?.exclusions) ? row.exclusions : []\n          },\n          emailData: row?.email_data || {\n            to: '', subject: '', message: '', agentName: '', agentPhone: '', agentEmail: ''\n          },\n          pricingConfig: {\n            mode: (pricingRaw?.mode ?? 'separate') as 'combined' | 'separate',\n            adultMarkup: pricingRaw?.adultMarkup ?? 15,\n            childMarkup: pricingRaw?.childMarkup ?? 10,\n            childDiscountPercent: pricingRaw?.childDiscountPercent ?? 25\n          },\n          pricingData: pricingRaw || null,\n          transportOptions,\n          lastSaved: row?.last_saved || new Date().toISOString(),\n          queryId,\n          draftType,\n          version: row?.version || 1\n        } as Partial<ProposalPersistenceData>;\n\n        setData(prevData => ({ ...prevData, ...remoteData } as ProposalPersistenceData));\n\n        // Keep offline cache in sync\n        try {\n          const cacheString = JSON.stringify({ ...data, ...remoteData });\n          localStorage.setItem(storageKey, cacheString);\n          localStorage.setItem(`proposal_persistence_${queryId}`, cacheString);\n        } catch {}\n\n        console.log('Loaded persistence data from Supabase proposals');\n        return true;\n      }\n    } catch (error) {\n      console.error('Error loading proposal persistence data (Supabase):', error);\n    }\n\n    // Fallback: local storage keys for backward compatibility\n    try {\n      const storageKeys = [\n        `proposal_persistence_${queryId}_${draftType}`,\n        `proposal_persistence_${queryId}`,\n        `proposal_draft_${queryId}_${draftType}`,\n        `proposal_draft_${queryId}`\n      ];\n\n      for (const key of storageKeys) {\n        const saved = localStorage.getItem(key);\n        if (saved) {\n          const parsedData = JSON.parse(saved);\n          if (parsedData.queryId === queryId) {\n            setData(prevData => ({\n              ...prevData,\n              ...parsedData,\n              draftType,\n              version: parsedData.version || 1\n            }));\n            console.log(`Loaded persistence data from ${key}`);\n            return true;\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error loading proposal persistence data (local fallback):', error);\n    }\n    return false;\n  }, [queryId, storageKey, draftType, data]);\n\n  // Enhanced save data with versioning and reference stability\n  const saveData = useCallback(async (updates: Partial<ProposalPersistenceData>) => {\n    try {\n      // Update local state and offline cache\n      const nowIso = new Date().toISOString();\n      let nextData: ProposalPersistenceData | null = null;\n      setData(prevData => {\n        const updatedData = {\n          ...prevData,\n          ...updates,\n          lastSaved: nowIso,\n          queryId,\n          draftType,\n          version: (prevData.version || 0) + 1\n        };\n        nextData = updatedData as ProposalPersistenceData;\n        const prevDataString = JSON.stringify(prevData);\n        const newDataString = JSON.stringify(updatedData);\n        if (prevDataString !== newDataString) {\n          try {\n            localStorage.setItem(storageKey, newDataString);\n            localStorage.setItem(`proposal_persistence_${queryId}`, newDataString);\n          } catch {}\n          console.log(`Saved persistence data locally to ${storageKey}, version ${updatedData.version}`);\n        }\n        return updatedData;\n      });\n\n      // Prepare Supabase patch for remote persistence\n      const supabasePatch: any = {};\n      // Itinerary JSONB merge-builder\n      const itineraryRelatedUpdate = (\n        updates.itineraryData !== undefined ||\n        updates.sightseeingOptions !== undefined ||\n        updates.citySelection !== undefined\n      );\n      if (itineraryRelatedUpdate && nextData) {\n        supabasePatch.itinerary_data = {\n          ...(nextData.itineraryOther || {}),\n          days: nextData.itineraryData || [],\n          sightseeing_options: nextData.sightseeingOptions || [],\n          city_selection: nextData.citySelection ?? null,\n        };\n      }\n\n      // Accommodation JSONB\n      if (updates.accommodationData !== undefined && nextData) {\n        supabasePatch.accommodation_data = nextData.accommodationData;\n      }\n\n      // Pricing JSONB merge-builder\n      const pricingRelatedUpdate = (\n        updates.pricingConfig !== undefined ||\n        updates.transportOptions !== undefined\n      );\n      if (pricingRelatedUpdate && nextData) {\n        supabasePatch.pricing_data = {\n          ...(nextData.pricingData || {}),\n          ...nextData.pricingConfig,\n          transport_options: nextData.transportOptions || [],\n        };\n      }\n\n      // Email JSONB\n      if (updates.emailData !== undefined && nextData) supabasePatch.email_data = nextData.emailData;\n      if (updates.termsConditions !== undefined) {\n        supabasePatch.terms = updates.termsConditions.paymentTerms || '';\n        supabasePatch.inclusions = updates.termsConditions.inclusions || [];\n        supabasePatch.exclusions = updates.termsConditions.exclusions || [];\n      }\n      if (nextData) supabasePatch.version = nextData.version;\n\n      // Only call remote if there is anything to update\n      if (Object.keys(supabasePatch).length > 0) {\n        const { error } = await SupabaseProposalService.updateDraftFields({\n          queryId,\n          draftType,\n          patch: supabasePatch\n        });\n        if (error) {\n          console.warn('Supabase updateDraftFields warning:', error);\n        } else {\n          console.log('Persisted proposal data to Supabase (proposals table)');\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error saving proposal persistence data:', error);\n      return false;\n    }\n  }, [queryId, storageKey, draftType]);\n\n  // Update specific sections with stable references\n  const updateItineraryData = useCallback((itineraryData: ItineraryDay[]) => {\n    return saveData({ itineraryData });\n  }, [saveData]);\n\n  const updateSightseeingOptions = useCallback((sightseeingOptions: NonNullable<ProposalPersistenceData['sightseeingOptions']>) => {\n    return saveData({ sightseeingOptions });\n  }, [saveData]);\n\n  const updateCitySelection = useCallback((citySelection: string | null) => {\n    return saveData({ citySelection });\n  }, [saveData]);\n\n  const updateTermsConditions = useCallback((termsConditions: typeof data.termsConditions) => {\n    return saveData({ termsConditions });\n  }, [saveData]);\n\n  const updateEmailData = useCallback((emailData: typeof data.emailData) => {\n    return saveData({ emailData });\n  }, [saveData]);\n\n  const updatePricingConfig = useCallback((pricingConfig: typeof data.pricingConfig) => {\n    return saveData({ pricingConfig });\n  }, [saveData]);\n\n  const updateTransportOptions = useCallback((transportOptions: NonNullable<ProposalPersistenceData['transportOptions']>) => {\n    return saveData({ transportOptions });\n  }, [saveData]);\n\n  const updateAccommodationData = useCallback((accommodationData: typeof data.accommodationData) => {\n    return saveData({ accommodationData });\n  }, [saveData]);\n\n  // Load data on mount\n  useEffect(() => {\n    void loadData();\n  }, [loadData]);\n\n  return {\n    data,\n    updateItineraryData,\n    updateSightseeingOptions,\n    updateCitySelection,\n    updateAccommodationData,\n    updateTermsConditions,\n    updateEmailData,\n    updatePricingConfig,\n    updateTransportOptions,\n    saveData,\n    loadData\n  };\n};","import { useState, useEffect, useCallback } from 'react';\nimport { ItineraryDay } from '@/components/proposal/DayByDayItineraryBuilder';\nimport ProposalService from '@/services/proposalService';\nimport SupabaseProposalService from '@/services/supabaseProposalService';\nimport { Query } from '@/types/query';\nimport { calculateTripDuration } from '@/utils/currencyUtils';\nimport { saveAccommodationData, loadAccommodationData, AccommodationOption } from '@/utils/accommodationUtils';\n\ninterface UseProposalBuilderOptions {\n  draftType?: 'daywise' | 'enhanced';\n  autoLoadDraft?: boolean;\n  initialTab?: string;\n}\n\ninterface UseProposalBuilderReturn {\n  days: ItineraryDay[];\n  totalCost: number;\n  loading: boolean;\n  selectedDayId: string | null;\n  setSelectedDayId: (dayId: string | null) => void;\n  addDay: () => void;\n  addMultipleDays: (count: number) => void;\n  updateDay: (dayId: string, updates: Partial<ItineraryDay>) => void;\n  removeDay: (dayId: string) => void;\n  reorderDay: (dayId: string, direction: 'up' | 'down') => void;\n  autoGenerateDaysFromQuery: (query: Query) => void;\n  generateDaysFromCityAllocations: (query: Query, allocations: any[]) => void;\n  addHotelToDay: (dayId: string, hotel: any, price?: number) => void;\n  addTransportToDay: (dayId: string, transport: any, price?: number) => void;\n  addSightseeingToDay: (dayId: string, activity: any, price?: number) => void;\n  saveDraft: (draftType?: string) => Promise<string>;\n  generateProposal: () => Promise<string>;\n  saveAccommodations: (accommodations: AccommodationOption[]) => void;\n  loadSpecificDraft: (draftId: string, draftType: string) => Promise<void>;\n}\n\nexport const useProposalBuilder = (queryId?: string, options?: UseProposalBuilderOptions): UseProposalBuilderReturn => {\n  const [days, setDays] = useState<ItineraryDay[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [selectedDayId, setSelectedDayId] = useState<string | null>(null);\n  \n  const draftType = options?.draftType || 'daywise';\n\n  // Enhanced draft loading with type support\n  const loadDraftData = useCallback((specificDraftType?: string) => {\n    if (!queryId) return false;\n    \n    const targetDraftType = specificDraftType || draftType;\n    console.log('Loading draft data for query:', queryId, 'type:', targetDraftType);\n    \n    // Try different storage keys based on draft type\n    const storageKeys = [\n      `proposal_draft_${queryId}_${targetDraftType}`,\n      `proposal_draft_${queryId}`,\n      `enhanced_proposal_${queryId}`,\n      `proposal_persistence_${queryId}`\n    ];\n    \n    for (const key of storageKeys) {\n      const savedDraft = localStorage.getItem(key);\n      if (savedDraft) {\n        try {\n          const parsedDraft = JSON.parse(savedDraft);\n          console.log('Parsed draft data from', key, ':', parsedDraft);\n          \n          // Handle different draft formats\n          let daysData = parsedDraft.days || parsedDraft.itineraryData || [];\n          \n          if (Array.isArray(daysData)) {\n            const validatedDays = daysData.map((day: any, index: number) => {\n              const validDay: ItineraryDay = {\n                id: day.id || `day_${Date.now()}_${index}`,\n                dayNumber: day.dayNumber || (index + 1),\n                title: day.title || `Day ${index + 1}`,\n                city: day.city || '',\n                description: day.description || '',\n                date: day.date || new Date().toISOString().split('T')[0],\n                activities: Array.isArray(day.activities) ? day.activities : [],\n                transport: Array.isArray(day.transport) ? day.transport : [],\n                accommodations: Array.isArray(day.accommodations) ? day.accommodations : [],\n                accommodation: day.accommodation || undefined,\n                meals: day.meals || {\n                  breakfast: false,\n                  lunch: false,\n                  dinner: false\n                },\n                totalCost: typeof day.totalCost === 'number' ? day.totalCost : 0\n              };\n              \n              return validDay;\n            });\n            \n            console.log('Validated days from', key, ':', validatedDays);\n            setDays(validatedDays);\n            return true;\n          }\n        } catch (error) {\n          console.error('Error loading saved draft from', key, ':', error);\n          localStorage.removeItem(key);\n        }\n      }\n    }\n    \n    return false;\n  }, [queryId, draftType]);\n\n  // Load specific draft by ID and type\n  const loadSpecificDraft = useCallback(async (draftId: string, draftType: string) => {\n    console.log('Loading specific draft:', draftId, 'type:', draftType);\n    \n    // Try to load from Supabase first if it's a DRAFT- prefixed ID\n    if (draftId.startsWith('DRAFT-')) {\n      try {\n        console.log('Attempting to load Supabase draft:', draftId);\n        const supabaseDraft = await SupabaseProposalService.getDraftByProposalId(draftId);\n        \n        if (supabaseDraft && supabaseDraft.data) {\n          console.log('Supabase draft loaded successfully:', supabaseDraft);\n          \n          // Extract days data from the Supabase draft\n          const daysData = supabaseDraft.data.itinerary_data || [];\n          \n          if (Array.isArray(daysData) && daysData.length > 0) {\n            const validatedDays = daysData.map((day: any, index: number) => ({\n              id: day.id || `day_${Date.now()}_${index}`,\n              dayNumber: day.dayNumber || (index + 1),\n              title: day.title || `Day ${index + 1}`,\n              city: day.city || '',\n              description: day.description || '',\n              date: day.date || new Date().toISOString().split('T')[0],\n              activities: Array.isArray(day.activities) ? day.activities : [],\n              transport: Array.isArray(day.transport) ? day.transport : [],\n              accommodations: Array.isArray(day.accommodations) ? day.accommodations : [],\n              accommodation: day.accommodation || undefined,\n              meals: day.meals || {\n                breakfast: false,\n                lunch: false,\n                dinner: false\n              },\n              totalCost: typeof day.totalCost === 'number' ? day.totalCost : 0\n            }));\n            \n            setDays(validatedDays);\n            console.log('Loaded Supabase draft successfully with', validatedDays.length, 'days');\n            return;\n          } else {\n            console.log('No days data found in Supabase draft, starting with blank');\n            setDays([]);\n            return;\n          }\n        } else {\n          console.log('Supabase draft not found, starting with blank');\n          setDays([]);\n          return;\n        }\n      } catch (error) {\n        console.warn('Failed to load from Supabase, starting with blank:', error);\n        setDays([]);\n        return;\n      }\n    }\n    \n    // Fallback to localStorage for non-DRAFT IDs\n    const storageKey = `proposal_draft_${draftId}_${draftType}`;\n    const savedDraft = localStorage.getItem(storageKey);\n    \n    if (!savedDraft) {\n      console.log('No draft found, starting with blank slate');\n      setDays([]);\n      return;\n    }\n    \n    try {\n      const parsedDraft = JSON.parse(savedDraft);\n      const daysData = parsedDraft.days || parsedDraft.itineraryData || [];\n      \n      if (Array.isArray(daysData) && daysData.length > 0) {\n        const validatedDays = daysData.map((day: any, index: number) => ({\n          id: day.id || `day_${Date.now()}_${index}`,\n          dayNumber: day.dayNumber || (index + 1),\n          title: day.title || `Day ${index + 1}`,\n          city: day.city || '',\n          description: day.description || '',\n          date: day.date || new Date().toISOString().split('T')[0],\n          activities: Array.isArray(day.activities) ? day.activities : [],\n          transport: Array.isArray(day.transport) ? day.transport : [],\n          accommodations: Array.isArray(day.accommodations) ? day.accommodations : [],\n          accommodation: day.accommodation || undefined,\n          meals: day.meals || {\n            breakfast: false,\n            lunch: false,\n            dinner: false\n          },\n          totalCost: typeof day.totalCost === 'number' ? day.totalCost : 0\n        }));\n        \n        setDays(validatedDays);\n        console.log('Loaded localStorage draft successfully with', validatedDays.length, 'days');\n      } else {\n        console.log('No days data in localStorage draft, starting with blank');\n        setDays([]);\n      }\n    } catch (error) {\n      console.error('Error parsing specific draft:', error);\n      console.log('Invalid draft format, starting with blank');\n      setDays([]);\n    }\n  }, []);\n\n  // Enhanced draft loading with URL parameter support\n  useEffect(() => {\n    if (queryId) {\n      // Check URL parameters for specific loading instructions\n      const urlParams = new URLSearchParams(window.location.search);\n      const shouldAutoLoad = options?.autoLoadDraft || urlParams.get('loadDraft') === 'true';\n      const specificDraftType = urlParams.get('draftType') || draftType;\n      const draftId = urlParams.get('draftId') || queryId;\n      \n      if (shouldAutoLoad) {\n        console.log('Loading draft with parameters:', { queryId, draftId, specificDraftType });\n        \n        // Try to load specific draft first\n        if (draftId !== queryId) {\n          loadSpecificDraft(draftId, specificDraftType).catch(() => {\n            // Fallback to regular draft loading\n            const draftLoaded = loadDraftData(specificDraftType);\n            if (draftLoaded) {\n              console.log('Fallback draft data loaded successfully');\n            } else {\n              console.log('No valid draft found');\n            }\n          });\n        } else {\n          const draftLoaded = loadDraftData(specificDraftType);\n          if (draftLoaded) {\n            console.log('Draft data loaded successfully');\n          } else {\n            console.log('No valid draft found');\n          }\n        }\n      }\n    }\n  }, [queryId, loadDraftData, loadSpecificDraft, options?.autoLoadDraft, draftType]);\n\n  // Calculate total cost\n  const totalCost = days.reduce((sum, day) => sum + day.totalCost, 0);\n\n  const addDay = useCallback(() => {\n    const newDay: ItineraryDay = {\n      id: `day_${Date.now()}`,\n      dayNumber: days.length + 1,\n      title: `Day ${days.length + 1}`,\n      city: '',\n      description: '',\n      date: new Date().toISOString().split('T')[0],\n      activities: [],\n      transport: [],\n      accommodations: [],\n      meals: {\n        breakfast: false,\n        lunch: false,\n        dinner: false\n      },\n      totalCost: 0\n    };\n\n    setDays(prev => [...prev, newDay]);\n    // No auto-save when adding empty day\n  }, [days.length]);\n\n  const addMultipleDays = useCallback((count: number) => {\n    const newDays: ItineraryDay[] = [];\n    for (let i = 0; i < count; i++) {\n      const dayNumber = days.length + i + 1;\n      const newDay: ItineraryDay = {\n        id: `day_${Date.now()}_${i}`,\n        dayNumber,\n        title: `Day ${dayNumber}`,\n        city: '',\n        description: '',\n        date: new Date().toISOString().split('T')[0],\n        activities: [],\n        transport: [],\n        accommodations: [],\n        meals: {\n          breakfast: false,\n          lunch: false,\n          dinner: false\n        },\n        totalCost: 0\n      };\n      newDays.push(newDay);\n    }\n    setDays(prev => [...prev, ...newDays]);\n    // No auto-save when adding empty days\n  }, [days.length]);\n\n  const autoGenerateDaysFromQuery = useCallback((query: Query) => {\n    const tripDuration = calculateTripDuration(query.travelDates.from, query.travelDates.to);\n    if (!tripDuration) return;\n\n    const startDate = new Date(query.travelDates.from);\n    const generatedDays: ItineraryDay[] = [];\n\n    for (let i = 0; i < tripDuration.days; i++) {\n      const currentDate = new Date(startDate);\n      currentDate.setDate(startDate.getDate() + i);\n      \n      const isFirstDay = i === 0;\n      const isLastDay = i === tripDuration.days - 1;\n      \n      let title = `Day ${i + 1}`;\n      let description = '';\n      let defaultCity = query.destination.cities[0] || '';\n\n      if (isFirstDay) {\n        title = `Day 1 - Arrival`;\n        description = `Arrival in ${query.destination.country}. Check-in and orientation.`;\n      } else if (isLastDay) {\n        title = `Day ${i + 1} - Departure`;\n        description = `Check-out and departure from ${query.destination.country}.`;\n      } else {\n        // Distribute cities across days\n        const cityIndex = Math.floor((i - 1) / Math.max(1, Math.floor((tripDuration.days - 2) / query.destination.cities.length)));\n        defaultCity = query.destination.cities[cityIndex] || defaultCity;\n        title = `Day ${i + 1} - ${defaultCity}`;\n        description = `Explore ${defaultCity} and its attractions.`;\n      }\n\n      const newDay: ItineraryDay = {\n        id: `day_${Date.now()}_${i}`,\n        dayNumber: i + 1,\n        title,\n        city: defaultCity,\n        description,\n        date: currentDate.toISOString().split('T')[0],\n        activities: [],\n        transport: [],\n        accommodations: [],\n        meals: {\n          breakfast: !isFirstDay, // No breakfast on arrival day\n          lunch: false,\n          dinner: false\n        },\n        totalCost: 0\n      };\n      \n      generatedDays.push(newDay);\n    }\n\n    setDays(generatedDays);\n  }, []);\n\n  const generateDaysFromCityAllocations = useCallback((query: Query, allocations: any[]) => {\n    if (!allocations || allocations.length === 0) return;\n\n    const startDate = new Date(query.travelDates.from);\n    const generatedDays: ItineraryDay[] = [];\n    let currentDayNumber = 1;\n    \n    // Calculate total nights and add 1 for departure day\n    const totalNights = allocations.reduce((sum, a) => sum + a.nights, 0);\n    const totalDays = totalNights + 1;\n\n    // Generate days based on city allocations\n    allocations.forEach((allocation, allocationIndex) => {\n      if (allocation.nights > 0 && allocation.city) {\n        for (let i = 0; i < allocation.nights; i++) {\n          const currentDate = new Date(startDate);\n          currentDate.setDate(startDate.getDate() + currentDayNumber - 1);\n          \n          const isFirstDayInCity = i === 0;\n          const isLastDayInCity = i === allocation.nights - 1;\n          const isFirstDayOverall = currentDayNumber === 1;\n          \n          let title = `Day ${currentDayNumber}`;\n          let description = '';\n\n          if (isFirstDayOverall) {\n            title = `Day ${currentDayNumber} - Arrival in ${allocation.city}`;\n            description = `Arrival in ${allocation.city}, ${query.destination.country}. Check-in and orientation.`;\n          } else if (isFirstDayInCity && allocationIndex > 0) {\n            title = `Day ${currentDayNumber} - Transfer to ${allocation.city}`;\n            description = `Travel to ${allocation.city}. Check-in and explore.`;\n          } else if (isLastDayInCity && allocationIndex < allocations.length - 1) {\n            title = `Day ${currentDayNumber} - Last day in ${allocation.city}`;\n            description = `Final exploration of ${allocation.city} before moving to next destination.`;\n          } else {\n            title = `Day ${currentDayNumber} - Explore ${allocation.city}`;\n            description = `Full day exploring ${allocation.city} and its attractions.`;\n          }\n\n          const newDay: ItineraryDay = {\n            id: `day_${Date.now()}_${currentDayNumber}`,\n            dayNumber: currentDayNumber,\n            title,\n            city: allocation.city,\n            description,\n            date: currentDate.toISOString().split('T')[0],\n            activities: [],\n            transport: [],\n            accommodations: [],\n            meals: {\n              breakfast: !isFirstDayOverall, // No breakfast on arrival day\n              lunch: false,\n              dinner: false\n            },\n            totalCost: 0\n          };\n          \n          generatedDays.push(newDay);\n          currentDayNumber++;\n        }\n      }\n    });\n\n    // Add the departure day in the arrival city\n    if (allocations.length > 0) {\n      const arrivalCity = allocations[0].city; // First city is the arrival city\n      const departureDate = new Date(startDate);\n      departureDate.setDate(startDate.getDate() + totalNights); // Last day\n      \n      const departureDay: ItineraryDay = {\n        id: `day_${Date.now()}_${totalDays}`,\n        dayNumber: totalDays,\n        title: `Day ${totalDays} - Departure from ${arrivalCity}`,\n        city: arrivalCity,\n        description: `Check-out and departure from ${arrivalCity}. End of trip.`,\n        date: departureDate.toISOString().split('T')[0],\n        activities: [],\n        transport: [],\n        accommodations: [],\n        meals: {\n          breakfast: true,\n          lunch: false, // Usually no lunch on departure day\n          dinner: false // No dinner on departure day\n        },\n        totalCost: 0\n      };\n      \n      generatedDays.push(departureDay);\n    }\n\n    setDays(generatedDays);\n  }, []);\n\n  const updateDay = useCallback((dayId: string, updates: Partial<ItineraryDay>) => {\n    setDays(prev => {\n      const updatedDays = prev.map(day => \n        day.id === dayId \n          ? { ...day, ...updates }\n          : day\n      );\n      \n      // No auto-save - data will only be saved on manual save\n      return updatedDays;\n    });\n  }, []);\n\n  const removeDay = useCallback((dayId: string) => {\n    setDays(prev => {\n      const filtered = prev.filter(day => day.id !== dayId);\n      const updatedDays = filtered.map((day, index) => ({\n        ...day,\n        dayNumber: index + 1,\n        title: day.title.includes('Day ') ? `Day ${index + 1}` : day.title\n      }));\n      \n      // No auto-save - data will only be saved on manual save\n      return updatedDays;\n    });\n  }, []);\n\n  const reorderDay = useCallback((dayId: string, direction: 'up' | 'down') => {\n    setDays(prev => {\n      const currentIndex = prev.findIndex(day => day.id === dayId);\n      if (currentIndex === -1) return prev;\n      \n      const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;\n      if (newIndex < 0 || newIndex >= prev.length) return prev;\n      \n      const reorderedDays = [...prev];\n      const [movedDay] = reorderedDays.splice(currentIndex, 1);\n      reorderedDays.splice(newIndex, 0, movedDay);\n      \n      // Update day numbers after reordering\n      const renumberedDays = reorderedDays.map((day, index) => ({\n        ...day,\n        dayNumber: index + 1,\n        title: day.title.includes('Day ') ? `Day ${index + 1}` : day.title\n      }));\n      \n      return renumberedDays;\n    });\n  }, []);\n\n  const addHotelToDay = useCallback((dayId: string, hotel: any, price?: number) => {\n    const finalPrice = price || hotel.minRate || 100;\n    \n    const accommodationData = {\n      id: hotel.id?.toString() || `hotel_${Date.now()}`,\n      name: hotel.name,\n      type: 'hotel',\n      price: finalPrice,\n      hotel: hotel.name,\n      roomType: hotel.roomTypes?.[0]?.name || 'Standard Room'\n    };\n\n    const day = days.find(d => d.id === dayId);\n    const activitiesCost = day?.activities.reduce((sum, a) => sum + a.cost, 0) || 0;\n    const transportCost = day?.transport?.reduce((sum, t) => sum + t.price, 0) || 0;\n    const accommodationsCost = day?.accommodations?.reduce((sum, acc) => sum + acc.price, 0) || 0;\n\n    updateDay(dayId, {\n      accommodation: accommodationData,\n      totalCost: activitiesCost + transportCost + accommodationsCost + finalPrice\n    });\n  }, [days, updateDay]);\n\n  const addTransportToDay = useCallback((dayId: string, transport: any, price?: number) => {\n    const finalPrice = price || transport.price || 50;\n    \n    // Enhanced transport activity data\n    const transportActivity = {\n      id: transport.id?.toString() || `transport_${Date.now()}`,\n      name: transport.name,\n      description: transport.description || `Transport from ${transport.from} to ${transport.to}`,\n      duration: transport.duration || '1 hour',\n      cost: finalPrice,\n      type: 'transport' as const,\n      \n      // Transport specific data\n      from: transport.from,\n      to: transport.to,\n      transportType: transport.transportType || transport.vehicleType,\n      vehicleType: transport.vehicleType,\n      seatingCapacity: transport.seatingCapacity,\n      vehicleCount: transport.vehicleCount,\n      pickupLocation: transport.pickupLocation,\n      dropoffLocation: transport.dropoffLocation,\n      pickupTime: transport.pickupTime,\n      dropTime: transport.dropTime,\n      routeCode: transport.routeCode,\n      \n      // Data source tracking\n      dataSource: 'transport',\n      originalData: transport,\n      \n      // Pricing breakdown\n      priceBreakdown: {\n        basePrice: finalPrice,\n        finalPrice: finalPrice\n      }\n    };\n\n    const day = days.find(d => d.id === dayId);\n    const existingActivitiesCost = day?.activities.reduce((sum, a) => sum + a.cost, 0) || 0;\n    const accommodationCost = day?.accommodation?.price || 0;\n    const accommodationsCost = day?.accommodations?.reduce((sum, acc) => sum + acc.price, 0) || 0;\n    const existingTransportCost = day?.transport?.reduce((sum, t) => sum + t.price, 0) || 0;\n\n    // Add to both activities (for unified tracking) and transport (for legacy compatibility)\n    const updatedActivities = [...(day?.activities || []), transportActivity];\n    \n    updateDay(dayId, {\n      activities: updatedActivities,\n      transport: day?.transport ? [...day.transport, {\n        id: transportActivity.id,\n        name: transportActivity.name,\n        from: transport.from,\n        to: transport.to,\n        price: finalPrice,\n        type: transport.transportType || transport.vehicleType\n      }] : [{\n        id: transportActivity.id,\n        name: transportActivity.name,\n        from: transport.from,\n        to: transport.to,\n        price: finalPrice,\n        type: transport.transportType || transport.vehicleType\n      }],\n      totalCost: existingActivitiesCost + accommodationCost + accommodationsCost + existingTransportCost + finalPrice\n    });\n  }, [days, updateDay]);\n\n  const addSightseeingToDay = useCallback((dayId: string, activity: any, price?: number) => {\n    const day = days.find(d => d.id === dayId);\n    if (!day) return;\n\n    const finalPrice = price || (typeof activity.price === 'object' ? activity.price.adult || 25 : activity.price || 25);\n\n    // Enhanced activity data preservation\n    const newActivity = {\n      id: activity.id?.toString() || `activity_${Date.now()}`,\n      name: activity.name,\n      description: activity.description || '',\n      duration: activity.duration || '2 hours',\n      cost: finalPrice,\n      type: 'sightseeing' as const,\n      \n      // Enhanced sightseeing data\n      category: activity.category || activity.data?.category,\n      effectivePax: activity.effectivePax || activity.data?.effectivePax,\n      startTime: activity.startTime,\n      endTime: activity.endTime,\n      location: activity.location || activity.city,\n      \n      // Transport configuration from sightseeing\n      transportType: activity.data?.transportType || activity.transportType || activity.pricingSelection?.transferOption?.type,\n      transportLabel: activity.data?.transportLabel || activity.transportLabel || activity.pricingSelection?.transferOption?.type,\n      vehicleType: activity.pricingSelection?.transferOption?.vehicleType || activity.vehicleType,\n      priceUnit: activity.pricingSelection?.transferOption?.priceUnit || activity.priceUnit,\n      pickupLocation: activity.pickupLocation,\n      dropoffLocation: activity.dropoffLocation,\n      seatingCapacity: activity.seatingCapacity,\n      \n      // Sightseeing selections and options\n      selectedOptions: activity.selectedOptions || activity.data?.selectedOptions || [],\n      packageOptions: activity.packageOptions || activity.pricingSelection?.packageOptions || [],\n      pricingOptions: activity.pricingOptions || activity.pricingSelection?.pricingOptions || [],\n      transferOptions: activity.transferOptions || activity.pricingSelection?.transferOptions || [],\n      \n      // Data source tracking\n      dataSource: 'sightseeing',\n      originalData: activity.data || activity.pricingSelection,\n      \n      // Pricing breakdown\n      priceBreakdown: {\n        basePrice: finalPrice,\n        finalPrice: finalPrice\n      }\n    };\n\n    const updatedActivities = [...day.activities, newActivity];\n    const totalActivityCost = updatedActivities.reduce((sum, a) => sum + a.cost, 0);\n    const accommodationCost = day.accommodation?.price || 0;\n    const accommodationsCost = day.accommodations?.reduce((sum, acc) => sum + acc.price, 0) || 0;\n    const transportCost = day.transport?.reduce((sum, t) => sum + t.price, 0) || 0;\n\n    updateDay(dayId, {\n      activities: updatedActivities,\n      totalCost: totalActivityCost + accommodationCost + accommodationsCost + transportCost\n    });\n  }, [days, updateDay]);\n\n  const saveDraft = useCallback(async (targetDraftType?: string): Promise<string> => {\n    if (!queryId) throw new Error('Query ID is required');\n    \n    setLoading(true);\n    try {\n      const finalDraftType = targetDraftType || draftType;\n      const draftId = `draft_${queryId}`;\n      \n      // Use enhanced activity data storage\n      const { saveActivityDataWithValidation } = await import('@/utils/activityDataUtils');\n      saveActivityDataWithValidation(queryId, days);\n      \n      const draftData = {\n        id: draftId,\n        queryId,\n        days,\n        totalCost,\n        draftType: finalDraftType,\n        savedAt: new Date().toISOString(),\n        version: Date.now()\n      };\n      \n      console.log('Manual save draft data with enhanced activities:', draftData);\n      \n      // Save with type-specific key\n      const storageKey = `proposal_draft_${queryId}_${finalDraftType}`;\n      localStorage.setItem(storageKey, JSON.stringify(draftData));\n      \n      // Also save with legacy key for compatibility\n      localStorage.setItem(`proposal_draft_${queryId}`, JSON.stringify(draftData));\n      \n      // Save accommodation data separately\n      const allAccommodations: AccommodationOption[] = days.flatMap(day => \n        (day.accommodations || []).map(acc => ({\n          id: acc.id || `acc_${Date.now()}`,\n          name: acc.name || acc.hotel || 'Accommodation',\n          type: (acc.type || 'hotel') as 'hotel' | 'resort' | 'guesthouse' | 'apartment' | 'villa' | 'hostel',\n          city: day.city || '',\n          checkIn: day.date,\n          checkOut: day.date,\n          nights: 1,\n          roomType: acc.roomType || 'Standard Room',\n          starRating: 3,\n          pricePerNight: acc.price || 0,\n          totalPrice: acc.price || 0,\n          amenities: [],\n          description: '',\n          address: '',\n          phone: '',\n          email: '',\n          dayIds: [day.id],\n          option: 1\n        }))\n      );\n      \n      if (allAccommodations.length > 0) {\n        saveAccommodationData(queryId, allAccommodations, days);\n      }\n      \n      // Supabase: upsert draft row for server-side persistence (best-effort)\n      try {\n        const query: Query | null = await ProposalService.getQueryByIdAsync(queryId);\n        if (query) {\n          await SupabaseProposalService.upsertDraftProposal({\n            query,\n            days,\n            totalCost,\n            draftType: finalDraftType,\n          });\n        }\n      } catch (e) {\n        console.warn('Supabase draft upsert failed:', e);\n      }\n      \n      return draftId;\n    } finally {\n      setLoading(false);\n    }\n  }, [queryId, days, totalCost, draftType]);\n\n  const generateProposal = useCallback(async () => {\n    if (!queryId) throw new Error('Query ID is required');\n    \n    setLoading(true);\n    try {\n      // Convert days to proposal modules\n      const modules = days.map(day => ({\n        id: day.id,\n        type: 'transport' as const,\n        name: day.title,\n        category: 'itinerary',\n        data: {\n          dayNumber: day.dayNumber,\n          city: day.city,\n          description: day.description,\n          date: day.date,\n          accommodation: day.accommodation,\n          accommodations: day.accommodations,\n          transport: day.transport,\n          activities: day.activities,\n          meals: day.meals\n        },\n        pricing: {\n          basePrice: day.totalCost,\n          finalPrice: day.totalCost,\n          currency: 'USD'\n        },\n        status: 'active' as const,\n        metadata: {\n          supplier: 'Internal',\n          confirmationRequired: false,\n          tags: ['day-by-day', day.city.toLowerCase()]\n        }\n      }));\n\n      const query = await ProposalService.getQueryByIdAsync(queryId);\n      if (!query) throw new Error('Query not found');\n\n      const proposalData = {\n        queryId,\n        query,\n        modules,\n        totals: {\n          subtotal: totalCost,\n          discountAmount: 0,\n          total: totalCost,\n          moduleCount: modules.length\n        },\n        metadata: {\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          status: 'draft' as const,\n          version: 1\n        }\n      };\n\n      const proposalId = ProposalService.saveProposal(proposalData);\n      \n      // Supabase: create server-side proposal record (best-effort)\n      try {\n        await SupabaseProposalService.createProposal({\n          query,\n          days,\n          totalCost,\n          draftType,\n        });\n      } catch (e) {\n        console.warn('Supabase proposal creation failed:', e);\n      }\n      \n      // Keep draft after successful proposal creation (don't clear)\n      \n      return proposalId;\n    } finally {\n      setLoading(false);\n    }\n  }, [queryId, days, totalCost, draftType]);\n\n  const saveAccommodations = useCallback((accommodations: AccommodationOption[]) => {\n    if (!queryId) return;\n    \n    console.log('Saving accommodations from accommodation planning:', accommodations);\n    \n    // Update days with new accommodations\n    const updatedDays = days.map(day => {\n      const dayAccommodations = accommodations.filter(acc => \n        acc.dayIds?.includes(day.id) || \n        acc.city === day.city ||\n        (acc.checkIn <= day.date && acc.checkOut >= day.date)\n      );\n      \n      return {\n        ...day,\n        accommodations: dayAccommodations.map(acc => ({\n          id: acc.id,\n          name: acc.name,\n          type: acc.type,\n          price: acc.totalPrice,\n          hotel: acc.name,\n          roomType: acc.roomType\n        }))\n      };\n    });\n    \n    setDays(updatedDays);\n    \n    // Save to storage\n    saveAccommodationData(queryId, accommodations, updatedDays);\n  }, [queryId, days]);\n\n  return {\n    days,\n    totalCost,\n    loading,\n    selectedDayId,\n    setSelectedDayId,\n    addDay,\n    addMultipleDays,\n    updateDay,\n    removeDay,\n    reorderDay,\n    autoGenerateDaysFromQuery,\n    generateDaysFromCityAllocations,\n    addHotelToDay,\n    addTransportToDay,\n    addSightseeingToDay,\n    saveDraft,\n    generateProposal,\n    saveAccommodations,\n    loadSpecificDraft\n  };\n};\n","\nimport { useEffect, useRef, useCallback, useState } from 'react';\nimport { ItineraryDay } from '@/components/proposal/DayByDayItineraryBuilder';\nimport supabaseProposalService from '@/services/supabaseProposalService';\nimport { Query } from '@/types/query';\n\ninterface UseAutoSaveProposalOptions {\n  queryId: string;\n  days: ItineraryDay[];\n  totalCost: number;\n  query?: Query;\n  enabled?: boolean;\n  debounceMs?: number;\n  showToast?: boolean;\n}\n\nexport const useAutoSaveProposal = ({\n  queryId,\n  days,\n  totalCost,\n  query,\n  enabled = true,\n  debounceMs = 5000, // Increased from 2000ms to 5000ms for better typing experience\n  showToast = false\n}: UseAutoSaveProposalOptions) => {\n  // Add validation for queryId format to prevent invalid saves\n  const isValidQueryId = queryId && (typeof queryId === 'string') && queryId.length > 0;\n  \n  // Track if we've logged the missing query warning to avoid spam\n  const hasLoggedMissingQuery = useRef(false);\n  const saveTimeoutRef = useRef<NodeJS.Timeout>();\n  const lastSavedRef = useRef<string>('');\n  const isInitialMount = useRef(true);\n  const isSavingRef = useRef(false);\n  \n  // State for tracking save status\n  const [lastSaved, setLastSaved] = useState<Date | null>(null);\n  const [saveError, setSaveError] = useState<string | null>(null);\n\n  const saveProposal = useCallback(async () => {\n    // Prevent concurrent saves\n    if (isSavingRef.current) return;\n    \n    // Skip if no valid queryId - silent return, this is expected during initialization\n    if (!isValidQueryId) {\n      return;\n    }\n    \n    // Skip if no query data available - but only warn once to avoid console spam\n    if (!query || !query.id) {\n      if (!hasLoggedMissingQuery.current) {\n        console.warn('Auto-save skipped: Query data not available for queryId:', queryId);\n        hasLoggedMissingQuery.current = true;\n      }\n      return;\n    }\n    \n    // Reset the warning flag when query becomes available\n    hasLoggedMissingQuery.current = false;\n    \n    try {\n      isSavingRef.current = true;\n      setSaveError(null);\n      \n      const proposalData = {\n        queryId,\n        days,\n        totalCost,\n        savedAt: new Date().toISOString(),\n        version: Date.now()\n      };\n      \n      const dataString = JSON.stringify(proposalData);\n      \n      // Only save if data has actually changed\n      if (dataString === lastSavedRef.current) {\n        return;\n      }\n      \n      // Save to Supabase instead of localStorage\n      const { proposal_id, error } = await supabaseProposalService.upsertDraftProposal({\n        query,\n        days,\n        totalCost,\n        draftType: 'enhanced'\n      });\n      \n      if (error) {\n        console.error('Auto-save to Supabase failed:', error);\n        setSaveError(`Supabase save failed: ${error.message || error}`);\n        // Fallback to localStorage if Supabase fails\n        localStorage.setItem(`proposal_draft_${queryId}`, dataString);\n        console.warn('Auto-save fallback to localStorage');\n      } else {\n        lastSavedRef.current = dataString;\n        setLastSaved(new Date());\n        setSaveError(null);\n        console.log('Auto-saved proposal to Supabase at:', new Date().toLocaleTimeString());\n      }\n      \n      // Emit event for UI updates\n      window.dispatchEvent(new CustomEvent('proposal-saved'));\n      \n    } catch (error) {\n      console.error('Auto-save failed:', error);\n      setSaveError(`Auto-save failed: ${error}`);\n      // Final fallback to localStorage\n      try {\n        localStorage.setItem(`proposal_draft_${queryId}`, JSON.stringify({\n          queryId,\n          days,\n          totalCost,\n          savedAt: new Date().toISOString(),\n          version: Date.now()\n        }));\n        console.warn('Auto-save final fallback to localStorage');\n      } catch (fallbackError) {\n        console.error('Even localStorage fallback failed:', fallbackError);\n      }\n    } finally {\n      isSavingRef.current = false;\n    }\n  }, [queryId, days, totalCost, query, isValidQueryId]);\n\n  const triggerAutoSave = useCallback(() => {\n    if (!enabled || isSavingRef.current) return;\n    \n    // Skip auto-save on initial mount - but allow it if query just became available\n    if (isInitialMount.current && query && query.id) {\n      isInitialMount.current = false;\n    } else if (isInitialMount.current) {\n      return;\n    }\n    \n    // Skip auto-save if query data is not available yet - it will retry when data loads\n    if (!query || !query.id) {\n      return;\n    }\n    \n    // Clear existing timeout\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n    \n    // Set new timeout for debounced save with increased delay\n    saveTimeoutRef.current = setTimeout(() => {\n      saveProposal();\n    }, Math.max(debounceMs, 3000)); // Minimum 3 second delay\n  }, [enabled, debounceMs, saveProposal, query]);\n\n  // Auto-save when days or totalCost changes\n  useEffect(() => {\n    triggerAutoSave();\n  }, [days, totalCost, triggerAutoSave]);\n\n  // Retry auto-save when query data becomes available\n  useEffect(() => {\n    if (query && query.id && enabled && !isInitialMount.current) {\n      // Query data just became available, trigger auto-save\n      triggerAutoSave();\n    }\n  }, [query, enabled, triggerAutoSave]);\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Manual save function\n  const manualSave = useCallback(() => {\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n    saveProposal();\n  }, [saveProposal]);\n\n  return {\n    triggerAutoSave,\n    manualSave,\n    lastSaved,\n    saveError,\n    isSaving: isSavingRef.current\n  };\n};\n","\nimport { useState, useEffect, useMemo } from 'react';\nimport { Hotel } from '@/components/inventory/hotels/types/hotel';\nimport { sightseeingData } from '@/pages/inventory/sightseeing/data/initialData';\nimport { Sightseeing } from '@/types/sightseeing';\nimport { Restaurant } from '@/pages/inventory/restaurants/types/restaurantTypes';\nimport { initialRestaurants } from '@/pages/inventory/restaurants/data/restaurantData';\nimport { TransportRoute } from '@/pages/queries/types/proposalTypes';\nimport { transportRoutes } from '@/pages/inventory/transport/data/transportData';\nimport { initialCities } from '@/pages/inventory/cities/data/cityData';\nimport { initialCountries } from '@/pages/inventory/countries/data/countryData';\n\ninterface InventoryFilters {\n  countries?: string[];\n  cities?: string[];\n}\n\ninterface EnhancedInventoryData {\n  hotels: Hotel[];\n  restaurants: Restaurant[];\n  sightseeing: Sightseeing[];\n  transportRoutes: TransportRoute[];\n  cities: typeof initialCities;\n  countries: typeof initialCountries;\n  currency: string;\n  currencySymbol: string;\n  loading: boolean;\n  refreshData: () => void;\n}\n\n// Enhanced data loading functions with real-time updates\nconst getEnhancedSightseeingData = (): Sightseeing[] => {\n  try {\n    const data = localStorage.getItem('sightseeingData');\n    return data ? JSON.parse(data) : sightseeingData;\n  } catch (error) {\n    console.error('Error getting sightseeing data from localStorage:', error);\n    return sightseeingData;\n  }\n};\n\nconst getEnhancedHotelData = (): Hotel[] => {\n  try {\n    const data = localStorage.getItem('savedHotels');\n    return data ? JSON.parse(data) : [];\n  } catch (error) {\n    console.error('Error getting hotel data from localStorage:', error);\n    return [];\n  }\n};\n\nconst getEnhancedRestaurantData = (): Restaurant[] => {\n  try {\n    const data = localStorage.getItem('savedRestaurants');\n    if (data) {\n      return JSON.parse(data);\n    }\n    return initialRestaurants.map(restaurant => ({\n      ...restaurant,\n      id: restaurant.id,\n      vegOptions: restaurant.dietaryOptions?.vegetarian || false,\n      currencyCode: restaurant.currencySymbol ? (restaurant.currencySymbol === '$' ? 'USD' : 'THB') : 'USD'\n    })) as Restaurant[];\n  } catch (error) {\n    console.error('Error getting restaurant data from localStorage:', error);\n    return initialRestaurants.map(restaurant => ({\n      ...restaurant,\n      id: restaurant.id,\n      vegOptions: restaurant.dietaryOptions?.vegetarian || false,\n      currencyCode: restaurant.currencySymbol ? (restaurant.currencySymbol === '$' ? 'USD' : 'THB') : 'USD'\n    })) as Restaurant[];\n  }\n};\n\nconst getEnhancedTransportData = (): TransportRoute[] => {\n  try {\n    const data = localStorage.getItem('savedTransportRoutes');\n    if (data) {\n      return JSON.parse(data);\n    }\n    // Use all transport routes for enhanced filtering\n    return transportRoutes.map(route => ({\n      id: String(route.id),\n      from: route.from || '',\n      to: route.to || '',\n      distance: route.distance || 0,\n      duration: route.duration || '1h',\n      transportType: route.transportType || 'Car',\n      price: route.price || 0,\n      name: route.name || `${route.from || ''} to ${route.to || ''}`,\n      country: route.country || 'Thailand'\n    })) as TransportRoute[];\n  } catch (error) {\n    console.error('Error getting transport data from localStorage:', error);\n    return transportRoutes.map(route => ({\n      id: String(route.id),\n      from: route.from || '',\n      to: route.to || '',\n      distance: route.distance || 0,\n      duration: route.duration || '1h',\n      transportType: route.transportType || 'Car',\n      price: route.price || 0,\n      name: route.name || `${route.from || ''} to ${route.to || ''}`,\n      country: route.country || 'Thailand'\n    })) as TransportRoute[];\n  }\n};\n\nexport const useEnhancedInventoryData = (filters?: InventoryFilters): EnhancedInventoryData => {\n  const [data, setData] = useState<EnhancedInventoryData>({\n    hotels: [],\n    restaurants: [],\n    sightseeing: [],\n    transportRoutes: [],\n    cities: initialCities,\n    countries: initialCountries,\n    currency: 'USD',\n    currencySymbol: '$',\n    loading: true,\n    refreshData: () => {}\n  });\n\n  const [loading, setLoading] = useState(true);\n\n  const loadData = async () => {\n    setLoading(true);\n    try {\n      // Load enhanced real-time data\n      const hotelData = getEnhancedHotelData();\n      const sightseeingDataFromStorage = getEnhancedSightseeingData();\n      const restaurantData = getEnhancedRestaurantData();\n      const transportData = getEnhancedTransportData();\n\n      // Use only Supabase data - no fallback to mock data\n      let finalHotelData = hotelData;\n\n      // Process sightseeing data with enhanced typing\n      const processedSightseeingData = sightseeingDataFromStorage.map(item => {\n        const typedItem: Sightseeing = {\n          ...item,\n          price: item.price === undefined ? { adult: 0, child: 0 } : \n                 typeof item.price === 'number' ? { adult: item.price, child: item.price / 2 } : \n                 item.price\n        };\n        return typedItem;\n      });\n\n      setData(prevData => ({\n        ...prevData,\n        hotels: finalHotelData,\n        restaurants: restaurantData,\n        sightseeing: processedSightseeingData,\n        transportRoutes: transportData,\n        loading: false\n      }));\n\n      console.log('Enhanced inventory data loaded:', {\n        hotels: finalHotelData.length,\n        restaurants: restaurantData.length,\n        sightseeing: processedSightseeingData.length,\n        transportRoutes: transportData.length\n      });\n\n    } catch (error) {\n      console.error(\"Error loading enhanced inventory data:\", error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const refreshData = () => {\n    loadData();\n  };\n\n  // Enhanced filtering with real-time updates\n  const filteredData = useMemo(() => {\n    if (!filters || (!filters.countries?.length && !filters.cities?.length)) {\n      return { ...data, refreshData, loading };\n    }\n\n    const filterByLocation = (items: any[], locationFields: string[]) => {\n      return items.filter(item => {\n        // Check multiple location fields\n        const itemLocations = locationFields.map(field => item[field]).filter(Boolean);\n        if (itemLocations.length === 0) return true;\n\n        // Enhanced country matching\n        if (filters.countries?.length) {\n          const matchesCountry = filters.countries.some(country => \n            itemLocations.some(location => {\n              // Ensure location is a string before calling toLowerCase\n              const locationStr = String(location || '');\n              const countryStr = String(country || '');\n              return locationStr.toLowerCase().includes(countryStr.toLowerCase()) ||\n                     countryStr.toLowerCase().includes(locationStr.toLowerCase());\n            })\n          );\n          if (matchesCountry) return true;\n        }\n\n        // Enhanced city matching\n        if (filters.cities?.length) {\n          const matchesCity = filters.cities.some(city => \n            itemLocations.some(location => {\n              // Ensure location is a string before calling toLowerCase\n              const locationStr = String(location || '');\n              const cityStr = String(city || '');\n              return locationStr.toLowerCase().includes(cityStr.toLowerCase()) ||\n                     cityStr.toLowerCase().includes(locationStr.toLowerCase());\n            })\n          );\n          if (matchesCity) return true;\n        }\n\n        return false;\n      });\n    };\n\n    return {\n      ...data,\n      hotels: filterByLocation(data.hotels, ['city', 'location', 'address']),\n      restaurants: filterByLocation(data.restaurants, ['city', 'location', 'address']),\n      sightseeing: filterByLocation(data.sightseeing, ['city', 'location']),\n      transportRoutes: data.transportRoutes.filter(route => {\n        if (!filters.countries?.length && !filters.cities?.length) return true;\n        \n        const routeCountry = String(route.country || '');\n        const routeFrom = String(route.from || '');\n        const routeTo = String(route.to || '');\n\n        // Enhanced transport filtering\n        const matchesCountry = filters.countries?.some(country => {\n          const countryStr = String(country || '');\n          return routeCountry.toLowerCase().includes(countryStr.toLowerCase()) ||\n                 countryStr.toLowerCase().includes(routeCountry.toLowerCase());\n        });\n\n        const matchesCity = filters.cities?.some(city => {\n          const cityStr = String(city || '');\n          return routeFrom.toLowerCase().includes(cityStr.toLowerCase()) ||\n                 routeTo.toLowerCase().includes(cityStr.toLowerCase()) ||\n                 cityStr.toLowerCase().includes(routeFrom.toLowerCase()) ||\n                 cityStr.toLowerCase().includes(routeTo.toLowerCase());\n        });\n\n        return matchesCountry || matchesCity;\n      }),\n      refreshData,\n      loading\n    };\n  }, [data, filters, loading]);\n\n  useEffect(() => {\n    loadData();\n\n    // Enhanced storage change listener for real-time updates\n    const handleStorageChange = (e: StorageEvent) => {\n      const watchedKeys = ['savedHotels', 'sightseeingData', 'savedRestaurants', 'savedTransportRoutes'];\n      if (watchedKeys.includes(e.key || '')) {\n        console.log(`Storage changed for ${e.key}, refreshing enhanced inventory data`);\n        loadData();\n      }\n    };\n\n    // Listen for custom events as well for immediate updates\n    const handleCustomUpdate = () => {\n      console.log('Custom inventory update triggered');\n      loadData();\n    };\n\n    window.addEventListener('storage', handleStorageChange);\n    window.addEventListener('inventoryUpdate', handleCustomUpdate);\n\n    return () => {\n      window.removeEventListener('storage', handleStorageChange);\n      window.removeEventListener('inventoryUpdate', handleCustomUpdate);\n    };\n  }, []);\n\n  return filteredData;\n};\n","\nimport { useCallback, useRef } from 'react';\n\n/**\n * Custom hook for debouncing function calls\n * @param fn The function to debounce\n * @param delay Delay in milliseconds\n * @returns A debounced version of the function\n */\nexport function useDebounce<T extends (...args: any[]) => any>(\n  fn: T,\n  delay: number\n): { debouncedFn: (...args: Parameters<T>) => void; cancel: () => void } {\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  \n  const debouncedFn = useCallback((...args: Parameters<T>) => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    \n    timeoutRef.current = setTimeout(() => {\n      fn(...args);\n      timeoutRef.current = null;\n    }, delay);\n  }, [fn, delay]);\n\n  const cancel = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n  }, []);\n\n  return { debouncedFn, cancel };\n}\n","import { useState, useEffect, useCallback, useRef } from 'react';\n\n// UUID validation regex - shared across the hook\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nconst ENQUIRY_REGEX = /^ENQ\\d{8,}$/i;\nconst DEQ_ENQUIRY_REGEX = /^DEQ\\/\\d{4}\\/\\d{3,}$/i;\nconst DRAFT_REGEX = /^DRAFT-ENQ\\d{8,}.*$/i;\nimport { supabase } from '@/lib/supabaseClient';\nimport { \n  OptionalRecords, \n  UseOptionalRecordsReturn,\n  OptionalRecordsConfig,\n  DEFAULT_OPTIONAL_RECORDS_CONFIG,\n  ComponentOptionalRecord\n} from '@/types/optionalRecords';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { useToast } from '@/hooks/use-toast';\n\n/**\n * Direct Supabase functions for optional records\n */\n\n/**\n * Get optional records for a specific proposal directly from Supabase\n */\nasync function getOptionalRecordsDirect(proposalId: string): Promise<OptionalRecords> {\n  try {\n    console.log(` Fetching optional records for proposal: ${proposalId}`);\n    \n    // Validate proposalId format - accept UUIDs, ENQ format, DEQ format, and draft format\n    if (!UUID_REGEX.test(proposalId) && !ENQUIRY_REGEX.test(proposalId) && !DEQ_ENQUIRY_REGEX.test(proposalId) && !DRAFT_REGEX.test(proposalId)) {\n      console.warn(` Invalid format for proposalId: ${proposalId}. Using empty records.`);\n      return {};\n    }\n    \n    // Determine which field to query by\n    let query = supabase.from('proposals').select('optional_records');\n    \n    if (UUID_REGEX.test(proposalId)) {\n      // If it's a UUID, query by the 'id' field\n      query = query.eq('id', proposalId);\n    } else {\n      // If it's an enquiry ID or draft format, query by the 'proposal_id' field\n      query = query.eq('proposal_id', proposalId);\n    }\n    \n    const { data, error } = await query.maybeSingle();\n\n    if (error) {\n      console.error(' Error fetching optional records:', error);\n      throw new Error(`Failed to fetch optional records: ${error.message}`);\n    }\n\n    // Handle case where no record is found\n    if (!data) {\n      console.log(' No proposal record found, returning empty optional records');\n      return {};\n    }\n\n    const optionalRecords = data?.optional_records || {};\n    console.log(' Optional records fetched successfully:', optionalRecords);\n    return optionalRecords;\n    \n  } catch (error) {\n    console.error(' Exception in getOptionalRecordsDirect:', error);\n    throw error;\n  }\n}\n\n/**\n * Update optional status for a specific item directly in Supabase\n */\nasync function updateOptionalItemDirect(\n  proposalId: string,\n  itemType: 'activity' | 'transport' | 'sightseeing',\n  itemId: string,\n  isOptional: boolean,\n  userId: string\n): Promise<boolean> {\n  try {\n    console.log(` Updating optional status: ${itemType} ${itemId} -> ${isOptional ? 'optional' : 'included'}`);\n    \n    // Get current optional records\n    const currentRecords = await getOptionalRecordsDirect(proposalId);\n    \n    // Determine the record type mapping\n    const recordType = mapItemTypeToRecordType(itemType);\n    \n    // Initialize structure if needed\n    if (!currentRecords[recordType]) {\n      currentRecords[recordType] = [];\n    }\n\n    // Find existing record or create new one\n    const records = currentRecords[recordType] as ComponentOptionalRecord[];\n    const existingIndex = records.findIndex((record: ComponentOptionalRecord) => \n      record.optionId === itemId\n    );\n\n    const updatedRecord: ComponentOptionalRecord = {\n      optionId: itemId,\n      isOptional,\n      updatedAt: new Date().toISOString(),\n      updatedBy: userId,\n      ...(existingIndex >= 0 ? records[existingIndex] : {})\n    };\n\n    if (existingIndex >= 0) {\n      records[existingIndex] = updatedRecord;\n    } else {\n      records.push(updatedRecord);\n    }\n\n    // Determine which field to update by\n    let updateQuery = supabase\n      .from('proposals')\n      .update({\n        optional_records: currentRecords,\n        last_saved: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      });\n    \n    if (UUID_REGEX.test(proposalId)) {\n      // If it's a UUID, update by the 'id' field\n      updateQuery = updateQuery.eq('id', proposalId);\n    } else {\n      // If it's an enquiry ID or draft format, update by the 'proposal_id' field\n      updateQuery = updateQuery.eq('proposal_id', proposalId);\n    }\n\n    const { error } = await updateQuery;\n\n    if (error) {\n      throw new Error(`Database update failed: ${error.message}`);\n    }\n\n    console.log(' Optional item updated successfully');\n    return true;\n    \n  } catch (error) {\n    console.error(' Error updating optional item:', error);\n    throw error;\n  }\n}\n\n/**\n * Map item type to record type\n */\nfunction mapItemTypeToRecordType(itemType: string): keyof OptionalRecords {\n  switch (itemType) {\n    case 'activity':\n    case 'sightseeing':\n      return 'sightseeing';\n    case 'transport':\n      return 'transport';\n    default:\n      return 'sightseeing';\n  }\n}\n\n/**\n * useOptionalRecords Hook - Direct Supabase Implementation\n */\nexport const useOptionalRecords = (\n  proposalId: string | null,\n  config: Partial<OptionalRecordsConfig> = {}\n): UseOptionalRecordsReturn => {\n  const { user } = useAuth();\n  const { toast } = useToast();\n  \n  // Merge configuration with defaults\n  const finalConfig = { ...DEFAULT_OPTIONAL_RECORDS_CONFIG, ...config };\n  \n  // State management\n  const [optionalRecords, setOptionalRecords] = useState<OptionalRecords>({});\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  \n  // Refs for internal state\n  const pendingUpdates = useRef<Map<string, boolean>>(new Map());\n  const subscriptionRef = useRef<(() => void) | null>(null);\n  const isMounted = useRef(true);\n\n  /**\n   * Initialize optional records and setup real-time subscription\n   */\n  useEffect(() => {\n    if (!proposalId || !user) {\n      console.log(' Skipping optional records initialization - missing proposalId or user');\n      return;\n    }\n\n    // Validate proposalId format - accept UUIDs, ENQ format, DEQ format, and draft format\n    if (!UUID_REGEX.test(proposalId) && !ENQUIRY_REGEX.test(proposalId) && !DEQ_ENQUIRY_REGEX.test(proposalId) && !DRAFT_REGEX.test(proposalId)) {\n      console.warn(` Invalid format for proposalId: ${proposalId}. Skipping optional records initialization.`);\n      return;\n    }\n\n    const initializeOptionalRecords = async () => {\n      try {\n        setIsLoading(true);\n        setError(null);\n        \n        console.log(` Initializing optional records for proposal: ${proposalId}`);\n        \n        // Fetch initial data\n        const records = await getOptionalRecordsDirect(proposalId);\n        \n        if (isMounted.current) {\n          setOptionalRecords(records);\n          console.log(' Optional records initialized successfully');\n        }\n\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Failed to load optional records';\n        console.error(' Error initializing optional records:', error);\n        \n        if (isMounted.current) {\n          setError(errorMessage);\n          toast({\n            title: \"Error Loading Optional Records\",\n            description: errorMessage,\n            variant: \"destructive\",\n          });\n        }\n      } finally {\n        if (isMounted.current) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    // Setup real-time subscription\n    const setupSubscription = () => {\n      if (!finalConfig.enableRealTimeSync) return;\n      \n      console.log(` Setting up real-time subscription for proposal: ${proposalId}`);\n      \n      try {\n        // Determine which field to filter by\n        const filter = UUID_REGEX.test(proposalId) ? `id=eq.${proposalId}` : `proposal_id=eq.${proposalId}`;\n        \n        const unsubscribe = supabase\n          .channel(`proposal-${proposalId}`)\n          .on(\n            'postgres_changes',\n            {\n              event: 'UPDATE',\n              schema: 'public',\n              table: 'proposals',\n              filter: filter\n            },\n            (payload) => {\n              console.log(' Real-time update received:', payload);\n              const newOptionalRecords = payload.new.optional_records || {};\n              if (isMounted.current) {\n                setOptionalRecords(newOptionalRecords);\n              }\n            }\n          )\n          .subscribe();\n        \n        subscriptionRef.current = unsubscribe;\n        console.log(' Real-time subscription setup successful');\n      } catch (error) {\n        console.error(' Error setting up real-time subscription:', error);\n        subscriptionRef.current = null;\n      }\n    };\n\n    // Handle online/offline status\n    const handleOnline = () => {\n      setIsOnline(true);\n      setError(null);\n      console.log(' Back online, refreshing optional records');\n      initializeOptionalRecords();\n    };\n\n    const handleOffline = () => {\n      setIsOnline(false);\n      console.log(' Gone offline');\n    };\n\n    // Initialize\n    initializeOptionalRecords();\n    setupSubscription();\n    \n    // Setup event listeners\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    // Cleanup\n    return () => {\n      console.log(` Cleaning up optional records for proposal: ${proposalId}`);\n      \n      if (subscriptionRef.current && typeof subscriptionRef.current === 'function') {\n        try {\n          subscriptionRef.current();\n        } catch (error) {\n          console.error('Error unsubscribing from real-time updates:', error);\n        }\n        subscriptionRef.current = null;\n      }\n      \n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, [proposalId, user, finalConfig.enableRealTimeSync, toast]);\n\n  /**\n   * Update optional status for a specific item\n   */\n  const updateOptionalItem = useCallback(async (\n    itemId: string,\n    itemType: 'activity' | 'transport' | 'sightseeing',\n    isOptional: boolean\n  ): Promise<void> => {\n    if (!proposalId || !user) {\n      console.warn(' Cannot update optional item - missing proposalId or user');\n      return;\n    }\n\n    // Validate proposalId format - accept UUIDs, ENQ format, DEQ format, and draft format\n    if (!UUID_REGEX.test(proposalId) && !ENQUIRY_REGEX.test(proposalId) && !DEQ_ENQUIRY_REGEX.test(proposalId) && !DRAFT_REGEX.test(proposalId)) {\n      console.warn(` Invalid format for proposalId: ${proposalId}. Skipping update.`);\n      return;\n    }\n\n    const updateKey = `${itemType}-${itemId}`;\n    \n    try {\n      // Optimistic update\n      if (finalConfig.enableDebouncing) {\n        pendingUpdates.current.set(updateKey, true);\n        \n        // Update local state immediately\n        setOptionalRecords(prev => {\n          const newRecords = { ...prev };\n          const recordType = mapItemTypeToRecordType(itemType);\n          \n          if (!newRecords[recordType]) {\n            newRecords[recordType] = [];\n          }\n          \n          const records = newRecords[recordType] as any[];\n          const existingIndex = records.findIndex(r => r.optionId === itemId);\n          \n          const updatedRecord = {\n            optionId: itemId,\n            isOptional,\n            updatedAt: new Date().toISOString(),\n            updatedBy: user.id\n          };\n          \n          if (existingIndex >= 0) {\n            records[existingIndex] = updatedRecord;\n          } else {\n            records.push(updatedRecord);\n          }\n          \n          return newRecords;\n        });\n      }\n\n      // Perform actual update\n      await updateOptionalItemDirect(\n        proposalId,\n        itemType,\n        itemId,\n        isOptional,\n        user.id\n      );\n\n      pendingUpdates.current.delete(updateKey);\n      \n      // Show success toast\n      toast({\n        title: \"Updated\",\n        description: `Item marked as ${isOptional ? 'optional' : 'required'}`,\n        variant: \"default\",\n        duration: 2000,\n      });\n\n    } catch (error) {\n      pendingUpdates.current.delete(updateKey);\n      \n      const errorMessage = error instanceof Error ? error.message : 'Update failed';\n      console.error(' Error updating optional item:', error);\n      \n      setError(errorMessage);\n      \n      // Revert optimistic update on error\n      if (finalConfig.enableDebouncing) {\n        setOptionalRecords(prev => {\n          const newRecords = { ...prev };\n          const recordType = mapItemTypeToRecordType(itemType);\n          \n          if (newRecords[recordType]) {\n            const records = newRecords[recordType] as any[];\n            const existingIndex = records.findIndex(r => r.optionId === itemId);\n            \n            if (existingIndex >= 0) {\n              // Revert to previous state\n              records[existingIndex].isOptional = !isOptional;\n            }\n          }\n          \n          return newRecords;\n        });\n      }\n\n      toast({\n        title: \"Update Failed\",\n        description: errorMessage,\n        variant: \"destructive\",\n        duration: 5000,\n      });\n\n      throw error;\n    }\n  }, [proposalId, user, finalConfig.enableDebouncing, toast]);\n\n  /**\n   * Get optional status for a specific item\n   */\n  const getOptionalStatus = useCallback((\n    itemId: string,\n    itemType: 'activity' | 'transport' | 'sightseeing'\n  ): boolean => {\n    try {\n      const recordType = mapItemTypeToRecordType(itemType);\n      const records = optionalRecords?.[recordType] || [];\n      const record = records.find((r: ComponentOptionalRecord) => r.optionId === itemId);\n      return record?.isOptional || false;\n    } catch (error) {\n      console.error(' Error getting optional status:', error);\n      return false; // Default to included on error\n    }\n  }, [optionalRecords]);\n\n  /**\n   * Refresh optional records from database\n   */\n  const refreshOptionalRecords = useCallback(async (): Promise<void> => {\n    if (!proposalId) return;\n\n    try {\n      setIsLoading(true);\n      const records = await getOptionalRecordsDirect(proposalId);\n      setOptionalRecords(records);\n      setError(null);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Failed to refresh';\n      setError(errorMessage);\n      console.error(' Error refreshing optional records:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [proposalId]);\n\n  /**\n   * Cleanup on unmount\n   */\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n      pendingUpdates.current.clear();\n      \n      if (subscriptionRef.current && typeof subscriptionRef.current === 'function') {\n        try {\n          subscriptionRef.current();\n        } catch (error) {\n          console.error('Error unsubscribing from real-time updates during cleanup:', error);\n        }\n        subscriptionRef.current = null;\n      }\n    };\n  }, []);\n\n  return {\n    optionalRecords,\n    isLoading,\n    error,\n    isOnline,\n    updateOptionalItem,\n    getOptionalStatus,\n    refreshOptionalRecords,\n  };\n};\n\n/**\n * useOptionalItem Hook - Simplified hook for managing a single optional item's state\n */\nexport const useOptionalItem = (\n  proposalId: string | null,\n  itemId: string,\n  itemType: 'activity' | 'transport' | 'sightseeing'\n) => {\n  const {\n    optionalRecords,\n    isLoading,\n    error,\n    updateOptionalItem,\n    getOptionalStatus,\n  } = useOptionalRecords(proposalId);\n\n  const isOptional = getOptionalStatus(itemId, itemType);\n\n  const updateItem = useCallback(async (newOptional: boolean) => {\n    return updateOptionalItem(itemId, itemType, newOptional);\n  }, [updateOptionalItem, itemId, itemType]);\n\n  return {\n    isOptional,\n    isLoading,\n    error,\n    updateItem,\n  };\n};\n\nexport default useOptionalRecords;","import { useState, useEffect, useCallback } from 'react';\nimport { ProposalSummarySnapshot } from '@/utils/markupSync';\nimport { useProposalPersistence } from '@/hooks/useProposalPersistence';\n\nexport const useProposalRealtimeSync = (queryId: string, draftType: 'daywise' | 'enhanced' = 'enhanced') => {\n  const { data: persistenceData, loadData } = useProposalPersistence(queryId, draftType);\n  const [snapshot, setSnapshot] = useState<ProposalSummarySnapshot | null>(null);\n  const [lastUpdate, setLastUpdate] = useState<string>('');\n\n  // Refresh data manually - moved before use\n  const refresh = useCallback(() => {\n    loadData();\n  }, [loadData]);\n\n  // Extract snapshot from persistence data\n  useEffect(() => {\n    if (persistenceData.accommodationData?.markupData?.options) {\n      const markupData = persistenceData.accommodationData.markupData;\n      const newSnapshot: ProposalSummarySnapshot = {\n        baseCost: markupData.options[0]?.baseTotal || 0,\n        serviceCosts: markupData.options[0]?.serviceCosts || {\n          sightseeing: { total: 0 },\n          transport: { totalCost: 0, perPersonCost: 0 },\n          dining: { total: 0 },\n          accommodation: { totalCost: 0, perPersonCost: 0, totalRooms: 0, totalNights: 0 }\n        },\n        accommodationOptions: markupData.options || [],\n        currency: 'USD',\n        lastCalculated: persistenceData.lastSaved || new Date().toISOString()\n      };\n      setSnapshot(newSnapshot);\n      setLastUpdate(persistenceData.lastSaved);\n    }\n  }, [persistenceData]);\n\n  // Listen for localStorage changes from other tabs/windows\n  useEffect(() => {\n    const handleStorageChange = (e: StorageEvent) => {\n      if (e.key && e.key.includes(`proposal_persistence_${queryId}`)) {\n        loadData();\n      }\n    };\n\n    window.addEventListener('storage', handleStorageChange);\n    return () => window.removeEventListener('storage', handleStorageChange);\n  }, [queryId, loadData]);\n\n  // Phase 4: Listen for custom events from proposal summary updates\n  useEffect(() => {\n    const handleProposalUpdate = (event: CustomEvent) => {\n      const { queryId: eventQueryId, snapshot: newSnapshot } = event.detail;\n      if (eventQueryId === queryId) {\n        setSnapshot(newSnapshot);\n        setLastUpdate(new Date().toISOString());\n      }\n    };\n\n    const handlePricingUpdate = (event: CustomEvent) => {\n      const { queryId: eventQueryId, snapshot: newSnapshot } = event.detail;\n      if (eventQueryId === queryId) {\n        setSnapshot(newSnapshot);\n        setLastUpdate(new Date().toISOString());\n        console.log('Real-time pricing sync updated:', newSnapshot);\n      }\n    };\n\n    const handleTermsUpdate = (event: CustomEvent) => {\n      const { queryId: eventQueryId, terms } = event.detail;\n      if (eventQueryId === queryId) {\n        setLastUpdate(new Date().toISOString());\n        console.log('Real-time terms sync updated:', terms);\n        // Refresh data to get updated snapshot\n        refresh();\n      }\n    };\n\n    window.addEventListener('proposal-summary-updated', handleProposalUpdate as EventListener);\n    window.addEventListener('proposal-pricing-updated', handlePricingUpdate as EventListener);\n    window.addEventListener('proposal-terms-updated', handleTermsUpdate as EventListener);\n    \n    return () => {\n      window.removeEventListener('proposal-summary-updated', handleProposalUpdate as EventListener);\n      window.removeEventListener('proposal-pricing-updated', handlePricingUpdate as EventListener);\n      window.removeEventListener('proposal-terms-updated', handleTermsUpdate as EventListener);\n    };\n  }, [queryId, refresh]);\n\n  return {\n    snapshot,\n    lastUpdate,\n    persistenceData,\n    refresh,\n    hasData: !!snapshot\n  };\n};","import { useEffect, useMemo, useState } from \"react\";\nimport { supabase } from \"../lib/supabaseClient\";\nimport { AgentManagementService } from \"../services/agentManagementService\";\nimport type { Query } from \"../types/query\";\n\nexport interface AgentContactDetails {\n  name: string;\n  email: string;\n  phone: string;\n  company: string;\n  address?: string;\n  alternateEmail?: string;\n  mobileNumbers?: string[];\n  profileImage?: string;\n}\n\ntype HookResult = {\n  contact: AgentContactDetails | null;\n  loading: boolean;\n  error: Error | null;\n};\n\n/**\n * Resolve agent contact details from Supabase public.agents table.\n * Primary key lookup uses query.agentUuid when available; otherwise attempts name-based lookup.\n * Falls back gracefully if Supabase is unreachable.\n */\nexport function useSupabaseAgentContact(query: Query | null | undefined): HookResult {\n  const [contact, setContact] = useState<AgentContactDetails | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const agentKey = useMemo(() => {\n    if (!query) return \"\";\n    return [query.agentUuid || \"\", query.agentName || \"\"].join(\":\");\n  }, [query]);\n\n  useEffect(() => {\n    let cancelled = false;\n    async function fetchAgent() {\n      if (!query) {\n        setContact(null);\n        return;\n      }\n      setLoading(true);\n      setError(null);\n      try {\n        // Prefer direct lookup by UUID id\n        let agentRecord: any | null = null;\n        const candidateUuid = query.agentUuid || null;\n\n        if (candidateUuid) {\n          // Use a loosely typed client to avoid deep TS type instantiation\n          const sb: any = supabase;\n          const { data, error: supErr } = await sb\n            .from(\"agents\")\n            .select(\n              \"id, user_id, name, email, agency_name, agency_code, business_phone, business_address, website, alternate_email, mobile_numbers, city, country, profile_image\"\n            )\n            .eq(\"id\", candidateUuid)\n            .limit(1);\n          if (supErr) throw supErr;\n          agentRecord = (data && data[0]) || null;\n\n          // If not found by id, attempt user_id match with same uuid\n          if (!agentRecord) {\n            const { data: byUser, error: supErr2 } = await sb\n              .from(\"agents\")\n              .select(\n                \"id, user_id, name, email, agency_name, agency_code, business_phone, business_address, website, alternate_email, mobile_numbers, city, country, profile_image\"\n              )\n              .eq(\"user_id\", candidateUuid)\n              .limit(1);\n            if (supErr2) throw supErr2;\n            agentRecord = (byUser && byUser[0]) || null;\n          }\n        }\n\n        // If still not found and we have agentName, attempt name-based lookup\n        if (!agentRecord && query.agentName) {\n          const sb: any = supabase;\n          const { data: byName, error: nameErr } = await sb\n            .from(\"agents\")\n            .select(\n              \"id, user_id, name, email, agency_name, agency_code, business_phone, business_address, website, alternate_email, mobile_numbers, city, country, profile_image\"\n            )\n            .eq(\"name\", query.agentName)\n            .limit(1);\n          if (nameErr) throw nameErr;\n          agentRecord = (byName && byName[0]) || null;\n        }\n\n        // Final fallback: use management service if available\n        if (!agentRecord && candidateUuid) {\n          try {\n            const managedRes = await AgentManagementService.getAgentById(candidateUuid);\n            const managed: any = managedRes && (managedRes as any).data;\n            if (managed) {\n              agentRecord = {\n                id: managed.id,\n                user_id: managed.user_id,\n                name: managed.name,\n                email: managed.email,\n                agency_name: managed.agency_name || managed.company_name,\n                business_phone: managed.business_phone || managed.phone,\n                business_address: managed.business_address || managed.address,\n                website: managed.website,\n                alternate_email: managed.alternate_email,\n                mobile_numbers: managed.mobile_numbers,\n                city: managed.city,\n                country: managed.country,\n                profile_image: managed.profile_image,\n              };\n            }\n          } catch (_) {\n            // ignore fallback errors\n          }\n        }\n\n        // Map to contact details\n        const mapped: AgentContactDetails | null = agentRecord\n          ? {\n              name:\n                agentRecord.name || query.agentName || \"\",\n              email:\n                agentRecord.email || agentRecord.alternate_email || \"\",\n              phone:\n                agentRecord.business_phone || (Array.isArray(agentRecord.mobile_numbers) ? agentRecord.mobile_numbers[0] : \"\") || \"\",\n              company:\n                agentRecord.agency_name || \"\",\n              address:\n                agentRecord.business_address || [agentRecord.city, agentRecord.country].filter(Boolean).join(\", \") || undefined,\n              alternateEmail:\n                agentRecord.alternate_email || undefined,\n              mobileNumbers:\n                Array.isArray(agentRecord.mobile_numbers) ? agentRecord.mobile_numbers : undefined,\n              profileImage:\n                agentRecord.profile_image || undefined,\n            }\n          : query.agentName\n          ? {\n              name: query.agentName,\n              email: \"\",\n              phone: \"\",\n              company: \"\",\n              address: undefined,\n              alternateEmail: undefined,\n              mobileNumbers: undefined,\n              profileImage: undefined,\n            }\n          : null;\n\n        if (!cancelled) {\n          setContact(mapped);\n        }\n      } catch (err: any) {\n        if (!cancelled) {\n          setError(err);\n          // Graceful fallback to minimal contact from query\n          setContact(\n            query?.agentName\n              ? {\n                  name: query.agentName,\n                  email: \"\",\n                  phone: \"\",\n                  company: \"\",\n                  address: undefined,\n                }\n              : null\n          );\n        }\n      } finally {\n        if (!cancelled) setLoading(false);\n      }\n    }\n    fetchAgent();\n    return () => {\n      cancelled = true;\n    };\n  }, [agentKey]);\n\n  return { contact, loading, error };\n}","import { useMemo } from 'react';\nimport { Query } from '@/types/query';\nimport { ItineraryDay } from '@/components/proposal/DayByDayItineraryBuilder';\n\ninterface ValidationRule {\n  id: string;\n  label: string;\n  status: 'valid' | 'warning' | 'invalid';\n  message: string;\n  skippable?: boolean;\n  skipped?: boolean;\n}\n\ninterface UseProposalValidationProps {\n  query: Query | null;\n  days: ItineraryDay[];\n  totalCost: number;\n  skippedRules?: string[];\n  proposalManagementData?: any;\n}\n\nexport const useProposalValidation = ({\n  query,\n  days,\n  totalCost,\n  skippedRules = [],\n  proposalManagementData\n}: UseProposalValidationProps) => {\n  const validationRules = useMemo((): ValidationRule[] => {\n    const rules: ValidationRule[] = [];\n\n    // Early return if query is null\n    if (!query) {\n      rules.push({\n        id: 'no-query',\n        label: 'Query Data',\n        status: 'invalid',\n        message: 'Query data is not available'\n      });\n      return rules;\n    }\n\n    // Check if itinerary has days\n    if (days.length === 0) {\n      rules.push({\n        id: 'no-days',\n        label: 'Itinerary Days',\n        status: 'invalid',\n        message: 'At least one day must be added to the itinerary'\n      });\n    } else {\n      rules.push({\n        id: 'has-days',\n        label: 'Itinerary Days',\n        status: 'valid',\n        message: `${days.length} days configured`\n      });\n    }\n\n    // Check if days have activities\n    const daysWithoutActivities = days.filter(day => day.activities.length === 0);\n    if (daysWithoutActivities.length > 0) {\n      rules.push({\n        id: 'empty-days',\n        label: 'Day Activities',\n        status: 'warning',\n        message: `${daysWithoutActivities.length} day(s) have no activities`\n      });\n    } else if (days.length > 0) {\n      rules.push({\n        id: 'all-days-have-activities',\n        label: 'Day Activities',\n        status: 'valid',\n        message: 'All days have activities configured'\n      });\n    }\n\n    // Check total cost\n    if (totalCost <= 0) {\n      rules.push({\n        id: 'no-cost',\n        label: 'Proposal Pricing',\n        status: 'warning',\n        message: 'Total cost is zero - pricing may need review'\n      });\n    } else {\n      rules.push({\n        id: 'has-cost',\n        label: 'Proposal Pricing',\n        status: 'valid',\n        message: `Total cost: $${totalCost.toFixed(2)}`\n      });\n    }\n\n    // Check trip duration match\n    const expectedDays = query.tripDuration?.days || 0;\n    if (expectedDays > 0 && days.length !== expectedDays) {\n      rules.push({\n        id: 'duration-mismatch',\n        label: 'Trip Duration',\n        status: 'warning',\n        message: `Itinerary has ${days.length} days but query requested ${expectedDays} days`\n      });\n    } else if (expectedDays > 0) {\n      rules.push({\n        id: 'duration-match',\n        label: 'Trip Duration',\n        status: 'valid',\n        message: `Trip duration matches query (${expectedDays} days)`\n      });\n    }\n\n    // Check for accommodations (skippable)\n    const accommodationActivities = days.flatMap(day => \n      day.activities.filter(activity => activity.type === 'accommodation')\n    );\n    \n    if (skippedRules.includes('no-accommodation')) {\n      rules.push({\n        id: 'no-accommodation',\n        label: 'Accommodations',\n        status: 'valid',\n        message: 'Accommodation requirement skipped',\n        skippable: true,\n        skipped: true\n      });\n    } else if (accommodationActivities.length === 0) {\n      rules.push({\n        id: 'no-accommodation',\n        label: 'Accommodations',\n        status: 'warning',\n        message: 'No accommodations found in itinerary (this can be skipped)',\n        skippable: true\n      });\n    } else {\n      rules.push({\n        id: 'has-accommodation',\n        label: 'Accommodations',\n        status: 'valid',\n        message: `${accommodationActivities.length} accommodation(s) configured`\n      });\n    }\n\n    // Enhanced activity validation with completeness check\n    const allActivities = days.flatMap(day => day.activities);\n    const sightseeingActivities = allActivities.filter(activity => activity.type === 'sightseeing');\n    const transportActivities = allActivities.filter(activity => activity.type === 'transport');\n    \n    // Check activity data completeness\n    const incompleteActivities = allActivities.filter(activity => {\n      // Check if activity has essential data based on type\n      switch (activity.type) {\n        case 'sightseeing':\n          return !activity.selectedOptions?.length && !activity.packageOptions?.length;\n        case 'transport':\n          return !(activity as any).from || !(activity as any).to || !(activity as any).vehicleType;\n        default:\n          return false;\n      }\n    });\n    \n    if (incompleteActivities.length > 0) {\n      rules.push({\n        id: 'incomplete-activities',\n        label: 'Activity Data Completeness',\n        status: 'warning',\n        message: `${incompleteActivities.length} activity(ies) have incomplete configuration data`\n      });\n    } else if (allActivities.length > 0) {\n      rules.push({\n        id: 'complete-activities',\n        label: 'Activity Data Completeness',\n        status: 'valid',\n        message: 'All activities have complete configuration data'\n      });\n    }\n\n    // Sightseeing activities validation\n    if (sightseeingActivities.length === 0) {\n      rules.push({\n        id: 'no-sightseeing',\n        label: 'Sightseeing Activities',\n        status: 'warning',\n        message: 'No sightseeing activities found'\n      });\n    } else {\n      const completeSightseeing = sightseeingActivities.filter(activity => \n        activity.selectedOptions?.length || activity.packageOptions?.length\n      );\n      rules.push({\n        id: 'has-sightseeing',\n        label: 'Sightseeing Activities',\n        status: completeSightseeing.length === sightseeingActivities.length ? 'valid' : 'warning',\n        message: `${sightseeingActivities.length} sightseeing activity(ies) - ${completeSightseeing.length} with complete data`\n      });\n    }\n    \n    // Transport activities validation\n    if (transportActivities.length === 0) {\n      rules.push({\n        id: 'no-transport',\n        label: 'Transportation',\n        status: 'warning',\n        message: 'No transportation activities found'\n      });\n    } else {\n      const completeTransport = transportActivities.filter(activity => \n        (activity as any).from && (activity as any).to && (activity as any).vehicleType\n      );\n      rules.push({\n        id: 'has-transport',\n        label: 'Transportation',\n        status: completeTransport.length === transportActivities.length ? 'valid' : 'warning',\n        message: `${transportActivities.length} transport activity(ies) - ${completeTransport.length} with complete data`\n      });\n    }\n\n    // Check proposal management data completeness\n    if (proposalManagementData) {\n      // Check terms & conditions\n      const hasTerms = proposalManagementData.termsConditions && \n        (proposalManagementData.termsConditions.inclusions?.length > 0 ||\n         proposalManagementData.termsConditions.exclusions?.length > 0 ||\n         proposalManagementData.termsConditions.paymentTerms ||\n         proposalManagementData.termsConditions.cancellationPolicy);\n      \n      if (hasTerms) {\n        rules.push({\n          id: 'has-terms',\n          label: 'Terms & Conditions',\n          status: 'valid',\n          message: 'Terms and conditions have been configured'\n        });\n      } else {\n        rules.push({\n          id: 'no-terms',\n          label: 'Terms & Conditions',\n          status: 'warning',\n          message: 'Terms and conditions not configured in Proposal Management'\n        });\n      }\n\n      // Check email configuration\n      const hasEmailConfig = proposalManagementData.emailData &&\n        (proposalManagementData.emailData.to || proposalManagementData.emailData.subject);\n      \n      if (hasEmailConfig) {\n        rules.push({\n          id: 'has-email-config',\n          label: 'Email Configuration',\n          status: 'valid',\n          message: 'Email settings configured for proposal sharing'\n        });\n      } else {\n        rules.push({\n          id: 'no-email-config',\n          label: 'Email Configuration',\n          status: 'warning',\n          message: 'Email settings not configured in Proposal Management'\n        });\n      }\n\n      // Check pricing configuration\n      const hasPricingConfig = proposalManagementData.pricingConfig &&\n        (proposalManagementData.pricingConfig.mode || \n         proposalManagementData.pricingConfig.adultMarkup ||\n         proposalManagementData.pricingConfig.childMarkup);\n      \n      if (hasPricingConfig) {\n        rules.push({\n          id: 'has-pricing-config',\n          label: 'Pricing Configuration',\n          status: 'valid',\n          message: 'Pricing and markup settings configured'\n        });\n      } else {\n        rules.push({\n          id: 'no-pricing-config',\n          label: 'Pricing Configuration',\n          status: 'warning',\n          message: 'Pricing and markup not configured in Proposal Management'\n        });\n      }\n    } else {\n      rules.push({\n        id: 'no-proposal-management',\n        label: 'Proposal Management',\n        status: 'warning',\n        message: 'No proposal management data found - configure in Proposal Management tab'\n      });\n    }\n\n    return rules;\n  }, [query, days, totalCost, skippedRules, proposalManagementData]);\n\n  const hasErrors = validationRules.some(rule => rule.status === 'invalid');\n  const hasWarnings = validationRules.some(rule => rule.status === 'warning');\n  const isValid = !hasErrors;\n\n  return {\n    validationRules,\n    hasErrors,\n    hasWarnings,\n    isValid\n  };\n};","import { useState, useCallback } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface GenerationStep {\n  id: string;\n  label: string;\n  status: 'pending' | 'active' | 'completed' | 'error';\n  description?: string;\n}\n\ninterface UseProposalGenerationProps {\n  generateProposal: () => Promise<string>;\n}\n\nexport const useProposalGeneration = ({ generateProposal }: UseProposalGenerationProps) => {\n  const navigate = useNavigate();\n  const { toast } = useToast();\n  \n  const [isGenerating, setIsGenerating] = useState(false);\n  const [currentProgress, setCurrentProgress] = useState(0);\n  const [generationSteps, setGenerationSteps] = useState<GenerationStep[]>([\n    {\n      id: 'validation',\n      label: 'Validating proposal data',\n      status: 'pending',\n      description: 'Checking itinerary completeness and data integrity'\n    },\n    {\n      id: 'processing',\n      label: 'Processing itinerary',\n      status: 'pending',\n      description: 'Converting activities and calculating costs'\n    },\n    {\n      id: 'formatting',\n      label: 'Formatting proposal',\n      status: 'pending',\n      description: 'Creating proposal document structure'\n    },\n    {\n      id: 'saving',\n      label: 'Saving proposal',\n      status: 'pending',\n      description: 'Storing proposal data and generating ID'\n    },\n    {\n      id: 'finalizing',\n      label: 'Finalizing',\n      status: 'pending',\n      description: 'Completing proposal generation'\n    }\n  ]);\n\n  const updateStepStatus = useCallback((stepId: string, status: GenerationStep['status']) => {\n    setGenerationSteps(prev => prev.map(step => \n      step.id === stepId ? { ...step, status } : step\n    ));\n  }, []);\n\n  const simulateProgressSteps = useCallback(async () => {\n    const steps = ['validation', 'processing', 'formatting', 'saving', 'finalizing'];\n    const totalSteps = steps.length;\n    \n    for (let i = 0; i < steps.length; i++) {\n      const stepId = steps[i];\n      \n      // Mark current step as active\n      updateStepStatus(stepId, 'active');\n      setCurrentProgress((i / totalSteps) * 80); // 80% of progress for steps\n      \n      // Simulate step duration\n      await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 400));\n      \n      // Mark step as completed\n      updateStepStatus(stepId, 'completed');\n    }\n    \n    setCurrentProgress(100);\n  }, [updateStepStatus]);\n\n  const handleGenerateWithProgress = useCallback(async () => {\n    if (isGenerating) return;\n    \n    setIsGenerating(true);\n    setCurrentProgress(0);\n    \n    // Reset all steps to pending\n    setGenerationSteps(prev => prev.map(step => ({ ...step, status: 'pending' as const })));\n    \n    try {\n      // Start progress simulation\n      const progressPromise = simulateProgressSteps();\n      \n      // Actually generate the proposal\n      const proposalId = await generateProposal();\n      \n      // Wait for progress to complete\n      await progressPromise;\n      \n      // Small delay for final step\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      toast({\n        title: \"Proposal Generated Successfully\",\n        description: \"Your proposal has been created and is ready to view\",\n      });\n      \n      // Navigate to proposal\n      navigate(`/proposals/${proposalId}`);\n      \n    } catch (error) {\n      console.error('Error generating proposal:', error);\n      \n      // Mark current active step as error\n      setGenerationSteps(prev => prev.map(step => \n        step.status === 'active' ? { ...step, status: 'error' } : step\n      ));\n      \n      toast({\n        title: \"Generation Failed\",\n        description: \"There was an error generating your proposal. Please try again.\",\n        variant: \"destructive\"\n      });\n    } finally {\n      setIsGenerating(false);\n    }\n  }, [isGenerating, generateProposal, simulateProgressSteps, navigate, toast]);\n\n  const resetGeneration = useCallback(() => {\n    setIsGenerating(false);\n    setCurrentProgress(0);\n    setGenerationSteps(prev => prev.map(step => ({ ...step, status: 'pending' })));\n  }, []);\n\n  return {\n    isGenerating,\n    currentProgress,\n    generationSteps,\n    handleGenerateWithProgress,\n    resetGeneration\n  };\n};","\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface AutoSaveOptions {\n  key: string;\n  data: any;\n  interval?: number;\n  onSave?: (data: any) => void;\n  onRestore?: (data: any) => void;\n}\n\nexport const useAutoSave = ({\n  key,\n  data,\n  interval = 30000, // 30 seconds\n  onSave,\n  onRestore\n}: AutoSaveOptions) => {\n  const [lastSaved, setLastSaved] = useState<Date | null>(null);\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const [isSaving, setIsSaving] = useState(false);\n  const intervalRef = useRef<NodeJS.Timeout>();\n  const { toast } = useToast();\n\n  // Monitor online status\n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\n  // Auto-save function\n  const saveData = useCallback(async () => {\n    try {\n      setIsSaving(true);\n      const saveData = {\n        data,\n        timestamp: new Date().toISOString(),\n        version: Date.now()\n      };\n\n      localStorage.setItem(`autosave_${key}`, JSON.stringify(saveData));\n      \n      if (onSave) {\n        await onSave(data);\n      }\n\n      setLastSaved(new Date());\n      \n      if (isOnline) {\n        console.log('Auto-saved to localStorage and cloud');\n      } else {\n        console.log('Auto-saved to localStorage (offline)');\n      }\n    } catch (error) {\n      console.error('Auto-save failed:', error);\n      toast({\n        title: \"Auto-save failed\",\n        description: \"Your work may not be saved. Please save manually.\",\n        variant: \"destructive\"\n      });\n    } finally {\n      setIsSaving(false);\n    }\n  }, [key, data, onSave, isOnline, toast]);\n\n  // Restore saved data\n  const restoreData = useCallback(() => {\n    try {\n      const saved = localStorage.getItem(`autosave_${key}`);\n      if (saved) {\n        const parsedData = JSON.parse(saved);\n        if (onRestore) {\n          onRestore(parsedData.data);\n        }\n        setLastSaved(new Date(parsedData.timestamp));\n        return parsedData.data;\n      }\n    } catch (error) {\n      console.error('Failed to restore auto-saved data:', error);\n    }\n    return null;\n  }, [key, onRestore]);\n\n  // Clear auto-save data\n  const clearAutoSave = useCallback(() => {\n    localStorage.removeItem(`autosave_${key}`);\n    setLastSaved(null);\n  }, [key]);\n\n  // Set up auto-save interval\n  useEffect(() => {\n    if (data && Object.keys(data).length > 0) {\n      intervalRef.current = setInterval(saveData, interval);\n    }\n\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, [saveData, interval, data]);\n\n  // Manual save\n  const manualSave = useCallback(() => {\n    saveData();\n  }, [saveData]);\n\n  return {\n    lastSaved,\n    isOnline,\n    isSaving,\n    manualSave,\n    restoreData,\n    clearAutoSave\n  };\n};\n","import { useState, useEffect } from 'react';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { supabase } from '@/lib/supabaseClient';\nimport { useToast } from '@/hooks/use-toast';\n\nconst ALLOWED_ROLES = ['super_admin', 'manager'];\n// Allow a safe dev bypass so the App Settings UI can be tested locally\nconst DEV_BYPASS = (import.meta.env.MODE === 'development') && (import.meta.env.VITE_APPSETTINGS_DEV_BYPASS !== 'false');\n\nexport const useAppSettingsAccess = () => {\n  const [hasAccess, setHasAccess] = useState<boolean>(false);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [userRole, setUserRole] = useState<string | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const { user } = useAuth();\n  const { toast } = useToast();\n\n  useEffect(() => {\n    const checkAccess = async () => {\n      if (!user) {\n        if (DEV_BYPASS) {\n          setHasAccess(true);\n          setUserRole('dev_bypass');\n        } else {\n          setHasAccess(false);\n          setUserRole(null);\n        }\n        setIsLoading(false);\n        return;\n      }\n\n      try {\n        setError(null);\n        let role: string | null = null;\n\n        // Use the get_current_user_role function to get the user's role\n        const { data: roleData, error: roleError } = await supabase\n          .rpc('get_current_user_role');\n\n        if (!roleError && roleData) {\n          role = roleData;\n        } else {\n          // Fallback to profiles table if the function fails\n          const { data: profileData, error: profileError } = await supabase\n            .from('profiles')\n            .select('role')\n            .eq('id', user.id)\n            .single();\n\n          if (!profileError && profileData?.role) {\n            role = profileData.role;\n          } else {\n            setHasAccess(false);\n            setUserRole(null);\n            setError('Unable to verify user permissions');\n            setIsLoading(false);\n            return;\n          }\n        }\n\n        setUserRole(role);\n\n        // Check if user has required role\n        const hasRequiredRole = role && ALLOWED_ROLES.includes(role);\n        setHasAccess(!!hasRequiredRole);\n\n        if (!hasRequiredRole && !DEV_BYPASS) {\n          setError(`Access denied. Required roles: ${ALLOWED_ROLES.join(', ')}. Your role: ${role || 'None'}`);\n          toast({\n            title: \"Access Denied\",\n            description: \"You don't have permission to access App Settings. Only Super Admin and Manager roles are allowed.\",\n            variant: \"destructive\",\n          });\n        }\n        // In dev bypass mode, allow access even if role isn't one of the allowed roles\n        setHasAccess(hasRequiredRole || DEV_BYPASS);\n\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n        console.error('Error checking app settings access:', err);\n        setHasAccess(false);\n        setUserRole(null);\n        setError(errorMessage);\n        \n        toast({\n          title: \"Access Check Failed\",\n          description: errorMessage,\n          variant: \"destructive\",\n        });\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    checkAccess();\n\n    // Listen for auth state changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {\n      if (event === 'SIGNED_IN' || event === 'SIGNED_OUT' || event === 'TOKEN_REFRESHED') {\n        checkAccess();\n      }\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [user, toast]);\n\n  return {\n    hasAccess,\n    isLoading,\n    userRole,\n    error,\n  };\n};","\nimport { useState, useEffect } from 'react';\nimport { translateText, detectLanguage, fallbackTranslate } from '@/services/translationService';\nimport { Language } from '@/contexts/AppContext';\n\ntype TranslationState = {\n  translatedText: string;\n  detectedSourceLanguage: string;\n  isLoading: boolean;\n  error: string | null;\n};\n\n/**\n * Custom hook for text translation\n */\nexport const useTranslation = () => {\n  const [state, setState] = useState<TranslationState>({\n    translatedText: '',\n    detectedSourceLanguage: 'en',\n    isLoading: false,\n    error: null\n  });\n  \n  // Function to translate text\n  const translate = async (\n    text: string,\n    targetLanguage: Language,\n    sourceLanguage: string = 'auto'\n  ) => {\n    if (!text.trim()) {\n      setState(prev => ({\n        ...prev,\n        translatedText: '',\n        isLoading: false,\n        error: null\n      }));\n      return;\n    }\n    \n    setState(prev => ({ ...prev, isLoading: true, error: null }));\n    \n    try {\n      // Detect language if source is 'auto'\n      let sourceLang = sourceLanguage;\n      if (sourceLang === 'auto') {\n        sourceLang = await detectLanguage(text);\n        setState(prev => ({ ...prev, detectedSourceLanguage: sourceLang }));\n      }\n      \n      // Don't translate if source and target are the same\n      if (sourceLang === targetLanguage) {\n        setState(prev => ({\n          ...prev,\n          translatedText: text,\n          isLoading: false\n        }));\n        return;\n      }\n      \n      // Try API translation\n      try {\n        const result = await translateText(text, targetLanguage, sourceLang);\n        setState(prev => ({\n          ...prev,\n          translatedText: result,\n          isLoading: false\n        }));\n      } catch (apiError) {\n        // Fallback to dictionary translation if API fails\n        console.warn('API translation failed, using fallback:', apiError);\n        const fallbackResult = fallbackTranslate(text, targetLanguage);\n        setState(prev => ({\n          ...prev,\n          translatedText: fallbackResult,\n          isLoading: false,\n          error: 'API translation failed, using basic translation dictionary.'\n        }));\n      }\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: error instanceof Error ? error.message : 'Unknown translation error'\n      }));\n    }\n  };\n  \n  // Clear translation data\n  const clearTranslation = () => {\n    setState({\n      translatedText: '',\n      detectedSourceLanguage: 'en',\n      isLoading: false,\n      error: null\n    });\n  };\n  \n  return {\n    ...state,\n    translate,\n    clearTranslation\n  };\n};\n","\nimport { useState, useEffect } from 'react';\nimport { EnhancedPricingService } from '@/services/enhancedPricingService';\nimport { PricingService } from '@/services/pricingService';\nimport { CountryCurrencyService } from '@/services/countryCurrencyService';\n\nexport interface CurrencyInfo {\n  code: string;\n  symbol: string;\n  name: string;\n}\n\nexport const useCurrency = () => {\n  const [defaultCurrency, setDefaultCurrency] = useState<CurrencyInfo>({\n    code: 'THB',\n    symbol: '',\n    name: 'Thai Baht'\n  });\n\n  useEffect(() => {\n    const enhancedSettings = EnhancedPricingService.getEnhancedSettings();\n    const baseCurrency = enhancedSettings.currencyConversion.baseCurrency;\n    \n    // Get country info for the base currency using centralized service\n    const availableCountries = CountryCurrencyService.getAllCountriesWithCurrency();\n    const defaultCountry = availableCountries.find(c => c.countryCode === enhancedSettings.defaultCountry);\n    \n    if (defaultCountry) {\n      const effectiveCurrency = defaultCountry.pricingCurrency || defaultCountry.currency;\n      const effectiveSymbol = defaultCountry.pricingCurrencySymbol || defaultCountry.currencySymbol;\n      \n      setDefaultCurrency({\n        code: effectiveCurrency,\n        symbol: effectiveSymbol,\n        name: `${defaultCountry.countryName} ${effectiveCurrency}`\n      });\n      \n      console.log('useCurrency: Updated default currency from countries module:', {\n        code: effectiveCurrency,\n        symbol: effectiveSymbol,\n        country: defaultCountry.countryName\n      });\n    }\n  }, []);\n\n  const formatCurrency = (amount: number, currency?: string, symbol?: string): string => {\n    const currencyCode = currency || defaultCurrency.code;\n    const currencySymbol = symbol || defaultCurrency.symbol;\n    \n    // Format with proper currency symbol\n    return `${currencySymbol}${amount.toLocaleString('en-US', {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2\n    })}`;\n  };\n\n  const convertCurrency = (amount: number, fromCurrency: string, toCurrency?: string): number => {\n    const targetCurrency = toCurrency || defaultCurrency.code;\n    return PricingService.convertCurrency(amount, fromCurrency, targetCurrency);\n  };\n\n  const getCurrencyByCountryCode = (countryCode: string): CurrencyInfo => {\n    const currency = CountryCurrencyService.getCurrencyByCountryCode(countryCode);\n    const availableCountries = CountryCurrencyService.getAllCountriesWithCurrency();\n    const country = availableCountries.find(c => c.countryCode === countryCode);\n    \n    return {\n      code: currency.code,\n      symbol: currency.symbol,\n      name: country ? `${country.countryName} ${currency.code}` : currency.code\n    };\n  };\n\n  const getCurrencyByCountryName = (countryName: string): CurrencyInfo => {\n    const currency = CountryCurrencyService.getCurrencyByCountryName(countryName);\n    \n    return {\n      code: currency.code,\n      symbol: currency.symbol,\n      name: `${countryName} ${currency.code}`\n    };\n  };\n\n  return {\n    defaultCurrency,\n    formatCurrency,\n    convertCurrency,\n    getCurrencyByCountryCode,\n    getCurrencyByCountryName,\n    setDefaultCurrency\n  };\n};\n","import { useState, useEffect, useCallback } from 'react';\nimport { \n  ComprehensiveTransportService,\n  type CompleteTransportRoute,\n  type TransportRouteFormData,\n  type TransportType\n} from '@/services/comprehensiveTransportService';\n\ninterface UseTransportRoutesOptions {\n  autoFetch?: boolean;\n  filters?: {\n    country?: string;\n    transfer_type?: string;\n    status?: string;\n    enable_sightseeing?: boolean;\n  };\n}\n\nexport const useComprehensiveTransportRoutes = (options: UseTransportRoutesOptions = {}) => {\n  const { autoFetch = true, filters } = options;\n\n  // State management\n  const [routes, setRoutes] = useState<CompleteTransportRoute[]>([]);\n  const [transportTypes, setTransportTypes] = useState<TransportType[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [statistics, setStatistics] = useState<{\n    totalRoutes: number;\n    routesByTransferType: Record<string, number>;\n    routesByCountry: Record<string, number>;\n    routesWithSightseeing: number;\n    routesWithIntermediateStops: number;\n  } | null>(null);\n\n  // Fetch all routes\n  const fetchRoutes = useCallback(async () => {\n    const abortController = new AbortController();\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await ComprehensiveTransportService.getCompleteRoutes({ filters });\n      \n      // Only update state if request wasn't aborted\n      if (!abortController.signal.aborted) {\n        if (result.success && result.data) {\n          setRoutes(result.data.data);\n        } else {\n          setError(result.error || 'Failed to fetch routes');\n        }\n      }\n    } catch (err) {\n      if (!abortController.signal.aborted) {\n        setError(err instanceof Error ? err.message : 'Unknown error occurred');\n      }\n    } finally {\n      if (!abortController.signal.aborted) {\n        setLoading(false);\n      }\n    }\n    \n    // Cleanup function\n    return () => {\n      abortController.abort();\n    };\n  }, [filters]);\n\n  // Fetch transport types\n  const fetchTransportTypes = useCallback(async () => {\n    const abortController = new AbortController();\n    \n    try {\n      const result = await ComprehensiveTransportService.getTransportTypes();\n      \n      // Only update state if request wasn't aborted\n      if (!abortController.signal.aborted && result.success && result.data) {\n        setTransportTypes(result.data);\n      }\n    } catch (err) {\n      if (!abortController.signal.aborted) {\n        console.error('Failed to fetch transport types:', err);\n      }\n    }\n    \n    // Cleanup function\n    return () => {\n      abortController.abort();\n    };\n  }, []);\n\n  // Fetch statistics\n  const fetchStatistics = useCallback(async () => {\n    const abortController = new AbortController();\n    \n    try {\n      const result = await ComprehensiveTransportService.getRouteStatistics();\n      \n      // Only update state if request wasn't aborted\n      if (!abortController.signal.aborted && result.success && result.data) {\n        setStatistics(result.data);\n      }\n    } catch (err) {\n      if (!abortController.signal.aborted) {\n        console.error('Failed to fetch statistics:', err);\n      }\n    }\n    \n    // Cleanup function\n    return () => {\n      abortController.abort();\n    };\n  }, []);\n\n  // Create a new route\n  const createRoute = useCallback(async (formData: TransportRouteFormData) => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      // Validate data first\n      const validation = await ComprehensiveTransportService.validateRouteData(formData);\n      if (!validation.isValid) {\n        setError(validation.errors.join(', '));\n        setLoading(false);\n        return { success: false, error: validation.errors.join(', ') };\n      }\n\n      const result = await ComprehensiveTransportService.createCompleteRoute(formData);\n      \n      if (result.success && result.data) {\n        // Add the new route to the current list\n        setRoutes(prev => [result.data!, ...prev]);\n        // Refresh statistics\n        fetchStatistics();\n        return { success: true, data: result.data };\n      } else {\n        setError(result.error || 'Failed to create route');\n        return { success: false, error: result.error };\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      setError(errorMessage);\n      return { success: false, error: errorMessage };\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchStatistics]);\n\n  // Update an existing route\n  const updateRoute = useCallback(async (routeId: string, formData: Partial<TransportRouteFormData>) => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await ComprehensiveTransportService.updateCompleteRoute(routeId, formData);\n      \n      if (result.success && result.data) {\n        // Update the route in the current list\n        setRoutes(prev => prev.map(route => \n          route.id === routeId ? result.data! : route\n        ));\n        // Refresh statistics\n        fetchStatistics();\n        return { success: true, data: result.data };\n      } else {\n        setError(result.error || 'Failed to update route');\n        return { success: false, error: result.error };\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      setError(errorMessage);\n      return { success: false, error: errorMessage };\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchStatistics]);\n\n  // Delete a route\n  const deleteRoute = useCallback(async (routeId: string) => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await ComprehensiveTransportService.deleteCompleteRoute(routeId);\n      \n      if (result.success) {\n        // Remove the route from the current list\n        setRoutes(prev => prev.filter(route => route.id !== routeId));\n        // Refresh statistics\n        fetchStatistics();\n        return { success: true };\n      } else {\n        setError(result.error || 'Failed to delete route');\n        return { success: false, error: result.error };\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      setError(errorMessage);\n      return { success: false, error: errorMessage };\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchStatistics]);\n\n  // Get a single route\n  const getRoute = useCallback(async (routeId: string) => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await ComprehensiveTransportService.getCompleteRoute(routeId);\n      \n      if (result.success && result.data) {\n        return { success: true, data: result.data };\n      } else {\n        setError(result.error || 'Failed to fetch route');\n        return { success: false, error: result.error };\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      setError(errorMessage);\n      return { success: false, error: errorMessage };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Manage intermediate stops for a route\n  const manageIntermediateStops = useCallback(async (\n    routeId: string, \n    stops: Parameters<typeof ComprehensiveTransportService.manageIntermediateStops>[1]\n  ) => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await ComprehensiveTransportService.manageIntermediateStops(routeId, stops);\n      \n      if (result.success) {\n        // Update the route in the current list with new stops\n        setRoutes(prev => prev.map(route => \n          route.id === routeId \n            ? { ...route, intermediate_stops: result.data || [] }\n            : route\n        ));\n        return { success: true, data: result.data };\n      } else {\n        setError(result.error || 'Failed to manage intermediate stops');\n        return { success: false, error: result.error };\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      setError(errorMessage);\n      return { success: false, error: errorMessage };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Manage sightseeing options for a route\n  const manageSightseeingOptions = useCallback(async (\n    routeId: string, \n    options: Parameters<typeof ComprehensiveTransportService.manageSightseeingOptions>[1]\n  ) => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await ComprehensiveTransportService.manageSightseeingOptions(routeId, options);\n      \n      if (result.success) {\n        // Update the route in the current list with new options\n        setRoutes(prev => prev.map(route => \n          route.id === routeId \n            ? { ...route, sightseeing_options: result.data || [] }\n            : route\n        ));\n        return { success: true, data: result.data };\n      } else {\n        setError(result.error || 'Failed to manage sightseeing options');\n        return { success: false, error: result.error };\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      setError(errorMessage);\n      return { success: false, error: errorMessage };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Refresh all data\n  const refresh = useCallback(async () => {\n    await Promise.all([\n      fetchRoutes(),\n      fetchTransportTypes(),\n      fetchStatistics(),\n    ]);\n  }, [fetchRoutes, fetchTransportTypes, fetchStatistics]);\n\n  // Auto-fetch on mount and when filters change\n  useEffect(() => {\n    if (autoFetch) {\n      refresh();\n    }\n    \n    // Cleanup function to cancel any pending requests when component unmounts\n    return () => {\n      // The abort controllers in individual fetch functions will handle request cancellation\n    };\n  }, [autoFetch, refresh]);\n\n  // Helper functions\n  const getRoutesByCountry = useCallback((country: string) => {\n    return routes.filter(route => route.country === country);\n  }, [routes]);\n\n  const getRoutesByTransferType = useCallback((transferType: string) => {\n    return routes.filter(route => route.transfer_type === transferType);\n  }, [routes]);\n\n  const getRoutesWithSightseeing = useCallback(() => {\n    return routes.filter(route => route.enable_sightseeing);\n  }, [routes]);\n\n  const getRoutesWithIntermediateStops = useCallback(() => {\n    return routes.filter(route => \n      route.intermediate_stops && route.intermediate_stops.length > 0\n    );\n  }, [routes]);\n\n  const validateRouteData = useCallback((formData: TransportRouteFormData) => {\n    return ComprehensiveTransportService.validateRouteData(formData);\n  }, []);\n\n  return {\n    // Data\n    routes,\n    transportTypes,\n    statistics,\n    \n    // State\n    loading,\n    error,\n    \n    // Actions\n    createRoute,\n    updateRoute,\n    deleteRoute,\n    getRoute,\n    manageIntermediateStops,\n    manageSightseeingOptions,\n    refresh,\n    \n    // Helpers\n    getRoutesByCountry,\n    getRoutesByTransferType,\n    getRoutesWithSightseeing,\n    getRoutesWithIntermediateStops,\n    validateRouteData,\n    \n    // Utils\n    clearError: () => setError(null),\n  };\n};\n\n// Specialized hooks for specific use cases\nexport const useTransportRoute = (routeId: string) => {\n  const [route, setRoute] = useState<CompleteTransportRoute | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchRoute = useCallback(async () => {\n    if (!routeId) return;\n    \n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await ComprehensiveTransportService.getCompleteRoute(routeId);\n      \n      if (result.success && result.data) {\n        setRoute(result.data);\n      } else {\n        setError(result.error || 'Failed to fetch route');\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error occurred');\n    } finally {\n      setLoading(false);\n    }\n  }, [routeId]);\n\n  useEffect(() => {\n    fetchRoute();\n  }, [fetchRoute]);\n\n  return {\n    route,\n    loading,\n    error,\n    refresh: fetchRoute,\n    clearError: () => setError(null),\n  };\n};\n\nexport const useTransportTypes = () => {\n  const [transportTypes, setTransportTypes] = useState<TransportType[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchTransportTypes = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await ComprehensiveTransportService.getTransportTypes();\n      \n      if (result.success && result.data) {\n        setTransportTypes(result.data);\n      } else {\n        setError(result.error || 'Failed to fetch transport types');\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error occurred');\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    fetchTransportTypes();\n  }, [fetchTransportTypes]);\n\n  return {\n    transportTypes,\n    loading,\n    error,\n    refresh: fetchTransportTypes,\n    clearError: () => setError(null),\n  };\n};","import { useState, useEffect } from 'react';\nimport { CountriesService, CountryRow } from '@/services/countriesService';\nimport { useToast } from '@/hooks/use-toast';\nimport { supabase } from '@/lib/supabaseClient';\nimport { Country } from '@/pages/inventory/countries/types/country';\n\nexport interface CurrencyOption {\n  code: string;\n  name: string;\n  symbol: string;\n}\n\ninterface UseRealTimeCountriesReturn {\n  countries: Country[];\n  activeCountries: Country[];\n  popularCountries: Country[];\n  currencies: CurrencyOption[];\n  loading: boolean;\n  error: string | null;\n  refreshCountries: () => Promise<void>;\n  updateCountryCurrency: (countryId: string, currency: string, symbol: string) => Promise<boolean>;\n  overridePricingCurrency: (countryId: string, currency: string, symbol: string) => Promise<boolean>;\n}\n\n// Map Supabase country row to frontend Country interface\nconst mapCountryRow = (row: CountryRow): Country => ({\n  id: row.id,\n  name: row.name,\n  code: row.code,\n  region: row.region,\n  continent: row.continent,\n  currency: row.currency,\n  currency_symbol: row.currency_symbol,\n  status: row.status,\n  flag_url: row.flag_url || null,\n  is_popular: row.is_popular || false,\n  visa_required: row.visa_required || false,\n  languages: Array.isArray(row.languages) ? row.languages : [],\n  pricing_currency_override: row.pricing_currency_override || false,\n  pricing_currency: row.pricing_currency || null,\n  pricing_currency_symbol: row.pricing_currency_symbol || null,\n  created_at: row.created_at || new Date().toISOString(),\n  updated_at: row.updated_at || new Date().toISOString(),\n});\n\nexport const useRealTimeCountries = (): UseRealTimeCountriesReturn => {\n  const [countries, setCountries] = useState<Country[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const { toast } = useToast();\n\n  const fetchCountries = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const response = await CountriesService.getAllCountries();\n      \n      if (response.success && response.data) {\n        const mappedCountries = response.data.map(mapCountryRow);\n        setCountries(mappedCountries);\n      } else {\n        setError(response.error || 'Failed to fetch countries');\n        console.error('Error fetching countries:', response.error);\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      setError(errorMessage);\n      console.error('Unexpected error fetching countries:', err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const refreshCountries = async () => {\n    await fetchCountries();\n  };\n\n  const updateCountryCurrency = async (countryId: string, currency: string, symbol: string): Promise<boolean> => {\n    try {\n      const response = await CountriesService.updateCountry(countryId, {\n        currency,\n        currency_symbol: symbol,\n        updated_at: new Date().toISOString(),\n      });\n\n      if (response.success) {\n        // Update local state\n        setCountries(prev => prev.map(country => \n          country.id === countryId \n            ? { ...country, currency, currency_symbol: symbol }\n            : country\n        ));\n        \n        toast({\n          title: \"Currency Updated\",\n          description: `Country currency updated to ${currency} (${symbol})`,\n        });\n        \n        return true;\n      } else {\n        toast({\n          title: \"Update Failed\",\n          description: response.error || \"Failed to update currency\",\n          variant: \"destructive\",\n        });\n        return false;\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      toast({\n        title: \"Update Failed\",\n        description: errorMessage,\n        variant: \"destructive\",\n      });\n      return false;\n    }\n  };\n\n  const overridePricingCurrency = async (countryId: string, currency: string, symbol: string): Promise<boolean> => {\n    try {\n      const response = await CountriesService.updateCountry(countryId, {\n        pricing_currency_override: true,\n        pricing_currency: currency,\n        pricing_currency_symbol: symbol,\n        updated_at: new Date().toISOString(),\n      });\n\n      if (response.success) {\n        // Update local state\n        setCountries(prev => prev.map(country => \n          country.id === countryId \n            ? { \n                ...country, \n                pricing_currency_override: true,\n                pricing_currency: currency,\n                pricing_currency_symbol: symbol\n              }\n            : country\n        ));\n        \n        toast({\n          title: \"Pricing Currency Override Set\",\n          description: `Pricing currency override set to ${currency} (${symbol})`,\n        });\n        \n        return true;\n      } else {\n        toast({\n          title: \"Override Failed\",\n          description: response.error || \"Failed to set pricing currency override\",\n          variant: \"destructive\",\n        });\n        return false;\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      toast({\n        title: \"Override Failed\",\n        description: errorMessage,\n        variant: \"destructive\",\n      });\n      return false;\n    }\n  };\n\n  // Derived data\n  const activeCountries = countries.filter(country => country.status === 'active');\n  const popularCountries = countries.filter(country => country.is_popular && country.status === 'active');\n  \n  // Extract unique currencies from countries\n  const currencies: CurrencyOption[] = Array.from(\n    new Map(\n      countries.map(country => [\n        country.currency,\n        {\n          code: country.currency,\n          name: country.currency, // You might want to add full currency names to the database\n          symbol: country.currency_symbol,\n        }\n      ])\n    ).values()\n  );\n\n  useEffect(() => {\n    fetchCountries();\n\n    // Set up real-time subscription for countries table\n    const subscription = supabase\n      .channel('countries-changes')\n      .on(\n        'postgres_changes',\n        {\n          event: '*', // Listen to all events (INSERT, UPDATE, DELETE)\n          schema: 'public',\n          table: 'countries'\n        },\n        (payload) => {\n          console.log('Real-time countries update:', payload);\n          \n          if (payload.eventType === 'INSERT' && payload.new) {\n            // Add new country\n            const newCountry = mapCountryRow(payload.new as CountryRow);\n            setCountries(prev => [...prev, newCountry]);\n            \n            // Note: Toast messages for new countries are handled by useCountryActions\n            // to prevent duplicate notifications\n          } else if (payload.eventType === 'UPDATE' && payload.new) {\n            // Update existing country\n            const updatedCountry = mapCountryRow(payload.new as CountryRow);\n            setCountries(prev => prev.map(country => \n              country.id === updatedCountry.id ? updatedCountry : country\n            ));\n            \n            // Note: Toast messages for status changes are handled by useCountryActions\n            // to prevent duplicate notifications\n          } else if (payload.eventType === 'DELETE' && payload.old) {\n            // Remove deleted country\n            setCountries(prev => prev.filter(country => country.id !== payload.old.id));\n            \n            // Note: Toast messages for deleted countries are handled by useCountryActions\n            // to prevent duplicate notifications\n          }\n        }\n      )\n      .subscribe();\n\n    // Cleanup subscription on unmount\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [toast]);\n\n  return {\n    countries,\n    activeCountries,\n    popularCountries,\n    currencies,\n    loading,\n    error,\n    refreshCountries,\n    updateCountryCurrency,\n    overridePricingCurrency,\n  };\n};\n\n// Export common currencies for backward compatibility\nexport const commonCurrencies: CurrencyOption[] = [\n  { code: 'USD', name: 'US Dollar', symbol: '$' },\n  { code: 'EUR', name: 'Euro', symbol: '' },\n  { code: 'GBP', name: 'British Pound', symbol: '' },\n  { code: 'JPY', name: 'Japanese Yen', symbol: '' },\n  { code: 'CAD', name: 'Canadian Dollar', symbol: 'C$' },\n  { code: 'AUD', name: 'Australian Dollar', symbol: 'A$' },\n  { code: 'CHF', name: 'Swiss Franc', symbol: 'CHF' },\n  { code: 'CNY', name: 'Chinese Yuan', symbol: '' },\n  { code: 'INR', name: 'Indian Rupee', symbol: '' },\n  { code: 'AED', name: 'UAE Dirham', symbol: '.' },\n  { code: 'SGD', name: 'Singapore Dollar', symbol: 'S$' },\n  { code: 'THB', name: 'Thai Baht', symbol: '' },\n];","import { useState, useCallback } from 'react';\n\nexport interface CityAllocation {\n  cityId: string;\n  allocation: number;\n}\n\nexport interface UseOptionalCitiesReturn {\n  cityAllocations: CityAllocation[];\n  onCityAllocationsChange: (allocations: CityAllocation[]) => void;\n  isOptionalEnabled: boolean;\n  setOptionalEnabled: (enabled: boolean) => void;\n  getCityAllocation: (cityId: string) => number;\n  updateCityAllocation: (cityId: string, allocation: number) => void;\n}\n\nexport const useOptionalCities = (): UseOptionalCitiesReturn => {\n  const [cityAllocations, setCityAllocations] = useState<CityAllocation[]>([]);\n  const [isOptionalEnabled, setOptionalEnabled] = useState(false);\n\n  const onCityAllocationsChange = useCallback((allocations: CityAllocation[]) => {\n    setCityAllocations(allocations);\n  }, []);\n\n  const getCityAllocation = useCallback((cityId: string): number => {\n    const allocation = cityAllocations.find(alloc => alloc.cityId === cityId);\n    return allocation?.allocation || 0;\n  }, [cityAllocations]);\n\n  const updateCityAllocation = useCallback((cityId: string, allocation: number) => {\n    setCityAllocations(prev => {\n      const existingIndex = prev.findIndex(alloc => alloc.cityId === cityId);\n      if (existingIndex >= 0) {\n        const updated = [...prev];\n        updated[existingIndex] = { cityId, allocation };\n        return updated;\n      } else {\n        return [...prev, { cityId, allocation }];\n      }\n    });\n  }, []);\n\n  return {\n    cityAllocations,\n    onCityAllocationsChange,\n    isOptionalEnabled,\n    setOptionalEnabled,\n    getCityAllocation,\n    updateCityAllocation,\n  };\n};\n\nexport default useOptionalCities;","import { useState, useEffect, useCallback } from 'react';\nimport { \n  automatedProposalStatusService, \n  AutomatedProposalStatus, \n  ProposalTrackingData \n} from '@/services/automatedProposalStatusService';\nimport { useToast } from '@/hooks/use-toast';\n\nexport interface UseAutomatedProposalStatusReturn {\n  // Current status data\n  proposalStatus: AutomatedProposalStatus | null;\n  trackingData: ProposalTrackingData | null;\n  isLoading: boolean;\n  error: string | null;\n  \n  // Status transition functions\n  handleProposalCreated: (queryId: string, proposalId: string) => Promise<void>;\n  handleProposalSent: (proposalId: string, sendMethod: 'email' | 'whatsapp' | 'portal') => Promise<void>;\n  handleProposalViewed: (proposalId: string, clientId: string, viewSource: 'email' | 'portal') => Promise<void>;\n  handleClientFeedback: (proposalId: string, feedbackType: 'interested' | 'modification-requested' | 'negotiation' | 'rejection') => Promise<void>;\n  handlePaymentReceived: (proposalId: string, amount: number, paymentType: 'advance' | 'full') => Promise<void>;\n  \n  // Automated checks\n  checkFollowUpRequired: (proposalId: string) => Promise<boolean>;\n  getProposalsNeedingFollowUp: () => string[];\n  \n  // Statistics\n  getProposalStats: () => {\n    totalProposals: number;\n    statusDistribution: Record<AutomatedProposalStatus, number>;\n    averageTimeToView: number;\n    conversionRate: number;\n  };\n}\n\nexport const useAutomatedProposalStatus = (): UseAutomatedProposalStatusReturn => {\n  const [trackingData, setTrackingData] = useState<ProposalTrackingData | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const { toast } = useToast();\n\n  // Get current proposal status\n  const proposalStatus = trackingData?.currentStatus || null;\n\n  // Handle proposal creation with automated status transition\n  const handleProposalCreated = useCallback(async (queryId: string, proposalId: string) => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      await automatedProposalStatusService.handleProposalCreated(queryId, proposalId);\n      const newTrackingData = automatedProposalStatusService.getProposalTracking(proposalId);\n      setTrackingData(newTrackingData || null);\n      \n      toast({\n        title: 'Proposal Created',\n        description: 'Status automatically updated to \"Proposal in Draft\"',\n        variant: 'default'\n      });\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to create proposal tracking';\n      setError(errorMessage);\n      toast({\n        title: 'Error',\n        description: errorMessage,\n        variant: 'destructive'\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [toast]);\n\n  // Handle proposal sending\n  const handleProposalSent = useCallback(async (proposalId: string, sendMethod: 'email' | 'whatsapp' | 'portal') => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const success = await automatedProposalStatusService.handleProposalSent(proposalId, sendMethod);\n      if (success) {\n        const updatedTrackingData = automatedProposalStatusService.getProposalTracking(proposalId);\n        setTrackingData(updatedTrackingData || null);\n        \n        toast({\n          title: 'Proposal Sent',\n          description: `Status updated to \"Proposal Sent\" via ${sendMethod}`,\n          variant: 'default'\n        });\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to update proposal status';\n      setError(errorMessage);\n      toast({\n        title: 'Error',\n        description: errorMessage,\n        variant: 'destructive'\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [toast]);\n\n  // Handle proposal viewing\n  const handleProposalViewed = useCallback(async (proposalId: string, clientId: string, viewSource: 'email' | 'portal') => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const success = await automatedProposalStatusService.handleProposalViewed(proposalId, clientId, viewSource);\n      if (success) {\n        const updatedTrackingData = automatedProposalStatusService.getProposalTracking(proposalId);\n        setTrackingData(updatedTrackingData || null);\n        \n        toast({\n          title: 'Proposal Viewed',\n          description: `Client viewed proposal via ${viewSource}`,\n          variant: 'default'\n        });\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to update proposal status';\n      setError(errorMessage);\n      toast({\n        title: 'Error',\n        description: errorMessage,\n        variant: 'destructive'\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [toast]);\n\n  // Handle client feedback\n  const handleClientFeedback = useCallback(async (proposalId: string, feedbackType: 'interested' | 'modification-requested' | 'negotiation' | 'rejection') => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const success = await automatedProposalStatusService.handleClientFeedback(proposalId, feedbackType);\n      if (success) {\n        const updatedTrackingData = automatedProposalStatusService.getProposalTracking(proposalId);\n        setTrackingData(updatedTrackingData || null);\n        \n        const statusMap = {\n          'interested': 'Interested',\n          'modification-requested': 'Modification Requested',\n          'negotiation': 'Negotiation',\n          'rejection': 'Rejected'\n        };\n        \n        toast({\n          title: 'Client Feedback Received',\n          description: `Status updated to \"${statusMap[feedbackType]}\"`,\n          variant: feedbackType === 'rejection' ? 'destructive' : 'default'\n        });\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to update proposal status';\n      setError(errorMessage);\n      toast({\n        title: 'Error',\n        description: errorMessage,\n        variant: 'destructive'\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [toast]);\n\n  // Handle payment received\n  const handlePaymentReceived = useCallback(async (proposalId: string, amount: number, paymentType: 'advance' | 'full') => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const success = await automatedProposalStatusService.handlePaymentReceived(proposalId, amount, paymentType);\n      if (success) {\n        const updatedTrackingData = automatedProposalStatusService.getProposalTracking(proposalId);\n        setTrackingData(updatedTrackingData || null);\n        \n        const statusMap = {\n          'advance': 'Advance Received',\n          'full': 'Booking Confirmed'\n        };\n        \n        toast({\n          title: 'Payment Received',\n          description: `Status updated to \"${statusMap[paymentType]}\" - $${amount.toLocaleString()}`,\n          variant: 'success'\n        });\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to update payment status';\n      setError(errorMessage);\n      toast({\n        title: 'Error',\n        description: errorMessage,\n        variant: 'destructive'\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [toast]);\n\n  // Check if follow-up is required\n  const checkFollowUpRequired = useCallback(async (proposalId: string): Promise<boolean> => {\n    try {\n      return await automatedProposalStatusService.checkFollowUpRequired(proposalId);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to check follow-up status';\n      setError(errorMessage);\n      return false;\n    }\n  }, []);\n\n  // Get proposals needing follow-up\n  const getProposalsNeedingFollowUp = useCallback((): string[] => {\n    return automatedProposalStatusService.getProposalsNeedingFollowUp();\n  }, []);\n\n  // Get proposal statistics\n  const getProposalStats = useCallback(() => {\n    return automatedProposalStatusService.getProposalStats();\n  }, []);\n\n  // Load tracking data for a specific proposal\n  const loadProposalTracking = useCallback((proposalId: string) => {\n    const trackingData = automatedProposalStatusService.getProposalTracking(proposalId);\n    setTrackingData(trackingData || null);\n  }, []);\n\n  // Load tracking data for a specific query\n  const loadQueryTracking = useCallback((queryId: string) => {\n    const trackingData = automatedProposalStatusService.getTrackingByQueryId(queryId);\n    setTrackingData(trackingData || null);\n  }, []);\n\n  // Auto-refresh tracking data\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (trackingData?.proposalId) {\n        checkFollowUpRequired(trackingData.proposalId);\n      }\n    }, 30000); // Check every 30 seconds\n\n    return () => clearInterval(interval);\n  }, [trackingData?.proposalId, checkFollowUpRequired]);\n\n  return {\n    // Current status data\n    proposalStatus,\n    trackingData,\n    isLoading,\n    error,\n    \n    // Status transition functions\n    handleProposalCreated,\n    handleProposalSent,\n    handleProposalViewed,\n    handleClientFeedback,\n    handlePaymentReceived,\n    \n    // Automated checks\n    checkFollowUpRequired,\n    getProposalsNeedingFollowUp,\n    \n    // Statistics\n    getProposalStats,\n    \n    // Utility functions\n    loadProposalTracking,\n    loadQueryTracking\n  };\n};","\nimport { useState, useEffect } from 'react';\nimport { supabase, adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\nimport type { Tables } from '@/integrations/supabase/types';\n\nexport interface ReportingManager {\n  id: string;\n  name: string;\n  role: string;\n  department: string;\n}\n\nexport const useReportingManagers = (excludeId?: string) => {\n  const [reportingManagers, setReportingManagers] = useState<ReportingManager[]>([]);\n\n  useEffect(() => {\n    const loadReportingManagers = async () => {\n      try {\n        // Try fetching from Supabase with role filter\n        const { data, error } = await supabase\n          .from('profiles')\n          .select('id,name,role,department,status')\n          .in('role', ['staff', 'manager', 'super_admin']);\n\n        let rows: any[] = Array.isArray(data) ? data : [];\n\n        // Fallback to admin client if RLS blocks\n        if ((!rows || rows.length === 0) && (error || !data) && isAdminClientConfigured && adminSupabase) {\n          try {\n            const { data: adminData } = await (adminSupabase as any)\n              .from('profiles')\n              .select('id,name,role,department,status')\n              .in('role', ['staff', 'manager', 'super_admin']);\n            rows = Array.isArray(adminData) ? adminData : [];\n          } catch {}\n        }\n\n        const managers = (rows as Tables<'profiles'>[])\n          .filter((row) => {\n            // Exclude the provided ID if present\n            if (excludeId && row.id === excludeId) return false;\n            // Only include active profiles by default\n            const status = (row as any)?.status ?? 'active';\n            return String(status).toLowerCase() === 'active';\n          })\n          .map((row) => ({\n            id: row.id as string,\n            name: (row as any).name || 'Unknown',\n            role: (row as any).role || 'staff',\n            department: (row as any).department || ''\n          }))\n          // Remove duplicates based on ID (defensive)\n          .filter((manager, index, self) => index === self.findIndex(m => m.id === manager.id))\n          // Sort by name\n          .sort((a, b) => a.name.localeCompare(b.name));\n\n        setReportingManagers(managers);\n      } catch (err) {\n        console.warn('Failed to load reporting managers from Supabase', err);\n        setReportingManagers([]);\n      }\n    };\n\n    loadReportingManagers();\n  }, [excludeId]);\n\n  return reportingManagers;\n};\n","import { useState, useEffect } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\n\nexport interface CountryCurrency {\n  currency: string;\n  currency_symbol: string;\n  pricing_currency: string;\n  pricing_currency_symbol: string;\n  pricing_currency_override: boolean;\n}\n\nexport interface CurrencyInfo {\n  currency: string;\n  symbol: string;\n  displayText: string; // e.g., \"USD ($)\"\n}\n\nexport const useSightseeingCurrency = (countryName?: string) => {\n  const [currencyInfo, setCurrencyInfo] = useState<CurrencyInfo | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchCurrencyData = async (country: string) => {\n    if (!country) {\n      setCurrencyInfo(null);\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const { data, error: fetchError } = await supabase\n        .from('countries')\n        .select('currency, currency_symbol, pricing_currency, pricing_currency_symbol, pricing_currency_override')\n        .eq('name', country)\n        .eq('status', 'active')\n        .single();\n\n      if (fetchError) {\n        console.error('Error fetching country currency:', fetchError);\n        setError(`Failed to fetch currency data for ${country}`);\n        setCurrencyInfo(null);\n        return;\n      }\n\n      if (data) {\n        const countryCurrency = data as CountryCurrency;\n        \n        // Determine which currency to use based on pricing_currency_override\n        const currency = countryCurrency.pricing_currency_override \n          ? countryCurrency.pricing_currency \n          : countryCurrency.currency;\n          \n        const symbol = countryCurrency.pricing_currency_override \n          ? countryCurrency.pricing_currency_symbol \n          : countryCurrency.currency_symbol;\n\n        const currencyInfo: CurrencyInfo = {\n          currency,\n          symbol,\n          displayText: `${currency} (${symbol})`\n        };\n\n        setCurrencyInfo(currencyInfo);\n      } else {\n        setError(`No currency data found for ${country}`);\n        setCurrencyInfo(null);\n      }\n    } catch (err) {\n      console.error('Error in fetchCurrencyData:', err);\n      setError('An unexpected error occurred while fetching currency data');\n      setCurrencyInfo(null);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    if (countryName) {\n      fetchCurrencyData(countryName);\n    } else {\n      setCurrencyInfo(null);\n      setError(null);\n    }\n  }, [countryName]);\n\n  return {\n    currencyInfo,\n    loading,\n    error,\n    refetch: () => countryName && fetchCurrencyData(countryName)\n  };\n};","import { useMemo } from 'react';\nimport { \n  mockTravelerTrips, \n  mockTripActivities, \n  mockTravelerNotifications,\n  getCurrentTrip,\n  getActivitiesForTrip,\n  getTodayActivities\n} from '@/data/mockTravelerData';\nimport { TravelerTrip, TripActivity, TravelerNotification, TodayActivity } from '@/types/travelerTypes';\n\nexport const useTravelerData = () => {\n  // Get current trip\n  const currentTrip = useMemo(() => getCurrentTrip(), []);\n  \n  // Get activities for current trip\n  const currentTripActivities = useMemo(() => {\n    if (!currentTrip) return [];\n    return getActivitiesForTrip(currentTrip.id);\n  }, [currentTrip]);\n\n  // Get today's activities\n  const todayActivities = useMemo(() => {\n    return getTodayActivities(currentTripActivities);\n  }, [currentTripActivities]);\n\n  // Get upcoming activities (next 3 days)\n  const upcomingActivities = useMemo(() => {\n    const today = new Date();\n    const threeDaysFromNow = new Date(today.getTime() + 3 * 24 * 60 * 60 * 1000);\n    \n    return currentTripActivities.filter(activity => {\n      const activityDate = new Date(activity.date);\n      return activityDate >= today && activityDate <= threeDaysFromNow;\n    }).sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\n  }, [currentTripActivities]);\n\n  // Get trip history (completed trips)\n  const tripHistory = useMemo(() => {\n    return mockTravelerTrips.filter(trip => trip.status === 'completed');\n  }, []);\n\n  // Get unread notifications count\n  const unreadNotificationsCount = useMemo(() => {\n    return mockTravelerNotifications.filter(notif => !notif.isRead).length;\n  }, []);\n\n  // Get notifications requiring action\n  const actionRequiredNotifications = useMemo(() => {\n    return mockTravelerNotifications.filter(notif => notif.actionRequired && !notif.isRead);\n  }, []);\n\n  // Get trip progress percentage\n  const tripProgress = useMemo(() => {\n    if (!currentTrip) return 0;\n    \n    const tripStart = new Date(currentTrip.startDate);\n    const tripEnd = new Date(currentTrip.endDate);\n    const now = new Date();\n    \n    if (now < tripStart) return 0;\n    if (now > tripEnd) return 100;\n    \n    const totalDuration = tripEnd.getTime() - tripStart.getTime();\n    const elapsed = now.getTime() - tripStart.getTime();\n    \n    return Math.round((elapsed / totalDuration) * 100);\n  }, [currentTrip]);\n\n  // Get completed activities count for current trip\n  const completedActivitiesCount = useMemo(() => {\n    return currentTripActivities.filter(activity => activity.status === 'completed').length;\n  }, [currentTripActivities]);\n\n  return {\n    currentTrip,\n    currentTripActivities,\n    todayActivities,\n    upcomingActivities,\n    tripHistory,\n    notifications: mockTravelerNotifications,\n    unreadNotificationsCount,\n    actionRequiredNotifications,\n    tripProgress,\n    completedActivitiesCount,\n    totalActivitiesCount: currentTripActivities.length,\n    isLoading: false\n  };\n};","\nimport { useState, useEffect } from 'react';\n\ninterface AutoAssignmentSettings {\n  enabled: boolean;\n  requireCountryMatch: boolean;\n  fallbackToAnyStaff: boolean;\n}\n\nconst DEFAULT_SETTINGS: AutoAssignmentSettings = {\n  enabled: true,\n  requireCountryMatch: true,\n  fallbackToAnyStaff: true,\n};\n\nexport const useAutoAssignmentSettings = () => {\n  const [settings, setSettings] = useState<AutoAssignmentSettings>(() => {\n    const saved = localStorage.getItem('autoAssignmentSettings');\n    return saved ? JSON.parse(saved) : DEFAULT_SETTINGS;\n  });\n\n  useEffect(() => {\n    localStorage.setItem('autoAssignmentSettings', JSON.stringify(settings));\n  }, [settings]);\n\n  const updateSettings = (newSettings: Partial<AutoAssignmentSettings>) => {\n    setSettings(prev => ({ ...prev, ...newSettings }));\n  };\n\n  const toggleAutoAssignment = () => {\n    setSettings(prev => ({ ...prev, enabled: !prev.enabled }));\n  };\n\n  return {\n    settings,\n    updateSettings,\n    toggleAutoAssignment,\n    isAutoAssignmentEnabled: settings.enabled,\n  };\n};\n","import { useState, useEffect, useMemo } from 'react';\nimport { Agent } from '@/types/agent';\nimport { useLocalAgentData } from '@/hooks/useLocalAgentData';\nimport { AgentApiService } from '@/services/agentApiService';\n\nexport const useEnhancedAgentData = (queryId?: string) => {\n  const { agents: localAgents, loading: localLoading } = useLocalAgentData();\n  const [apiAgents, setApiAgents] = useState<Agent[]>([]);\n  const [queryAgents, setQueryAgents] = useState<Agent[]>([]);\n  const [apiLoading, setApiLoading] = useState(false);\n  const [queryLoading, setQueryLoading] = useState(false);\n\n  // Load agents from API endpoint\n  useEffect(() => {\n    const loadApiAgents = async () => {\n      setApiLoading(true);\n      try {\n        const agents = await AgentApiService.fetchAgents();\n        setApiAgents(agents);\n      } catch (error) {\n        console.error('Error loading agents from API:', error);\n      } finally {\n        setApiLoading(false);\n      }\n    };\n\n    loadApiAgents();\n  }, []);\n\n  // Load agents from query data if editing a query\n  useEffect(() => {\n    if (queryId) {\n      setQueryLoading(true);\n      try {\n        // Load agents from the specific query's context\n        const savedQueries = localStorage.getItem('travel_queries');\n        if (savedQueries) {\n          const queries = JSON.parse(savedQueries);\n          const currentQuery = queries.find((q: any) => q.id === queryId);\n          \n          if (currentQuery && currentQuery.agentId && currentQuery.agentName) {\n            // Create an agent object from query data\n            const queryAgent: Agent = {\n              id: currentQuery.agentId,\n              name: currentQuery.agentName,\n              email: `${currentQuery.agentName.toLowerCase().replace(/\\s+/g, '.')}@query.local`,\n              country: 'Unknown',\n              city: 'Unknown',\n              type: 'individual',\n              status: 'active',\n              commissionType: 'percentage',\n              commissionValue: '10%',\n              contact: {\n                email: `${currentQuery.agentName.toLowerCase().replace(/\\s+/g, '.')}@query.local`,\n                phone: 'N/A'\n              },\n              joinDate: currentQuery.createdAt || new Date().toISOString(),\n              createdAt: currentQuery.createdAt || new Date().toISOString(),\n              stats: {\n                totalQueries: 0,\n                totalBookings: 0,\n                conversionRate: 0,\n                revenueGenerated: 0,\n                averageBookingValue: 0,\n                activeCustomers: 0\n              },\n              recentActivity: []\n            };\n            \n            setQueryAgents([queryAgent]);\n          }\n        }\n      } catch (error) {\n        console.error('Error loading agents from query data:', error);\n      } finally {\n        setQueryLoading(false);\n      }\n    }\n  }, [queryId]);\n\n  // Combine all agent sources with deduplication\n  const allAgents = useMemo(() => {\n    const agentMap = new Map<number, Agent>();\n    \n    // Add local agents first\n    localAgents.forEach(agent => {\n      agentMap.set(agent.id, agent);\n    });\n    \n    // Add API agents (may override local agents)\n    apiAgents.forEach(agent => {\n      agentMap.set(agent.id, agent);\n    });\n    \n    // Add query agents (prioritize query context)\n    queryAgents.forEach(agent => {\n      agentMap.set(agent.id, { ...agentMap.get(agent.id), ...agent });\n    });\n    \n    return Array.from(agentMap.values());\n  }, [localAgents, apiAgents, queryAgents]);\n\n  // Get active agents from the combined agent data\n  const activeAgents = useMemo(() => {\n    return allAgents.filter((agent: Agent) => agent.status === 'active');\n  }, [allAgents]);\n\n  // Get agents by country\n  const getAgentsByCountry = (country: string) => {\n    return activeAgents.filter((agent: Agent) => \n      agent.country.toLowerCase() === country.toLowerCase()\n    );\n  };\n\n  // Get agents by city\n  const getAgentsByCity = (city: string) => {\n    return activeAgents.filter((agent: Agent) => \n      agent.city.toLowerCase() === city.toLowerCase()\n    );\n  };\n\n  // Get agent by ID\n  const getAgentById = (agentId: number) => {\n    return allAgents.find((agent: Agent) => agent.id === agentId);\n  };\n\n  // Get high-performing agents (based on conversion rate)\n  const getHighPerformingAgents = () => {\n    return activeAgents.filter((agent: Agent) => \n      agent.stats.conversionRate > 15\n    ).sort((a, b) => b.stats.conversionRate - a.stats.conversionRate);\n  };\n\n  // Search agents across all sources\n  const searchAgents = async (searchTerm: string) => {\n    const localResults = activeAgents.filter(agent =>\n      agent.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      agent.email.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      agent.city.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      agent.country.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n\n    try {\n      const apiResults = await AgentApiService.searchAgents(searchTerm);\n      \n      // Combine and deduplicate results\n      const resultMap = new Map<number, Agent>();\n      localResults.forEach(agent => resultMap.set(agent.id, agent));\n      apiResults.forEach(agent => resultMap.set(agent.id, agent));\n      \n      return Array.from(resultMap.values());\n    } catch (error) {\n      console.error('Error searching agents:', error);\n      return localResults;\n    }\n  };\n\n  const loading = localLoading || apiLoading || queryLoading;\n\n  return {\n    activeAgents,\n    allAgents,\n    getAgentsByCountry,\n    getAgentsByCity,\n    getAgentById,\n    getHighPerformingAgents,\n    searchAgents,\n    totalActiveAgents: activeAgents.length,\n    totalAgents: allAgents.length,\n    loading,\n    sources: {\n      local: localAgents.length,\n      api: apiAgents.length,\n      query: queryAgents.length\n    }\n  };\n};"],"file":"app-hooks-V1qjbRh1.js"}