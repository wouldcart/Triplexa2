{"version":3,"mappings":"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","names":["circuitBreaker","STACK_DEPTH_ERROR_CODES","STACK_DEPTH_ERROR_PATTERNS","getCircuitBreakerKey","operation","category","settingKey","shouldAttemptOperation","key","state","isOpen","Date","now","lastFailureTime","recordSuccess","recordFailure","error","failureCount","errorCode","code","errorMessage","message","includes","some","pattern","test","isStackDepthError","SETTING_CATEGORIES","GENERAL","SEO","BRANDING","PERMISSIONS","AUTHENTICATION","NOTIFICATIONS","PAYMENT","INTEGRATIONS","MAINTENANCE","CONTENT","STORAGE_KEY","databaseAccessCache","accessible","lastChecked","cacheExpiry","AppSettingsService$1","isDatabaseAccessible","markDatabaseInaccessible","markDatabaseAccessible","checkTableExists","this","supabase","from","select","limit","toLowerCase","isNetworkFetchError","err","checkPermissions","getAllSettings","data","success","eq","order","ascending","reduce","acc","setting","push","getAllSettingsFromStorage","raw","localStorage","getItem","JSON","parse","e","getSettingsByCategory","getSettingsByCategoryFromStorage","getSetting","maybeSingle","getSettingById","id","getSettingByIdFromStorage","parsed","Object","keys","found","find","s","getSettingFromStorage","setting_key","createSetting","circuitBreakerKey","session","authHelpers","getSession","userId","user","createSettingInStorage","hasPermission","upsertPayload","updated_by","rest","upsert","onConflict","single","retry","errObj","_userId","toISOString","record","setting_value","setting_json","description","data_type","is_required","is_active","created_at","updated_at","list","idx","findIndex","setItem","stringify","updateSetting","updates","updateSettingInStorage","updateSettingById","update","updateSettingByIdInStorage","updated","deleteSetting","delete","deleteSettingFromStorage","next","filter","getSettingValue","result","getCategories","Set","map","getCategoriesFromStorage","appSettingsService","AppSettingsService","AppSettingsHelpers","upsertSetting","existing","ensureSettingValue","defaultValue","current","getPermissionsByRole","role","convertToAppUser","authUser","email","name","department","phone","status","position","employeeId","employee_id","avatar","permissions","AuthService","signIn","password","authData","authError","profileRow","profileErr","profileData","ensureProfileExists","syncSupabasePasswordToAgentCredentials","agentResponse","tryAgentLogin","Error","userExistsByEmail","exists","target","String","trim","isAdminClientConfigured","adminSupabase","adminAuth","auth","admin","listUsers","match","users","u","rpcData","rpcErr","rpc","p_email","userExistsByPhone","normalize","p","replace","authPhone","metaPhone","user_metadata","p_phone","AgentManagementService","__vitePreload","async","Promise","resolve","then","agentManagementService","__VITE_PRELOAD__","existingCreds","credsError","is_temporary","setAgentCredentials","username","p_username","p_password","ok","agent","convertAgentToAppUser","errMsg","signUp","userData","company_name","city","country","must_change_password","adminCreate","adminErr","createUser","insert","adminCreateEx","adminProfileErr","ensureEx","profileUpsertEx","ensuredUser","signInWithGoogle","signOut","getCurrentSession","meta","app_metadata","hasValue","v","metaCompany","agency_name","authEmail","length","updateProfile","assign","enrichErr","resetPassword","reauthenticateWithPassword","currentPassword","getUserError","getUser","signInWithPassword","updatePassword","newPassword","emailForAgent","supabaseError","updateUser","metaErr","dbError","checkPasswordChangeRequired","required","reason","credData","credErr","readErr","metadata","roleData","roleErr","split","payload","upserted","upsertErr","dbClient","DB_LOGIN_TABLE","DB_ACTIVE_TABLE","LOGIN_RECORDS_KEY","ACTIVE_SESSIONS_KEY","getLoginRecords","stored","getActiveStaffSessions","recordStaffLogin","staffId","staffName","loginId","loginTime","existingActive","r","loginRecord","ipAddress","userAgent","navigator","activeSession","lastActivity","existingRecords","activeSessions","last_activity","profile","loginErr","staff_id","staff_name","login_time","ip_address","user_agent","sessErr","login_record_id","dbWriteErr","recordStaffLogout","logoutTime","loginRecords","activeRecord","duration","Math","floor","getTime","updatedSessions","activeRec","fetchErr","durationMinutes","updErr","logout_time","duration_minutes","delErr","dbErr","updateStaffActivity","sessionIndex","getStaffLoginHistory","days","records","cutoffDate","setDate","getDate","sort","a","b","getTotalWorkingHours","date","targetDate","toDateString","recordDate","total","isStaffCurrentlyActive","filters","query","Array","isArray","row","UserTrackingService","static","currentUser","getInstance","instance","setCurrentUser","getCurrentUser","getCurrentUserId","getCreateTrackingData","createdBy","updatedBy","createdByUser","updatedByUser","createdAt","updatedAt","getUpdateTrackingData","getUserInfo","getUsersInfo","userIds","in","usersMap","forEach","formatUserDisplay","userInfo","formatUserDisplayWithDepartment","canEditRecord","recordCreatedBy","currentUserId","canDeleteRecord","getAuditTrail","tableName","recordId","logAction","action","details","userTrackingService","CurrencyService","Map","symbol","decimals","getCurrencyInfo","currencyCode","currencyMap","get","toUpperCase","formatCurrency","amount","currency","rounded","round","pow","toLocaleString","minimumFractionDigits","maximumFractionDigits","formatCurrencyInput","toFixed","getCountryInfo","initialCountries","currencySymbol","region","getCountryByCode","countryCode","c","getCurrencyByCountryCode","getAvailableCurrencies","values","localeCompare","getCountriesByCurrency","calculateWithMargin","rate","margin","multiplier","surcharge","getDefaultRates","to","fromCurrency","toCurrency","lastUpdated","additionalSurcharge","isFixed","isRealTime","isCustom","getApiUsage","used","remaining","fetchAllRealTimeRates","rates","clearCache","staffNotificationService","notifications","preferences","notificationId","generateId","createNotification","notification","newNotification","timestamp","unshift","getNotificationsForStaff","setTimeout","n","markAsRead","read","markMultipleAsRead","notificationIds","dismissNotification","index","splice","getPreferences","userPreferences","browserNotifications","emailNotifications","assignments","statusUpdates","followUpReminders","urgentOnly","set","updatePreferences","showBrowserNotification","window","Notification","permission","browserNotification","title","body","icon","badge","tag","requireInteraction","priority","silent","close","onclick","focus","actionUrl","location","href","sendEmailNotification","recipientEmail","createAssignmentNotification","assignerName","calculatePriority","urgencyText","queryId","type","destination","travelDates","toLocaleDateString","actionRequired","createStatusChangeNotification","oldStatus","newStatus","createFollowUpReminder","createUrgentQueryNotification","expiresAt","travelDate","daysUntilTravel","totalPax","paxDetails","adults","children","infants","packageType","processNotification","isNotificationTypeEnabled","getNotificationCountByPriority","counts","cleanupExpiredNotifications","getNotificationStats","staffNotifications","unread","urgent","highPriority","ALLOWED_ROLES","sessionError","userRole","roleError","newSetting","crypto","randomUUID","settings","existingIndex","settingIndex","telemetryService","storageKey","maxEvents","uploaderRunning","uploadTimer","baseIntervalMs","currentIntervalMs","maxIntervalMs","endpointUrl","__vite_import_meta_env__","VITE_TELEMETRY_ENDPOINT","useSupabase","VITE_ENABLE_TELEMETRY_SUPABASE","load","save","events","slice","recordEvent","event","sanitizePayload","getEvents","configure","opts","intervalMs","startUploader","schedule","flush","min","stopUploader","clearTimeout","res","fetch","method","headers","rows","client","disallowed","k","entries","has","locationResolutionService","locationCache","lastCacheUpdate","lastCacheSource","lastRefreshDurationMs","getLocationByCode","isValidCache","refreshCache","getLocationFullName","full_name","resolveLocationCodes","codes","getAllActiveLocations","loc","searchLocations","searchTerm","refreshStart","fallback","loadFallback","rebuildCache","source","size","duration_ms","error_code","error_message","clear","getCacheStats","lastUpdate","isValid","getLastCacheSource","prewarmCache","force","start","mapLocalToRow","uuidv4","notes","latitude","longitude","Number","fullName","isFinite","resolveTransportRouteLocations","route","resolvedRoute","start_location_code","start_location_full_name","end_location_code","end_location_full_name","intermediate_stops","all","stop","location_code","location_full_name","sightseeing_locations","getApiBaseUrl","origin","sendOtp","baseUrl","response","purpose","contentType","errorText","text","json","verifyOtp","requestId","otp","request_id","upsertAgentWithPhone","getSmsConfigStatus","updateAccountEmail","newEmail","user_id","new_email","isMissingTableError","msg","isAuthOrPermissionError","m","readAgentsFromStorage","writeAgentsToStorage","agents","normalizeArrayField","val","Boolean","startsWith","endsWith","inner","item","normalizeCommissionStructure","obj","rawValue","value","getAgents","currentRole","agentQuery","agentsCore","agentsError","created_by","search","assigned_staff","profiles","profileMap","merged","business_phone","profile_image","source_type","source_details","login_credentials","suspension_reason","suspended_at","suspended_by","getAgentById","agentCore","agentError","adminUserData","adminUserError","getUserById","byUser","business_type","commission_type","commission_value","commission_structure","business_address","license_number","iata_number","specializations","preferred_language","alternate_email","website","partnership","mobile_numbers","documents","agency_code","createAgent","agentData","defaultStatus","creatorProfile","cp","creatorLabel","sourceDetails","primaryStaffId","primary_staff_id","rpcError","p_name","p_company_name","p_agency_code","p_country","p_city","p_business_type","p_source_type","p_source_details","p_staff_id","p_notes","errorMsg","newAgent","toString","random","agentId","agent_id","existingId","updateAgent","additionalStaff","sid","addStaffAssignmentToAgent","isPrimary","agentUpdate","parseFloat","agentErr","prev","prefsPatch","prefsErr","patchAgentSettingsPreferences","patch","selErr","syncAgentEmailAcrossAuth","updateUserById","authErr","profCatch","agentCatch","deleteAgent","signupAgent","signupData","autoApprove","dupeClient","existingProfiles","dupeErr","signUpData","signUpErr","generateTemporaryPassword","options","emailRedirectTo","authUserId","profileId","created","adminCreateErr","email_confirm","agent_type","insertErr","desired_username","storeAgentCredentials","forcePasswordChange","isTemporary","approveAgent","approvalData","p_id","upd","updatePayload","generateCredentials","baseFromEmail","baseFromName","temporaryPassword","p_is_temporary","rejectAgent","rejectionReason","suspendAgent","reactivateAgent","resetCredentials","newCredentials","getStaffMembers","getMyAssignedAgents","byCreator","byAssignment","fallbackErr","authenticateAgentWithDB","i","charAt","chars","updateAgentSourceByEmail","agentExists","upErr","readAssignmentsFallback","writeAssignmentsFallback","getAgentStaffAssignments","assignmentRows","assignErr","fbMap","migrateAssignmentsFallbackToSupabase","reRows","staffIds2","profiles2","profileMap2","is_primary","assignedAt","assigned_at","assignedBy","assigned_by","agentRow","staffIds","x","innerErr","assignerIds","staffProfiles","staffProfileMap","assignerProfileMap","assignerProfiles","staffProfile","assignerId","assignerProfile","assignedByName","assignedByRole","updateStaffAssignmentForAgent","removeStaffAssignmentFromAgent","targetAgentId","migratedAgents","migratedRows","readTaxInfoFromStorage","writeTaxInfoToStorage","getAgentTaxInfo","fb","upsertAgentTaxInfo","globalThis","tax_verified","REFERRAL_TABLE","buildReferralCode","btoa","short","bytes","binary","fromCharCode","bytesToBase64Url","uuid","hex","Uint8Array","parseInt","substr","uuidToBytes","decodeReferralCodeToStaffId","b64","atob","padded","charCodeAt","base64UrlToBytes","padStart","join","bytesToUuid","buildReferralLink","publicUrl","VITE_PUBLIC_SITE_URL","VITE_SITE_URL","getBaseSignupUrl","ensureReferralExistsForStaff","link","referral_code","getStaffReferralLink","getDeterministicStaffReferralLink","recordReferralCodeIfMissing","referralCode","possibleStaffId","sb","nameCache","roleCache","resolveProfileNameById","cached","agentByUser","agentUserErr","agentById","agentIdErr","resolveProfileRoleById","resolveEnquiryUuid","enquiryBusinessId","createWorkflowEvent","entry","enquiryUuid","userNameSource","userName","userIdStr","staffRow","staffErr","profRow","profErr","resolveUserNameWithSource","eventType","ruleApplied","rule_applied","assignmentRule","assignedByStr","assignedToStr","assignedTo","assignedToName","enquiry_id","event_type","user_name","user_role","listWorkflowEventsByEnquiryBusinessId","isSystemAuto","toUIEvent","countries","getCountryByName","getStaffOperationalCountries","operationalCountries","byId","byCode","byName","findStaffByCountry","availableStaff","queryDestination","destinationCountry","staff","hasCountryMatch","workloadRatio","assigned","workloadCapacity","score","matchType","matchedCountries","getBestCountryMatch","matches","perfectMatches","availableMatches","getAssignmentReason","expertise","exp","fetchEnhancedStaff","staffRows","historyRows","histErr","assignedCounts","mapped","nextId","operational_countries","active","availability","day","isAvailable","workingHours","end","autoAssignEnabled","sequenceOrder","experience","existingUuids","managerProfiles","mgrErr","getAvailableStaff","findBestStaffMatch","countryMatch","destinations","cities","scoredStaff","dest","pkg","spec","TABLE","StaffSequenceService","fetchSequence","upsertSequence","items","it","existingRows","existingSet","base","sequence_order","auto_assign_enabled","addStaff","insertPayload","removeStaff","reorderSequence","orderedStaffIds","updateAutoAssign","enabled","listAssignmentRules","updateAssignmentRuleEnabled","createAssignmentRule","rule_type","conditions","updateAssignmentRule","deleteAssignmentRule","getRulesEnabledMap","ruleTypes","rt","en","ruleType","toQuery","fallbackDate","specialRequests","special_requests","rawAgentId","agentUuid","norm","maybeNum","agentName","country_name","travel_from","travel_to","isEstimated","is_date_estimated","tripDuration","nights","package_type","budget","budget_min","max","budget_max","budget_currency","assigned_to","communicationPreference","communication_preference","hotelDetails","rooms","hotel_rooms","hotel_category","inclusions","sightseeing","transfers","mealPlan","meal_plan","cityAllocations","city_allocations","toDateOnly","iso","d","yyyy","getFullYear","getMonth","listEnquiries","params","page","pageSize","field","direction","offset","count","or","createdFrom","gte","createdTo","lte","sortField","range","agentIds","agentsMap","agentsData","agentsErr","queries","q","agentCompany","fetchAllEnquiries","batchSize","buildBaseQuery","firstData","firstError","fetched","batch","createEnquiry","selectedCountryCode","getCountryCodeByName","ensureCountryConfig","countryName","country_code","fromQuery","initialId","candidate","prefix","numStr","latest","like","nextNum","lm","ensureUniqueEnquiryId","bumpId","inserted","insertError","attempts","currentRow","createdQuery","settingVal","ruleStatus","roundRobinActive","workloadBalanceActive","expertiseMatchActive","activeStaff","destCountry","candidatesWithCountry","ops","seqRows","orderedIds","staffByUuid","availableIds","nextUuid","recent","lastId","startIndex","indexOf","step","best","assignEnquiry","refetched","updateEnquiry","resolvedStaffId","findError","staffFound","ilike","is_auto_assigned","subscribeEnquiries","onChange","channel","on","schema","table","new","old","subscribe","useEnquiries","setData","useState","setCount","isLoading","setIsLoading","setError","fetchData","useCallback","useEffect","ch","_type","removeChannel","refetch","getEnquiryById","isUuid","enriched","company","searchEnquiriesBySuffix","suffix","trimmed","agentInfo","agent_name","staffIdOrName","isAutoAssigned","previousAssignedId","previousStatus","previousAssignedNameSource","previousAssignedName","prevStaffRow","prevStaffErr","prevProfile","prevProfErr","assignedToNameSource","staffProfileId","staffAssignedName","updateError","historyError","config","DEFAULT_ENQUIRY_COUNTRIES","defaultCountryCode","isActive","invCountry","template","newCountry","yearFormat","yearSeparator","numberLength","numberSeparator","startingNumber","isDefault","enquirySettings","enquiryId","file","path","storage","upload","cacheControl","pub","getPublicUrl","url","DEFAULT_SEO_SETTINGS","page_route","keywords","og_title","og_description","meta_robots","seoService","localStorageKey","profileStorageKey","activityLogKey","getSEOSettings","pageRoute","getAllSEOSettings","allSettings","upsertSEOSettings","updatedSettings","getEnhancedProfile","upsertEnhancedProfile","existingProfile","updatedProfile","last_active","logProfileActivity","getProfileActivityLog","log","fieldChanged","oldValue","newValue","logs","newLog","field_changed","old_value","new_value","subscribeToSEOSettings","callback","handleStorageChange","addEventListener","unsubscribe","removeEventListener","subscribeToEnhancedProfile","createAutoSave","saveFunction","debounceMs","timeoutId","AGENTS_STORAGE_KEY","AgentStorageService","storedAgents","saveAgent","newId","stats","totalQueries","totalBookings","conversionRate","revenueGenerated","averageBookingValue","activeCustomers","recentActivity","updatedAgents","agentIndex","updatedAgent","filteredAgents","realTimeNotificationService","ws","subscribers","reconnectAttempts","reconnectTimer","isConnected","audioContext","notificationSound","constructor","enableWebSocket","enablePushNotifications","enableSoundNotifications","reconnectInterval","maxReconnectAttempts","initializeAudioContext","setupServiceWorker","AudioContext","webkitAudioContext","buffer","createBuffer","getChannelData","sin","PI","VITE_ENABLE_SW","serviceWorker","register","connect","wsUrl","WebSocket","onopen","send","onmessage","handleIncomingNotification","onclose","attemptReconnect","onerror","disconnect","notifySubscribers","playNotificationSound","subscriber","shouldNotifySubscriber","types","priorities","createBufferSource","requestNotificationPermission","requestPermission","subscribeToPushNotifications","registration","ready","subscription","pushManager","userVisibleOnly","applicationServerKey","urlBase64ToUint8Array","sendSubscriptionToServer","base64String","base64","repeat","rawData","outputArray","sendNotification","updateConfig","newConfig","getConnectionStatus","hasWebSocketSupport","hasPushSupport","hasNotificationSupport","notificationPermission","startSimulation","simulationTypes","messages","setInterval","rawOperationalCountries","safe","mappedNamesFromIds","calculateWorkload","head","getEligibleStaff","enforceCountryFilter","sequenceActive","seqById","ids","profilesRows","eligible","rawOperational","seq","inSequence","countryOk","workloadCount","mappedOps","getAgentStaffRelation","eligibleIds","getStrictSequenceOrderedIds","nextSequenceRoundRobin","allowedIds","candidateId","nextRoundRobinStaff","allowSet","assignQuery","enquiry","expertiseMatchEnabled","relationEnabled","workloadBalanceEnabled","roundRobinEnabled","seqIds","relStaffId","byWorkload","minCount","lowest","rrTieId","nextSeqId","seqNext","relationStaffId","rrTie","seqTieId","rr","CountriesService","fetchCitiesHeadCount","getAllCountries","getAllCountriesAdmin","supabaseAdmin","getCountryById","createCountry","updateCountry","deleteCountry","citiesUsingCountry","citiesError","getCountriesByStatus","searchCountries","bulkInsertCountries","getCountriesByContinent","continent","overridePricingCurrency","countryId","pricingCurrency","pricingCurrencySymbol","pricing_currency","pricing_currency_symbol","pricing_currency_override","removePricingCurrencyOverride","bulkOverridePricingCurrency","countryIds","getCountriesWithPricingOverrides","bulkDeleteCountries","bulkToggleStatus","bulkUpdateCountries","bulkUpsertCountries","ignoreDuplicates","updateCountryByCode","bulkUpdateCountriesByCode","results","errors","getCountriesWithCityCount","countriesData","cityCount","city_count","toCountryWithCityCount","mapDbCountryToFrontend","dbCountry","currency_symbol","flag_url","is_popular","visa_required","languages","mapFrontendCountryToDbInsert","mapFrontendCountryToDbUpdate","mapDbCountriesToFrontend","dbCountries","ensureStaff","buildQuery","seedAssignmentTestData","alice","bob","charlie","ensureAgent","ensureAgentStaffRelation","pre1Id","relId","balanceId","rrId","rr2Id","enquiries","isGemini","api","base_url","provider_name","getActiveProviders","providers","ai","bi","aiIdx","o","biIdx","POSITIVE_INFINITY","sortByDefaultPriority","sessionUsageCounts","timeoutSignal","timeoutMs","controller","AbortController","abort","signal","tryProvider","prompt","model","model_name","performance","statusCode","encodeURIComponent","api_key","contents","parts","catch","candidates","content","inline_data","endpoint","status_code","response_time","response_time_ms","answer","provider","Authorization","temperature","choices","runSmartPrompt","maxRetries","maxRetriesPerProvider","sessionLimit","sessionProviderLimit","currentUsage","usage_count","daily_limit","fallback_reason","attempt","last_tested","ItineraryService","setInventoryData","hotels","restaurants","transportRoutes","generateItinerary","request","itinerary","travelers","startDate","endDate","calculateDuration","generateDestinations","interests","accommodationType","transportPreference","dietaryRestrictions","pricing","baseCost","markup","markupType","finalPrice","context","contextId","generateDailyItinerary","calculatePricing","ceil","destinationNames","totalDays","dayNum","currentDate","addDays","format","activities","generateActivities","meals","generateMeals","totalCost","accommodation","generateAccommodation","previousLocation","transport","generateTransport","calculateDayCost","localSightseeing","numActivities","sight","startHour","startTime","endTime","price","getPrice","policies","localRestaurants","lunchRestaurant","dinnerRestaurant","restaurant","cuisine","averageCost","time","localHotels","h","selectedHotel","starRating","defaultHotel","amenities","hotel","checkIn","checkOut","roomType","transportType","sum","activity","meal","adult","CitiesService","getAllCities","getAllCitiesAdmin","getCityById","createCity","cityData","countryLookupError","has_airport","country_id","updateCity","existingCity","fetchError","updateData","mergedData","upsertData","upsertError","fallbackError","deleteCity","checkError","deleteError","softDeleteData","softDeleteError","rpcResult","city_id","warning","hideError","searchCities","getCitiesByCountryId","bulkDeleteCities","citiesToDelete","city_ids","successCount","bulkUpdateCities","cityIds","bulkUpsertCities","getActiveCities","getPopularCities","getActiveCountries","listTransportRoutes","routes","mapRouteRowToProposalRoute","vt","vehicle_types","te","transport_entries","first","isNaN","start_location","end_location","distance","transfer_type","route_name","route_code","transferType","EnhancedProposalService","proposalStorageKey","changesStorageKey","versionsStorageKey","createProposal","proposalData","proposalId","ProposalIdGenerator","generateProposalId","newProposal","modules","totals","subtotal","discountAmount","moduleCount","version","saveProposal","logChange","saveVersion","duplicateProposal","originalId","newQueryId","original","getProposal","targetQueryId","newProposalId","duplicated","getProposalsByQuery","getAllProposals","updateProposal","changeDescription","processBulkOperation","failed","queryIds","getProposalChanges","getAllChanges","getProposalVersions","getAllVersions","proposal","proposals","saved","changeType","change","changes","versionId","versions","cleanupOldVersions","allVersions","versionsToKeep","otherVersions","EnhancedProposalService$1","ProposalService","queryStorageKey","createQuery","queryData","getAllQueries","foundCountry","EnqIdGenerator","prepareConfig","generateEnqId","enquiryError","newQuery","getQueryById","savedQueries","foundQuery","mockQueries","getQueryByIdAsync","localOrMock","EnhancedService","getProposalById","getProposalsByQueryId","deleteProposal","filtered","exportProposal","dataStr","dataUri","exportFileDefaultName","linkElement","document","createElement","setAttribute","click","duplicate","migrateToEnhancedService","ProposalService$1","enquiryBusinessOrUuid","getCurrentProfileId","generateDraftProposalId","draftType","computeCostPerPerson","pax","buildTitle","buildDescription","dayNumber","buildItineraryData","accommodations","breakfast","lunch","dinner","sightseeing_options","city_selection","buildAccommodationData","dayId","buildPricingData","basePrice","transport_options","isPlainObject","deepMerge","srcVal","tgtVal","normalizeItineraryData","normalizePricingData","SupabaseProposalService","getLatestDraftForEnquiry","nullsFirst","listProposalsByEnquiry","getDraftByProposalId","upsertDraftProposal","proposal_id","cost_per_person","total_cost","final_price","exclusions","terms","draft_type","itinerary_data","accommodation_data","pricing_data","email_data","agent_feedback","modifications","last_saved","optional_records","updateProposalStatus","sent_at","accepted_at","rejected_at","searchId","updateDraftFields","mergedItinerary","mergedPricing","mergedAccommodation","mergedEmail","mergedInclusions","mergedExclusions","mergedTerms","deleteByProposalId","listTransportTypes","createTransportType","seating_capacity","luggage_capacity","updateTransportType","deleteTransportType","toggleTransportTypeActive","mapTransportTypeRowToUI","seatingCapacity","luggageCapacity","mapUIToTransportTypeRow","ui","listLocationCodes","createLocationCode","insertData","updateLocationCode","deleteLocationCode","DEFAULT_TAX_CONFIGURATIONS","taxType","taxRates","serviceType","tdsConfiguration","isApplicable","threshold","exemptionLimit","exemptions","TaxCalculationService","initializeFromSupabase","PricingConfigurationService","getDefaultConfiguration","setDefaultConfiguration","defaultCountry","seedErr","initializedFromSupabase","currentConfigId","default_country","TaxConfigurationSupabase","listByConfig","toUI","def","fromUI","taxConfigurations","listActiveCountries","countryNameMap","fromEntries","getTaxConfigurations","getTaxConfiguration","getDefaultCountry","getAvailableCountries","detectCountryFromCurrency","INR","AED","USD","GBP","initializeDefaultConfigurations","calculateTax","baseAmount","isInclusive","taxAmount","totalAmount","taxBreakdown","taxRate","taxableAmount","tdsAmount","addTaxConfiguration","updateTaxConfiguration","configOrCountryCode","fullConfig","cfg","isInitializedFromSupabase","getCurrentConfigId","PricingService","defaultMarkupPercentage","useSlabPricing","slabApplicationMode","markupSlabs","minAmount","maxAmount","markupValue","showPricingToAgents","showPricingToStaff","allowStaffPricingEdit","getSettings","toPricingSettings","updateSettings","upsertConfiguration","base_markup_percentage","slab_markup_enabled","dispatchEvent","CustomEvent","detail","calculateMarkup","paxCount","perPersonPrice","totalPrice","comparisonAmount","applicableSlab","slab","convertCurrency","THB_USD","USD_THB","THB_EUR","EUR_THB","THB_AED","AED_THB","THB_SGD","SGD_THB","THB_INR","INR_THB","THB_GBP","GBP_THB","USD_EUR","EUR_USD","USD_AED","AED_USD","USD_SGD","SGD_USD","USD_INR","INR_USD","USD_GBP","GBP_USD","AED_SGD","SGD_AED","INR_AED","AED_INR","EUR_GBP","GBP_EUR","directRate","toUSDKey","fromUSDKey","usdAmount","CountryCurrencyService","getCurrencyByCountryName","getPricingCurrencyByCountryName","getPricingCurrencyByCountryCode","getAllCountriesWithCurrency","pricingCurrencyOverride","hasPricingCurrencyOverride","getEffectiveCurrency","isOverride","EnhancedPricingService","countryRules","defaultMarkup","tier","conversionMargin","regionalTemplates","currencyConversion","baseCurrency","autoUpdateRates","updateFrequency","fallbackRates","conversionMargins","THB","SGD","MYR","EUR","enableCountryBasedPricing","popularDestinations","getEnhancedSettings","enhancedSettings","updateEnhancedSettings","getCountryRule","rule","calculateCountryBasedPricing","targetCurrency","countryRule","originalCurrency","convertedCurrency","regionalAdjustment","tierMultiplier","countryInfo","standard","premium","luxury","seasonalAdjustment","convertedPrice","targetCurr","rateKey","createCountryRule","uniqueId","rand","newRule","updatedRules","updateCountryRule","ruleId","deleteCountryRule","applyRegionalTemplate","templateId","targetCountries","t","existingRule","currencyInfo","performBulkOperation","adjustmentValue","adjustmentType","newMarkup","loadSMTPConfig","host","port","secure","fromEmail","fromName","smtp_host","smtp_port","smtp_secure","smtp_user","smtp_password","from_email","from_name","subject","html","configOverride","VITE_EMAIL_SERVER_URL","statusText","translationCache","detectLanguage","language","translateText","targetLang","sourceLang","cacheKey","translatedText","fallbackTranslate","simpleDictionary","Hello","fr","es","ar","hi","ru","ja","de","pt","zh","ko","Goodbye","lowerText","translations","emailTemplateService","templates","defaultTemplates","trigger","variables","availableVariables","example","initializeDefaultTemplates","newTemplate","getTemplates","getTemplatesByCategory","getTemplatesByRole","getTemplateById","createTemplate","updateTemplate","deleteTemplate","duplicateTemplate","toggleTemplateStatus","getAvailableVariables","getVariablesByCategory","previewTemplate","previewSubject","previewContent","regex","RegExp","sendTestEmail","testEmail","preview","sendEmail","emailService","getTemplateStats","inactive","byCategory","byRole","CurrencyApiService","getApiKey","API_KEY_KEY","getUsage","USAGE_KEY","resetDate","lastFetch","updateUsage","increment","usage","nextMonth","getCachedRates","CACHE_KEY","CACHE_DURATION","setCachedRates","cacheData","fetchRealTimeRates","apiKey","currencies","API_BASE_URL","currencyData","fetchSpecificRate","reverseKey","removeItem","getRemainingRequests","CurrencyScheduler","scheduleDaily9AM","refreshCallback","clearSchedule","millisecondsUntil9AM","getMillisecondsUntilNextIST","performScheduledRefresh","isScheduled","getISTTime","getNextRefreshTime","nextRefresh","setTime","formatISTTime","EmailConfigurationService","getEmailConfigurations","getActiveEmailConfiguration","manualData","manualError","getEmailConfigurationById","createEmailConfiguration","configData","updateEmailConfiguration","deleteEmailConfiguration","setDefaultEmailConfiguration","unsetError","is_default","neq","toggleEmailConfigurationStatus","currentConfig","testEmailConfiguration","configResult","htmlContent","emailServerUrl","errorData","messageId","previewUrl","emailConfigurationService","CountryEmailSettingsService","getCountryEmailSettings","getCountryEmailSettingByCountryId","saveCountryEmailSetting","existingSetting","cc_emails","bcc_emails","settingData","deleteCountryEmailSetting","toggleCountryEmailSettingStatus","currentSetting","getCountryEmailRecipients","getCountriesWithoutSettings","activeCountries","countriesError","settingsCountries","settingsError","countriesWithSettings","countryEmailSettingsService","getBaseUrl","buildUrl","URL","searchParams","fetchOutbox","fetchInbox","fetchCampaigns","fetchQueueStatus","createCampaign","sendCampaignNow","scheduleCampaign","scheduled_at","pauseCampaign","resumeCampaign","fetchDashboard","getAiBaseUrl","VITE_AI_SERVER_URL","checkHealth","generateEmailTemplate","args","LocationResolutionService","getLocationDetails","locationCode","coordinates","lat","lng","resolveLocationFields","formData","resolvedData","startDetails","start_coordinates","endDetails","end_coordinates","stopDetails","resolveStopLocation","stopData","locationDetails","resolveSightseeingLocation","optionData","ComprehensiveTransportService","createCompleteRoute","resolvedFormData","validation","validateRouteData","routeData","generateRouteCode","enable_sightseeing","routeError","intermediateStops","stopsData","route_id","stop_order","stops","stopsError","sightseeingOptions","sightseeingData","option","optionsError","getCompleteRoute","routeId","getCompleteRoutes","sortBy","sortOrder","totalPages","routesError","updateCompleteRoute","routeUpdateData","deleteCompleteRoute","getTransportTypes","typesError","manageIntermediateStops","newStops","getIntermediateStops","createIntermediateStop","resolvedStopData","updateIntermediateStop","deleteIntermediateStop","reorderIntermediateStops","stopIds","stopId","manageSightseeingOptions","optionsData","newOptions","getSightseeingOptions","createSightseeingOption","resolvedOptionData","updateSightseeingOption","deleteSightseeingOption","substring","validateCountry","countryValidation","adult_price","child_price","getRouteStatistics","totalRoutes","routesByTransferType","routesByCountry","routesWithSightseeing","routesWithIntermediateStops","countError","transferTypeData","transferTypeError","countryData","countryError","sightseeingError","routesWithStops","IntegratedTransportService","validateLocationCodes","existingCodes","validCodes","invalidCodes","valid","invalid","createTransportRoute","allLocationCodes","startLocationDetails","endLocationDetails","startFullName","endFullName","startCoordinates","endCoordinates","computedRouteName","typeShortMap","routeCode","indexStr","typeShort","transport_types","transport_type","bags","kg","intermediateStopsData","stopsToInsert","resolvedCoords","transfer_method_notes","location_details","transportTypesData","sightseeingOptionsData","additional_charges","start_location_details","end_location_details","intermediate_stops_data","transport_types_data","sightseeing_options_data","getTransportRoute","transportTypes","enrichedStops","include_related","updateTransportRoute","locationCodes","updateBody","prototype","hasOwnProperty","call","allowed","updatedRoute","deleteTransportRoute","validateDataConsistency","issues","lc","routeIds","integratedTransportService","parseJsonArraySafely","locationNameCache","getTransportRouteDetails","vehicleTypes","BASE","getJson","Accept","nominatimService","URLSearchParams","addressdetails","countrycodes","reverse","lon","VisaService","getAllVisas","visa_type","visas","visa","documents_parsed","parseDocuments","getVisaById","createVisa","visaData","updateVisa","deleteVisa","getVisaCountries","getVisaTypes","formatDocumentsForStorage","ProposalTemplateService","getAllTemplates","concat","getDefaultTemplates","getTemplatesByDestination","queryCity","getTemplatesByDuration","getRecommendedTemplates","scoreA","usageCount","averageRating","saveTemplate","dayPlan","pricingMatrix","lastUsed","tags","saveProposalAsTemplate","proposalDays","templateName","incrementUsage","templateIndex","getStoredStaff","fetchStaffFromSupabase","today","mapRow","joinDate","dateOfBirth","skills","certifications","daily","tasksCompleted","responseTime","customerSatisfaction","monthly","month","totalTasks","averageResponseTime","averageCustomerSatisfaction","targetAchievement","quarterly","quarter","performanceRating","goalsAchieved","totalGoals","growthPercentage","overall","totalExperience","performanceScore","ranking","badges","targets","monday","isWorking","tuesday","wednesday","thursday","friday","saturday","sunday","reportingManager","teamMembers","salaryStructure","leaveBalance","attendanceRecord","updateStaffMember","updateStaffStatusBothTables","profileError","staffError","queryWorkflowService","workflows","eventId","generateEventId","createWorkflow","workflow","getWorkflow","addEvent","newEvent","createQueryCreatedEvent","createAssignmentEvent","createStatusChangeEvent","createProposalCreatedEvent","proposalTitle","createFollowUpEvent","followUpDate","createCommentEvent","comment","commentType","getQueryEvents","getAvailableActions","actions","getThailandSpecificActions","generateWorkflowSummary","statusEvents","completedSteps","currentStep","nextActions","estimatedCompletion","calculateEstimatedCompletion","executeAction","actionId","tomorrow","daysRemaining","getWorkflowStats","statusChanges","currentStatusEvent","daysInCurrentStatus","timeToFirstProposal","totalEvents","exportWorkflow","exportedAt","getWorkflowSummary","currentStatus","daysActive","lastEvent","firstEvent","formatActivityDescription","timeAgo","getTimeAgo","eventTime","diffInHours","diffInDays","automatedProposalStatusService","proposalTracking","statusTransitionRules","clientResponseRequired","paymentReceived","daysSinceLastActivity","followUpCount","initializeProposalTracking","trackingData","statusHistory","triggeredBy","clientResponseCount","paymentHistory","getProposalTracking","getTrackingByQueryId","tracking","transitionStatus","applicableRules","checkTransitionConditions","executeStatusTransition","lastClientInteraction","proposalSentDate","proposalViewedDate","lastFollowUpDate","automated","handleProposalCreated","queryStatus","proposalCreatedAt","handleProposalSent","sendMethod","sentAt","handleProposalViewed","clientId","viewSource","viewedAt","handleClientFeedback","feedbackType","interested","negotiation","rejection","receivedAt","handlePaymentReceived","paymentType","checkFollowUpRequired","lastFollowUp","followUpNumber","totalFollowUps","getProposalsNeedingFollowUp","proposalsNeedingFollowUp","shouldFollowUp","getProposalStats","allTrackingData","statusDistribution","viewedProposals","averageTimeToView","sentTime","convertedProposals","totalProposals","ALLOWED_WRITE_ROLES","USE_DEPARTMENTS_FALLBACK","readDepartmentsFromStorage","sampleDepartments","writeDepartmentsToStorage","getCurrentUserRole","departmentService","getDepartments","staffCount","staff_count","features","stages","autoAssignment","escalationRules","createDepartment","newDept","updateDepartment","initializeDepartmentFeatures","sample","defaultFeatures","addFeatureToDepartment","feature","currentFeatures","f","updatedFeatures","removeFeatureFromDepartment","featureId","deleteDepartment","staffCountData","assignedCount","migrateDepartmentsFallbackToSupabase","legacy","readLegacyDepartmentsFallback","migrated","checkTableAccessible","getStaffCountsByDepartment","dept","mapStaffRoleToUserRole","normalized","shortCodeMap","manager","hr_manager","finance_manager","sales_agent","executive","Manager","Agent","Executive","Staff","syncStaffWithAuthSystem","mustChangePassword","uiRole","roleForProfile","remoteUser","expectedRole","expectedDepartment","profileUpdates","currRole","currDept","currPos","currMustChange","desiredPosition","join_date","reporting_manager","date_of_birth","sRole","sDept","staffUpdates","sJoin","sDob","sMgr","sCountries","incoming","every","verifyErr","workLocation","lastLogin","Sales","Operations","Finance","Marketing","languageAccess","preferredLanguage","_credentials","dayKeyToIndex","indexToDayKey","normalizeUIHours","shifts","mapRowsToUI","day_of_week","is_working","staffWorkingHoursService","getWorkingHoursByStaff","getTimezoneByStaff","timezone","upsertWorkingHours","uiHours","mapUIToRows","del","deleteWorkingHoursForStaff","setWorkingDay","dayKey","dayIndex","mapUIToRow","achieved","period","start_date","end_date","mapRowToUI","staffTargetService","listTargetsByStaff","replaceTargetsForStaff","createTarget","updateTarget","deleteTarget","BUCKET","toStaffDocument","docType","doc_type","fileName","file_name","fileExt","file_ext","mimeType","mime_type","sizeBytes","size_bytes","storagePath","storage_path","sha256","verifiedBy","verified_by","verifiedAt","verified_at","listDocuments","getSignedUrl","expiresInSeconds","createSignedUrl","signedUrl","uploadDocument","ext","pop","uploadErr","approveDocument","documentId","rejectDocument","deleteDocument","doc","remove","toBank","bankName","bank_name","accountHolderName","account_holder_name","accountNumberLast4","account_number_last4","ifscOrSwift","ifsc_or_swift","branch","verifiedStatus","verified_status","getBankAccount","upsertBankAccount","input","p_bank_name","p_account_holder_name","p_account_number_plain","accountNumber","p_ifsc_or_swift","p_branch","updateBankVerificationStatus","accountId","metaSettingsSchema","z.object","waba_id","z.string","phone_id","token","template_name","default","business_name","z.boolean","optional","testMessageSchema","getMetaSettings","updateMetaSettings","validatedData","testWhatsAppConnection","phoneCheckResponse","phoneError","testMessage","messaging_product","message_id","validateWabaId","wabaId","validatePhoneId","phoneId","validateAccessToken","checkTokenExpirationRisk","riskLevel","maskToken","activityTracker","idleTimer","isTracking","currentStaffId","idleThreshold","currentSession","listeners","loadActivities","saveActivities","startTracking","stopTracking","recordActivity","pathname","setupActivityListeners","startIdleMonitoring","removeActivityListeners","stopIdleMonitoring","handleMouseMove","updateLastActivity","clientX","y","clientY","handleKeyPress","element","tagName","handleClick","handlePageChange","handleScroll","passive","removeListener","activityEvent","recordBreak","getActivities","dateRange","activityDate","generateProductivityReport","totalActiveTime","totalIdleTime","pageViews","actionsPerformed","averageSessionDuration","productivityScore","breakTime","focusTime","mostVisitedPages","hourlyActivity","_","hour","activeActivities","idleActivities","breakActivities","pageStats","hourActivities","getHours","totalTime","sessions","groupActivitiesBySessions","activityTime","getDailyProductivityTrend","trend","dayStart","setHours","dayEnd","dayMetrics","clearActivityData","exportActivityData","isCurrentlyTracking","getCurrentStaffId","UniversalPDFService","defaultStyles","fontSize","fontFamily","textColor","backgroundColor","borderColor","borderWidth","padding","alignment","activityTemplate","layout","sections","width","height","logo","fields","styles","proposalTemplate","subtitle","generatePDF","pdf","jsPDF","orientation","unit","setProperties","author","section","renderSection","watermark","addWatermark","Blob","output","convertToImage","quality","pageWidth","internal","getWidth","pageHeight","getHeight","renderHeader","renderContent","renderChart","renderTable","renderText","renderImage","setFontSize","setFont","align","setDrawColor","setLineWidth","rect","metrics","currentY","label","formatDuration","productivityTrend","chartData","chartWidth","chartHeight","setFillColor","x1","y1","x2","y2","line","point","pointX","pointY","circle","services","rowHeight","colWidths","service","quantity","lines","splitTextToSize","src","addImage","setGState","GState","opacity","setTextColor","angle","canvas","html2canvas","toBlob","blob","milliseconds","getTemplate","generateBatchPDFs","requests","generateActivityReport","generateProposalPDF","downloadPDF","filename","createObjectURL","download","appendChild","removeChild","revokeObjectURL","emailPDF","emailData","universalPDFService","TransportRouteErrorService","errorLog","errorCallbacks","feedbackCallbacks","logError","severity","errorId","generateErrorId","logEntry","stackTrace","stack","resolved","generateTags","callbackError","persistErrorLog","logValidationErrors","validationResult","errorIds","validationDetails","warnings","logDatabaseError","additionalDetails","getDatabaseErrorCode","originalError","logSynchronizationError","syncType","failedData","showUserFeedback","feedback","showValidationFeedback","routeName","persistent","showDetailedValidationErrors","variant","w","showDatabaseFeedback","showErrorDetails","showSynchronizationFeedback","syncedCount","failedCount","showRecentErrors","onError","onFeedback","getErrorStatistics","timeRange","filteredErrors","errorsByCategory","errorsBySeverity","errorCounts","topErrors","lastOccurred","recentErrors","resolvedErrors","resolutionRate","hours","errorRate","totalErrors","resolveError","resolvedBy","resolvedAt","clearOldErrors","olderThan","initialCount","exportErrorLog","getConsoleMethod","console","warn","info","debug","transportRouteErrorService","AgentApiService","fetchAgents","commissionType","commissionValue","contact","fetchAgentById","searchAgents"],"ignoreList":[],"sources":["../../src/services/appSettingsService_database.ts","../../src/services/authService.ts","../../src/services/loginRecordService.ts","../../src/services/userTrackingService.ts","../../src/services/currencyService.ts","../../src/services/staffNotificationService.ts","../../src/services/appSettingsService.ts","../../src/services/telemetryService.ts","../../src/services/locationResolutionService.ts","../../src/services/smsService.ts","../../src/services/agentManagementService.ts","../../src/services/staffReferralService.ts","../../src/services/profilesHelper.ts","../../src/services/workflowEventsService.ts","../../src/services/countryMappingService.ts","../../src/services/countryAssignmentService.ts","../../src/services/staffAssignmentService.ts","../../src/services/staffSequenceService.ts","../../src/services/assignmentRulesService.ts","../../src/services/enquiriesService.ts","../../src/services/seoService.ts","../../src/services/agentStorageService.ts","../../src/services/realTimeNotificationService.ts","../../src/services/autoAssignmentEngine.ts","../../src/services/countriesService.ts","../../src/services/countryMapper.ts","../../src/services/testSeedService.ts","../../src/services/aiRouter.ts","../../src/services/itineraryService.ts","../../src/services/citiesService.ts","../../src/services/transportRoutesService.ts","../../src/services/enhancedProposalService.ts","../../src/services/proposalService.ts","../../src/services/supabaseProposalService.ts","../../src/services/transportTypesService.ts","../../src/services/locationCodesService.ts","../../src/services/taxCalculationService.ts","../../src/services/pricingService.ts","../../src/services/countryCurrencyService.ts","../../src/services/enhancedPricingService.ts","../../src/services/emailService.ts","../../src/services/translationService.ts","../../src/services/emailTemplateService.ts","../../src/services/currencyApiService.ts","../../src/services/currencyScheduler.ts","../../src/services/emailConfigurationService.ts","../../src/services/countryEmailSettingsService.ts","../../src/services/emailMarketingService.ts","../../src/services/aiIntegrationService.ts","../../src/services/comprehensiveTransportService.ts","../../src/services/integratedTransportService.ts","../../src/services/transportRouteDetailsService.ts","../../src/services/nominatimService.ts","../../src/services/visaService.ts","../../src/services/proposalTemplateService.ts","../../src/services/staffStorageService.ts","../../src/services/queryWorkflowService.ts","../../src/services/automatedProposalStatusService.ts","../../src/services/departmentService.ts","../../src/services/credentialService.ts","../../src/services/staffWorkingHoursService.ts","../../src/services/staffTargetService.ts","../../src/services/staffDocumentsService.ts","../../src/services/staffBankService.ts","../../src/services/metaSettingsService.ts","../../src/services/activityTrackingService.ts","../../src/services/universalPDFService.ts","../../src/services/transportRouteErrorService.ts","../../src/services/agentApiService.ts"],"sourcesContent":["import { supabase, authHelpers } from '@/lib/supabaseClient';\nimport { Json } from '@/integrations/supabase/types';\n\n// Using centralized supabase client to avoid multiple GoTrueClient instances\n\n// Circuit breaker for preventing rapid retry attempts\ninterface CircuitBreakerState {\n  failureCount: number;\n  lastFailureTime: number;\n  isOpen: boolean;\n}\n\nconst circuitBreaker: Record<string, CircuitBreakerState> = {};\nconst MAX_FAILURES = 3;\nconst CIRCUIT_BREAKER_TIMEOUT = 30000; // 30 seconds\nconst STACK_DEPTH_ERROR_CODES = ['54001', '54011'];\nconst STACK_DEPTH_ERROR_PATTERNS = [/stack depth/i, /stack overflow/i, /recursion/i];\n\nfunction getCircuitBreakerKey(operation: string, category?: string, settingKey?: string): string {\n  return `${operation}_${category || 'all'}_${settingKey || 'all'}`;\n}\n\nfunction shouldAttemptOperation(key: string): boolean {\n  const state = circuitBreaker[key];\n  if (!state) return true;\n  \n  if (state.isOpen) {\n    const timeSinceLastFailure = Date.now() - state.lastFailureTime;\n    if (timeSinceLastFailure > CIRCUIT_BREAKER_TIMEOUT) {\n      // Reset circuit breaker after timeout\n      delete circuitBreaker[key];\n      return true;\n    }\n    return false;\n  }\n  \n  return true;\n}\n\nfunction recordSuccess(key: string): void {\n  delete circuitBreaker[key];\n}\n\nfunction isStackDepthError(error: any): boolean {\n  if (!error) return false;\n  \n  const errorCode = error.code || '';\n  const errorMessage = error.message || '';\n  \n  // Check for PostgreSQL stack depth error codes\n  if (STACK_DEPTH_ERROR_CODES.includes(errorCode)) return true;\n  \n  // Check for stack depth patterns in error message\n  return STACK_DEPTH_ERROR_PATTERNS.some(pattern => pattern.test(errorMessage));\n}\n\nfunction recordFailure(key: string, error?: any): void {\n  const state = circuitBreaker[key] || { failureCount: 0, lastFailureTime: 0, isOpen: false };\n  \n  // For stack depth errors, open circuit breaker immediately\n  if (isStackDepthError(error)) {\n    state.failureCount = MAX_FAILURES;\n    state.isOpen = true;\n    console.warn(`AppSettingsService: Circuit breaker opened for ${key} due to stack depth error`);\n  } else {\n    state.failureCount++;\n    state.isOpen = state.failureCount >= MAX_FAILURES;\n    if (state.isOpen) {\n      console.warn(`AppSettingsService: Circuit breaker opened for ${key} after ${state.failureCount} failures`);\n    }\n  }\n  \n  state.lastFailureTime = Date.now();\n  circuitBreaker[key] = state;\n}\n\n// Type definitions for app settings\nexport interface AppSetting {\n  id: string;\n  category: string;\n  setting_key: string;\n  setting_value?: string;\n  setting_json?: Json;\n  description?: string;\n  data_type?: string;\n  is_required?: boolean;\n  is_active?: boolean;\n  created_at: string;\n  updated_at: string;\n  updated_by?: string;\n}\n\nexport interface AppSettingInsert {\n  category: string;\n  setting_key: string;\n  setting_value?: string;\n  setting_json?: Json;\n  description?: string;\n  data_type?: string;\n  is_required?: boolean;\n  is_active?: boolean;\n  updated_by?: string;\n}\n\nexport interface AppSettingUpdate {\n  category?: string;\n  setting_key?: string;\n  setting_value?: string;\n  setting_json?: Json;\n  description?: string;\n  data_type?: string;\n  is_required?: boolean;\n  is_active?: boolean;\n  updated_by?: string;\n}\n\n// Categories for organizing settings\nexport const SETTING_CATEGORIES = {\n  GENERAL: 'General',\n  SEO: 'SEO & Meta',\n  BRANDING: 'Branding & UI',\n  PERMISSIONS: 'Permissions & Roles',\n  AUTHENTICATION: 'Authentication & Security',\n  NOTIFICATIONS: 'Notifications & Communication',\n  PAYMENT: 'Payment & Finance',\n  INTEGRATIONS: 'Integrations',\n  MAINTENANCE: 'System Maintenance',\n  CONTENT: 'Custom Content'\n} as const;\n\nexport type SettingCategory = typeof SETTING_CATEGORIES[keyof typeof SETTING_CATEGORIES];\n\n// Service response interface\nexport interface AppSettingsServiceResponse<T = any> {\n  data: T | null;\n  error: string | null;\n  success: boolean;\n}\n\n// For localStorage fallback\nconst STORAGE_KEY = 'app_settings_fallback';\n\n// Allowed roles for app settings management\nconst ALLOWED_ROLES = ['super_admin', 'manager', 'agent', 'staff', 'hr_manager'];\n\n// Cache for database access status to prevent repeated 406 errors\nlet databaseAccessCache: {\n  accessible: boolean;\n  lastChecked: number;\n  cacheExpiry: number;\n} = {\n  accessible: true,\n  lastChecked: 0,\n  cacheExpiry: 5 * 60 * 1000 // 5 minutes\n};\n\nclass AppSettingsService {\n  // Check if database access is available (with caching to prevent repeated 406 errors)\n  static isDatabaseAccessible(): boolean {\n    const now = Date.now();\n    const cacheValid = (now - databaseAccessCache.lastChecked) < databaseAccessCache.cacheExpiry;\n    \n    if (cacheValid) {\n      return databaseAccessCache.accessible;\n    }\n    \n    // Cache expired, will be refreshed on next database operation\n    return true; // Optimistically assume accessible until proven otherwise\n  }\n\n  // Mark database as inaccessible (called when 406 errors occur)\n  static markDatabaseInaccessible(): void {\n    databaseAccessCache.accessible = false;\n    databaseAccessCache.lastChecked = Date.now();\n  }\n\n  // Mark database as accessible (called when operations succeed)\n  static markDatabaseAccessible(): void {\n    databaseAccessCache.accessible = true;\n    databaseAccessCache.lastChecked = Date.now();\n  }\n\n  // Check if database table exists\n  static async checkTableExists(): Promise<boolean> {\n    try {\n      // If database is marked as inaccessible due to stack depth errors, skip the check\n      if (!this.isDatabaseAccessible()) {\n        console.warn('AppSettingsService: Database marked as inaccessible, skipping table check');\n        return false;\n      }\n      \n      // Try to query the table directly with type assertion\n      const { error } = await (supabase as any)\n        .from('app_settings')\n        .select('id')\n        .limit(1);\n      \n      // If table doesn't exist or we get permission errors, return false\n      if (error) {\n        const errorMessage = error.message?.toLowerCase() || '';\n        const errorCode = error.code || '';\n        const isNetworkFetchError = errorMessage.includes('failed to fetch') || errorMessage.includes('network') || errorMessage.includes('fetch');\n        const isStackDepthError = errorCode === '54001' || /stack depth/i.test(errorMessage);\n        \n        // Stack depth errors: mark DB inaccessible to prevent repeated attempts\n        if (isStackDepthError) {\n          console.warn('AppSettingsService: Stack depth error detected during table check, marking database as inaccessible');\n          this.markDatabaseInaccessible();\n          return false;\n        }\n        \n        // Common error conditions that indicate table issues\n        if (\n          errorMessage.includes('does not exist') ||\n          errorMessage.includes('permission denied') ||\n          errorMessage.includes('not acceptable') ||\n          errorCode === '406' ||\n          errorCode === 'PGRST301' ||\n          errorCode === 'PGRST116'\n        ) {\n          console.warn('AppSettingsService: Database table not accessible, using localStorage fallback');\n          return false;\n        }\n\n        // Network connectivity issues: mark DB inaccessible to avoid repeated attempts\n        if (isNetworkFetchError) {\n          console.warn('AppSettingsService: Network error accessing database, falling back to localStorage');\n          this.markDatabaseInaccessible();\n          return false;\n        }\n      }\n      \n      return !error;\n    } catch (err) {\n      console.warn('AppSettingsService: Error checking table existence, using localStorage fallback:', err);\n      // On unexpected network/type errors, mark inaccessible to prevent repeated attempts\n      this.markDatabaseInaccessible();\n      return false;\n    }\n  }\n\n  // Check if user has permission to access app settings\n  static async checkPermissions(): Promise<boolean> {\n    try {\n      // Allow both authenticated and anonymous users to access app settings\n      // Anonymous users can save settings to localStorage/database with proper RLS policies\n      return true;\n    } catch (error) {\n      console.error('AppSettingsService: Error checking permissions:', error);\n      return false;\n    }\n  }\n\n  // Get all settings grouped by category\n  static async getAllSettings(): Promise<AppSettingsServiceResponse<Record<string, AppSetting[]>>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      const tableExists = await this.checkTableExists();\n      \n      if (tableExists) {\n        // Use database with type assertion\n        const { data, error } = await (supabase as any)\n          .from('app_settings')\n          .select('*')\n          .eq('is_active', true)\n          .order('category', { ascending: true })\n          .order('setting_key', { ascending: true });\n\n        if (error) {\n          console.error('AppSettingsService: Database error while fetching all settings:', error);\n          return {\n            data: null,\n            error: error.message ?? 'Database error',\n            success: false\n          };\n        }\n\n        // Group by category with proper typing\n        const settings = data as AppSetting[];\n        const grouped = settings.reduce((acc, setting) => {\n          if (!acc[setting.category]) {\n            acc[setting.category] = [];\n          }\n          acc[setting.category].push(setting);\n          return acc;\n        }, {} as Record<string, AppSetting[]>);\n\n        return {\n          data: grouped,\n          error: null,\n          success: true\n        };\n      } else {\n        return {\n          data: null,\n          error: 'Table app_settings does not exist',\n          success: false\n        };\n      }\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Get settings from localStorage (fallback)\n  static async getAllSettingsFromStorage(): Promise<AppSettingsServiceResponse<Record<string, AppSetting[]>>> {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      const parsed = raw ? JSON.parse(raw) : {};\n      return { data: parsed, error: null, success: true };\n    } catch (e: any) {\n      return { data: null, error: e?.message || 'Local storage error', success: false };\n    }\n  }\n\n  // Get settings by category\n  static async getSettingsByCategory(category: string): Promise<AppSettingsServiceResponse<AppSetting[]>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      const tableExists = await this.checkTableExists();\n      \n      if (tableExists) {\n        // Use database with type assertion\n        const { data, error } = await (supabase as any)\n          .from('app_settings')\n          .select('*')\n          .eq('category', category)\n          .eq('is_active', true)\n          .order('setting_key', { ascending: true });\n\n        if (error) {\n          console.error('AppSettingsService: Database error while fetching category settings:', error);\n          return {\n            data: null,\n            error: error.message ?? 'Database error',\n            success: false\n          };\n        }\n\n        return {\n          data: data as AppSetting[] || [],\n          error: null,\n          success: true\n        };\n      } else {\n        return {\n          data: null,\n          error: 'Table app_settings does not exist',\n          success: false\n        };\n      }\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Get settings by category from localStorage\n  static async getSettingsByCategoryFromStorage(category: string): Promise<AppSettingsServiceResponse<AppSetting[]>> {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      const parsed: Record<string, AppSetting[]> = raw ? JSON.parse(raw) : {};\n      const list = parsed[category] || [];\n      return { data: list, error: null, success: true };\n    } catch (e: any) {\n      return { data: null, error: e?.message || 'Local storage error', success: false };\n    }\n  }\n\n  // Get a specific setting\n  static async getSetting(category: string, settingKey: string): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      const tableExists = await this.checkTableExists();\n      \n      if (tableExists) {\n        // Use database with type assertion\n        const { data, error } = await (supabase as any)\n          .from('app_settings')\n          .select('*')\n          .eq('category', category)\n          .eq('setting_key', settingKey)\n          .eq('is_active', true)\n          .maybeSingle();\n\n        if (error) {\n          console.error('AppSettingsService: Database error while fetching setting', error);\n          return {\n            data: null,\n            error: error.message ?? 'Database error',\n            success: false\n          };\n        }\n\n        // No error: if no row found, return null without error\n        if (!data) {\n          return {\n            data: null,\n            error: null,\n            success: true\n          };\n        }\n        \n        return {\n          data: data as AppSetting,\n          error: null,\n          success: true\n        };\n      } else {\n        return {\n          data: null,\n          error: 'Table app_settings does not exist',\n          success: false\n        };\n      }\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Get a single setting by its UUID (database or storage fallback)\n  static async getSettingById(id: string): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      const tableExists = await this.checkTableExists();\n      if (tableExists) {\n        const { data, error } = await (supabase as any)\n          .from('app_settings')\n          .select('*')\n          .eq('id', id)\n          .maybeSingle();\n\n        if (error) {\n          console.error('AppSettingsService: Database error while fetching by ID', error);\n          return { data: null, error: error.message ?? 'Database error', success: false };\n        }\n        return {\n          data: (data as AppSetting) || null,\n          error: null,\n          success: true\n        };\n      } else {\n        return { data: null, error: 'Table app_settings does not exist', success: false };\n      }\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Get setting by ID from localStorage\n  static async getSettingByIdFromStorage(id: string): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      const parsed: Record<string, AppSetting[]> = raw ? JSON.parse(raw) : {};\n      for (const key of Object.keys(parsed)) {\n        const found = (parsed[key] || []).find(s => s.id === id);\n        if (found) return { data: found, error: null, success: true };\n      }\n      return { data: null, error: null, success: true };\n    } catch (e: any) {\n      return { data: null, error: e?.message || 'Local storage error', success: false };\n    }\n  }\n\n  // Get setting from localStorage\n  static async getSettingFromStorage(category: string, settingKey: string): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      const parsed: Record<string, AppSetting[]> = raw ? JSON.parse(raw) : {};\n      const list = parsed[category] || [];\n      const found = list.find(s => s.setting_key === settingKey) || null;\n      return { data: found, error: null, success: true };\n    } catch (e: any) {\n      return { data: null, error: e?.message || 'Local storage error', success: false };\n    }\n  }\n\n  // Create a new setting\n  static async createSetting(setting: AppSettingInsert): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    const circuitBreakerKey = getCircuitBreakerKey('create', setting.category, setting.setting_key);\n    \n    // Check circuit breaker before attempting operation\n    if (!shouldAttemptOperation(circuitBreakerKey)) {\n      console.warn(`AppSettingsService: Circuit breaker open for create operation, using localStorage fallback`);\n      const { session } = await authHelpers.getSession();\n      const userId = session?.user?.id;\n      return await this.createSettingInStorage(setting, userId);\n    }\n\n    // If database is marked as inaccessible due to stack depth errors, use localStorage immediately\n    if (!this.isDatabaseAccessible()) {\n      console.warn('AppSettingsService: Database marked as inaccessible due to stack depth errors, using localStorage');\n      const { session } = await authHelpers.getSession();\n      const userId = session?.user?.id;\n      return await this.createSettingInStorage(setting, userId);\n    }\n\n    try {\n      const hasPermission = await this.checkPermissions();\n      const { session } = await authHelpers.getSession();\n      const userId = session?.user?.id;\n      if (!hasPermission) {\n        return { data: null, error: 'Insufficient permissions', success: false };\n      }\n      const tableExists = await this.checkTableExists();\n      \n      if (tableExists) {\n        // Use REST upsert directly to avoid RPC recursion causing 54001 errors\n        const upsertPayload = { ...setting, updated_by: userId };\n\n        const rest = await (supabase as any)\n          .from('app_settings')\n          .upsert(upsertPayload, { onConflict: 'category,setting_key' })\n          .select()\n          .single();\n\n        let data: any = rest.data;\n        let error: any = rest.error;\n\n        // If stack recursion error occurs, retry without updated_by to bypass potential triggers\n        if (error && (error.code === '54001' || /stack depth/i.test(error.message || ''))) {\n          console.warn('AppSettingsService: Stack depth error detected, retrying without updated_by');\n          const retry = await (supabase as any)\n            .from('app_settings')\n            .upsert({ ...upsertPayload, updated_by: null }, { onConflict: 'category,setting_key' })\n            .select()\n            .single();\n          data = retry.data;\n          error = retry.error;\n        }\n\n        if (error) {\n          const errObj = error as any;\n          // If persistent stack depth errors, fall back to local storage and mark DB inaccessible\n          if (errObj?.code === '54001' || /stack depth/i.test(errObj?.message || '')) {\n            console.warn('AppSettingsService: Stack depth error detected. Falling back to localStorage.');\n            this.markDatabaseInaccessible();\n            recordFailure(circuitBreakerKey, error);\n            const fallback = await this.createSettingInStorage(setting, userId);\n            return fallback;\n          }\n          console.warn('AppSettingsService: Database error while creating setting:', {\n            code: errObj?.code,\n            message: errObj?.message,\n            details: errObj?.details,\n            hint: errObj?.hint\n          });\n          recordFailure(circuitBreakerKey, error);\n          return { data: null, error: errObj?.message ?? 'Database error', success: false };\n        }\n\n        recordSuccess(circuitBreakerKey);\n        return { data: data as AppSetting, error: null, success: true };\n      } else {\n        return { data: null, error: 'Table app_settings does not exist', success: false };\n      }\n    } catch (error: any) {\n      recordFailure(circuitBreakerKey, error);\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Create setting in localStorage\n  static async createSettingInStorage(setting: AppSettingInsert, _userId?: string): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      const parsed: Record<string, AppSetting[]> = raw ? JSON.parse(raw) : {};\n      const now = new Date().toISOString();\n      const id = `local-${setting.category}:${setting.setting_key}`;\n      const record: AppSetting = {\n        id,\n        category: setting.category,\n        setting_key: setting.setting_key,\n        setting_value: setting.setting_value,\n        setting_json: setting.setting_json,\n        description: setting.description,\n        data_type: setting.data_type,\n        is_required: setting.is_required ?? false,\n        is_active: setting.is_active ?? true,\n        created_at: now,\n        updated_at: now,\n        updated_by: _userId || undefined,\n      };\n      const list = parsed[setting.category] || [];\n      const idx = list.findIndex(s => s.setting_key === setting.setting_key);\n      if (idx >= 0) list[idx] = { ...list[idx], ...record, updated_at: now };\n      else list.push(record);\n      parsed[setting.category] = list;\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(parsed));\n      return { data: record, error: null, success: true };\n    } catch (e: any) {\n      return { data: null, error: e?.message || 'Local storage error', success: false };\n    }\n  }\n\n  // Update an existing setting\n  static async updateSetting(\n    category: string, \n    settingKey: string, \n    updates: AppSettingUpdate\n  ): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    const circuitBreakerKey = getCircuitBreakerKey('update', category, settingKey);\n    \n    // Check circuit breaker before attempting operation\n    if (!shouldAttemptOperation(circuitBreakerKey)) {\n      console.warn(`AppSettingsService: Circuit breaker open for update operation, using localStorage fallback`);\n      const { session } = await authHelpers.getSession();\n      const userId = session?.user?.id;\n      return await this.updateSettingInStorage(category, settingKey, updates, userId);\n    }\n\n    // If database is marked as inaccessible due to stack depth errors, use localStorage immediately\n    if (!this.isDatabaseAccessible()) {\n      console.warn('AppSettingsService: Database marked as inaccessible due to stack depth errors, using localStorage');\n      const { session } = await authHelpers.getSession();\n      const userId = session?.user?.id;\n      return await this.updateSettingInStorage(category, settingKey, updates, userId);\n    }\n\n    try {\n      const hasPermission = await this.checkPermissions();\n      const { session } = await authHelpers.getSession();\n      const userId = session?.user?.id;\n      if (!hasPermission) {\n        return { data: null, error: 'Insufficient permissions', success: false };\n      }\n      const tableExists = await this.checkTableExists();\n      \n      if (tableExists) {\n        // Use REST upsert directly to avoid RPC recursion causing 54001 errors\n        const upsertPayload = {\n          category,\n          setting_key: settingKey,\n          ...updates,\n          updated_by: userId,\n        };\n\n        const rest = await (supabase as any)\n          .from('app_settings')\n          .upsert(upsertPayload, { onConflict: 'category,setting_key' })\n          .select()\n          .single();\n\n        let data: any = rest.data;\n        let error: any = rest.error;\n\n        // If recursion error occurs, retry without updated_by to bypass potential triggers\n        if (error && (error.code === '54001' || /stack depth/i.test(error.message || ''))) {\n          console.warn('AppSettingsService: Stack depth error detected, retrying without updated_by');\n          const retry = await (supabase as any)\n            .from('app_settings')\n            .upsert({ ...upsertPayload, updated_by: null }, { onConflict: 'category,setting_key' })\n            .select()\n            .single();\n          data = retry.data;\n          error = retry.error;\n        }\n\n        if (error) {\n          const errObj = error as any;\n          // Stack depth recursion: fall back to localStorage\n          if (errObj?.code === '54001' || /stack depth/i.test(errObj?.message || '')) {\n            console.warn('AppSettingsService: Stack depth error detected during update. Falling back to localStorage.');\n            this.markDatabaseInaccessible();\n            recordFailure(circuitBreakerKey, error);\n            const fallback = await this.updateSettingInStorage(category, settingKey, updates, userId);\n            return fallback;\n          }\n          console.warn('Database error while updating setting:', {\n            code: errObj?.code,\n            message: errObj?.message,\n            details: errObj?.details,\n            hint: errObj?.hint,\n          });\n          recordFailure(circuitBreakerKey, error);\n          return { data: null, error: errObj?.message ?? 'Database error', success: false };\n        }\n\n        recordSuccess(circuitBreakerKey);\n        return {\n          data: data as AppSetting,\n          error: null,\n          success: true,\n        };\n      } else {\n        return { data: null, error: 'Table app_settings does not exist', success: false };\n      }\n    } catch (error: any) {\n      recordFailure(circuitBreakerKey);\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Update setting by ID\n  static async updateSettingById(\n    id: string,\n    updates: AppSettingUpdate\n  ): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      const { session } = await authHelpers.getSession();\n      const userId = session?.user?.id;\n      if (!hasPermission) {\n        return { data: null, error: 'Insufficient permissions', success: false };\n      }\n      const tableExists = await this.checkTableExists();\n      if (tableExists) {\n        const { data, error } = await (supabase as any)\n          .from('app_settings')\n          .update({\n            ...updates,\n            updated_by: userId\n          })\n          .eq('id', id)\n          .select()\n          .maybeSingle();\n\n        if (error) {\n          if ((error as any)?.code === '54001' || /stack depth/i.test((error as any)?.message || '')) {\n            console.warn('AppSettingsService: Stack depth error detected during update by ID. Falling back to localStorage.');\n            this.markDatabaseInaccessible();\n            const fallback = await this.updateSettingByIdInStorage(id, updates, userId);\n            return fallback;\n          }\n          console.warn('Database error while updating by ID:', error);\n          return { data: null, error: (error as any).message ?? 'Database error', success: false };\n        }\n\n        return {\n          data: (data as AppSetting) || null,\n          error: null,\n          success: true\n        };\n      } else {\n        return { data: null, error: 'Table app_settings does not exist', success: false };\n      }\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Update setting by ID in localStorage\n  static async updateSettingByIdInStorage(\n    id: string,\n    updates: AppSettingUpdate,\n    _userId?: string\n  ): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      const parsed: Record<string, AppSetting[]> = raw ? JSON.parse(raw) : {};\n      let updated: AppSetting | null = null;\n      const now = new Date().toISOString();\n      for (const category of Object.keys(parsed)) {\n        const list = parsed[category] || [];\n        const idx = list.findIndex(s => s.id === id);\n        if (idx >= 0) {\n          list[idx] = {\n            ...list[idx],\n            ...updates,\n            updated_at: now,\n            updated_by: _userId || list[idx].updated_by,\n          } as AppSetting;\n          updated = list[idx];\n          parsed[category] = list;\n          break;\n        }\n      }\n      if (!updated) return { data: null, error: 'Not found', success: false };\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(parsed));\n      return { data: updated, error: null, success: true };\n    } catch (e: any) {\n      return { data: null, error: e?.message || 'Local storage error', success: false };\n    }\n  }\n\n  // Update setting in localStorage\n  static async updateSettingInStorage(\n    category: string, \n    settingKey: string, \n    updates: AppSettingUpdate,\n    _userId?: string\n  ): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      const parsed: Record<string, AppSetting[]> = raw ? JSON.parse(raw) : {};\n      const now = new Date().toISOString();\n      const list = parsed[category] || [];\n      const idx = list.findIndex(s => s.setting_key === settingKey);\n      if (idx >= 0) {\n        const updated: AppSetting = {\n          ...list[idx],\n          ...updates,\n          updated_at: now,\n          updated_by: _userId || list[idx].updated_by,\n        } as AppSetting;\n        list[idx] = updated;\n        parsed[category] = list;\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(parsed));\n        return { data: updated, error: null, success: true };\n      } else {\n        // Create new if missing\n        const record: AppSetting = {\n          id: `local-${category}:${settingKey}`,\n          category,\n          setting_key: settingKey,\n          setting_value: updates.setting_value,\n          setting_json: updates.setting_json,\n          description: updates.description,\n          data_type: updates.data_type,\n          is_required: updates.is_required ?? false,\n          is_active: updates.is_active ?? true,\n          created_at: now,\n          updated_at: now,\n          updated_by: _userId,\n        };\n        list.push(record);\n        parsed[category] = list;\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(parsed));\n        return { data: record, error: null, success: true };\n      }\n    } catch (e: any) {\n      return { data: null, error: e?.message || 'Local storage error', success: false };\n    }\n  }\n\n  // Delete a setting\n  static async deleteSetting(category: string, settingKey: string): Promise<AppSettingsServiceResponse<boolean>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return { data: false, error: 'Insufficient permissions', success: false };\n      }\n\n      const tableExists = await this.checkTableExists();\n      \n      if (tableExists) {\n        // Use database with type assertion\n        const { error } = await (supabase as any)\n          .from('app_settings')\n          .delete()\n          .eq('category', category)\n          .eq('setting_key', settingKey);\n\n        if (error) {\n          console.error('Database error while deleting setting:', error);\n          return { data: false, error: error.message ?? 'Database error', success: false };\n        }\n\n        return {\n          data: true,\n          error: null,\n          success: true\n        };\n      } else {\n        return { data: false, error: 'Table app_settings does not exist', success: false };\n      }\n    } catch (error: any) {\n      return {\n        data: false,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Delete setting from localStorage\n  static async deleteSettingFromStorage(category: string, settingKey: string): Promise<AppSettingsServiceResponse<boolean>> {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      const parsed: Record<string, AppSetting[]> = raw ? JSON.parse(raw) : {};\n      const list = parsed[category] || [];\n      const next = list.filter(s => s.setting_key !== settingKey);\n      parsed[category] = next;\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(parsed));\n      return { data: true, error: null, success: true };\n    } catch (e: any) {\n      return { data: false, error: e?.message || 'Local storage error', success: false };\n    }\n  }\n\n  // Get setting value directly\n  static async getSettingValue(category: string, settingKey: string): Promise<any> {\n    const result = await this.getSetting(category, settingKey);\n    if (result.success && result.data) {\n      return result.data.setting_json || result.data.setting_value;\n    }\n    return null;\n  }\n\n  // Get all categories\n  static async getCategories(): Promise<AppSettingsServiceResponse<string[]>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      const tableExists = await this.checkTableExists();\n      \n      if (tableExists) {\n        // Use database with type assertion\n        const { data, error } = await (supabase as any)\n          .from('app_settings')\n          .select('category')\n          .eq('is_active', true);\n\n        if (error) {\n          console.error('Database error while fetching categories:', error);\n          return { data: null, error: error.message ?? 'Database error', success: false };\n        }\n\n        const settings = data as { category: string }[];\n        const categories = [...new Set(settings.map(s => s.category))];\n\n        return {\n          data: categories,\n          error: null,\n          success: true\n        };\n      } else {\n        return { data: null, error: 'Table app_settings does not exist', success: false };\n      }\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Get categories from localStorage\n  static async getCategoriesFromStorage(): Promise<AppSettingsServiceResponse<string[]>> {\n    // Supabase-only: delegate to getCategories\n    return this.getCategories();\n  }\n}\n\n// Export both the class and an instance\nexport { AppSettingsService };\nexport const appSettingsService = new AppSettingsService();\n\n// Convenience helpers to consolidate logic in one place\nexport class AppSettingsHelpers {\n  // Upsert a setting: create if missing, otherwise update\n  static async upsertSetting(setting: AppSettingInsert): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    const existing = await AppSettingsService.getSetting(setting.category, setting.setting_key);\n    if (existing.success && existing.data) {\n      return AppSettingsService.updateSetting(setting.category, setting.setting_key, {\n        setting_value: setting.setting_value,\n        setting_json: setting.setting_json,\n        description: setting.description,\n        data_type: setting.data_type,\n        is_required: setting.is_required,\n        is_active: setting.is_active\n      });\n    }\n    return AppSettingsService.createSetting(setting);\n  }\n\n  // Ensure a setting exists with a default value; returns the setting\n  static async ensureSettingValue(\n    category: string,\n    settingKey: string,\n    defaultValue: string | Json\n  ): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    const current = await AppSettingsService.getSetting(category, settingKey);\n    if (current.success && current.data) {\n      return current as AppSettingsServiceResponse<AppSetting | null>;\n    }\n    return this.upsertSetting({\n      category,\n      setting_key: settingKey,\n      ...(typeof defaultValue === 'string'\n        ? { setting_value: defaultValue as string }\n        : { setting_json: defaultValue as Json })\n    });\n  }\n}","import { supabase, authHelpers, adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\nimport { User } from '@/types/User';\n\nexport interface AuthUser {\n  id: string;\n  email: string;\n  name: string;\n  role: string;\n  department: string;\n  phone?: string;\n  status: 'active' | 'inactive' | 'suspended';\n  position: string;\n  employeeId?: string;\n  employee_id?: string;\n  company_name?: string;\n  city?: string;\n  country?: string;\n  avatar?: string;\n  // Optional flag stored in user metadata to enforce password change\n  must_change_password?: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface AuthResponse {\n  user: User | null;\n  error: string | null;\n  session: any;\n}\n\n// Helper function to get permissions based on role\nconst getPermissionsByRole = (role: string): string[] => {\n  switch (role) {\n    case 'super_admin':\n      // Full administrative access\n      return ['*', 'manage_users', 'manage_settings', 'queries.*', 'staff.*', 'hr.*', 'attendance.*', 'payroll.*'];\n    case 'admin':\n      return ['read', 'write', 'delete', 'manage_users', 'manage_settings'];\n    case 'manager':\n      return ['read', 'write', 'manage_team'];\n    case 'hr_manager':\n      // HR managers have HR-focused capabilities\n      return ['staff.*', 'hr.*', 'attendance.*', 'payroll.*', 'queries.view'];\n    case 'staff':\n      // Baseline staff capabilities\n      return ['queries.view', 'bookings.view'];\n    case 'agent':\n      return ['read', 'write'];\n    case 'support':\n      return ['read', 'write', 'manage_tickets'];\n    default:\n      return ['read'];\n  }\n};\n\nconst convertToAppUser = (authUser: any): User => {\n  return {\n    id: authUser.id,\n    email: authUser.email,\n    name: authUser.name || authUser.email,\n    role: authUser.role || 'agent',\n    department: authUser.department,\n    phone: authUser.phone || '',\n    status: authUser.status || 'active',\n    position: authUser.position || authUser.role || 'Agent',\n    employeeId: authUser.employeeId ?? authUser.employee_id,\n    avatar: authUser.avatar || '',\n    permissions: getPermissionsByRole(authUser.role || 'agent'),\n  };\n};\n\nexport class AuthService {\n  /**\n   * Enhanced sign-in that properly handles Supabase-invited agents\n   */\n  static async signIn(email: string, password: string): Promise<AuthResponse> {\n    try {\n      console.log(' Attempting sign-in for:', email);\n      \n      // First try Supabase Auth\n      const { data: authData, error: authError } = await authHelpers.signIn(email, password);\n      \n      if (!authError && authData.user) {\n        console.log(' Supabase Auth successful for:', authData.user.email);\n        \n        // Fetch profile directly; if missing, self-heal by upserting minimal profile\n        const { data: profileRow, error: profileErr } = await supabase\n          .from('profiles')\n          .select('*')\n          .eq('id', authData.user.id)\n          .maybeSingle();\n\n        const profileData = profileRow || await AuthService.ensureProfileExists(authData.user);\n\n        if (profileData) {\n          console.log(' Profile resolved:', profileData.name);\n          \n          // For agents with Supabase Auth, sync their password to agent_credentials\n          if ((profileData as any).role === 'agent') {\n            await this.syncSupabasePasswordToAgentCredentials(authData.user.id, email, password);\n          }\n          \n          // Convert to app user format\n          const appUser = convertToAppUser(profileData);\n          return {\n            user: appUser,\n            error: null,\n            session: authData.session\n          };\n        } else {\n          console.log(' Profile not found for user:', authData.user.id);\n        }\n      } else {\n        console.log(' Supabase Auth error:', authError?.message);\n      }\n\n      // If Supabase Auth failed or profile not found, try DB-backed agent authentication\n      console.log(' Trying DB-backed agent authentication');\n      const agentResponse = await this.tryAgentLogin(email, password);\n      if (agentResponse && agentResponse.user) {\n        console.log(' DB-backed agent authentication successful');\n        return agentResponse;\n      }\n\n      // If both methods failed, return appropriate error\n      return {\n        user: null,\n        error: authError?.message || 'Authentication failed',\n        session: null\n      };\n    } catch (error) {\n      console.error(' Sign-in error:', error);\n      return {\n        user: null,\n        error: error instanceof Error ? error.message : 'Authentication failed',\n        session: null\n      };\n    }\n  }\n\n  /**\n   * Check if a user exists by email using the Admin Auth client.\n   * Returns { exists, id } where id is the Supabase Auth user id if found.\n   */\n  static async userExistsByEmail(email: string): Promise<{ exists: boolean; id?: string }> {\n    try {\n      if (!email) return { exists: false };\n      const target = String(email).trim().toLowerCase();\n\n      // Prefer admin listUsers when available\n      if (isAdminClientConfigured && adminSupabase) {\n        const adminAuth = (adminSupabase as any).auth.admin;\n        const { data, error } = await adminAuth.listUsers();\n        if (error) {\n          console.warn('Error listing users for email check:', error.message || error);\n        } else {\n          const match = (data?.users || []).find((u: any) => String(u.email || '').toLowerCase() === target);\n          if (match) return { exists: true, id: match.id };\n        }\n      }\n\n      // Fallback: call RPC if available\n      try {\n        const { data: rpcData, error: rpcErr } = await (supabase as any).rpc('check_user_exists_by_email', { p_email: target });\n        if (rpcErr) {\n          // Silently ignore RPC errors and return false\n          // console.warn('RPC email check error:', rpcErr.message || rpcErr);\n          return { exists: false };\n        }\n        if (rpcData && typeof rpcData === 'object') {\n          const exists = !!(rpcData as any).exists;\n          const id = (rpcData as any).id;\n          return { exists, id };\n        }\n      } catch {}\n\n      return { exists: false };\n    } catch (e) {\n      console.warn('userExistsByEmail error:', e);\n      return { exists: false };\n    }\n  }\n\n  /**\n   * Check if a user exists by phone using Admin Auth and user metadata.\n   * Normalizes to digits-only when comparing.\n   */\n  static async userExistsByPhone(phone: string): Promise<{ exists: boolean; id?: string }> {\n    try {\n      if (!phone) return { exists: false };\n      const normalize = (p: string) => String(p || '').replace(/\\D/g, '');\n      const target = normalize(phone);\n      if (!target) return { exists: false };\n\n      // Prefer admin listUsers when available\n      if (isAdminClientConfigured && adminSupabase) {\n        const adminAuth = (adminSupabase as any).auth.admin;\n        const { data, error } = await adminAuth.listUsers();\n        if (error) {\n          console.warn('Error listing users for phone check:', error.message || error);\n        } else {\n          const match = (data?.users || []).find((u: any) => {\n            const authPhone = normalize(u.phone || '');\n            const metaPhone = normalize(u.user_metadata?.phone || '');\n            return authPhone === target || metaPhone === target;\n          });\n          if (match) return { exists: true, id: match.id };\n        }\n      }\n\n      // Fallback: call RPC if available\n      try {\n        const { data: rpcData, error: rpcErr } = await (supabase as any).rpc('check_user_exists_by_phone', { p_phone: target });\n        if (rpcErr) {\n          // console.warn('RPC phone check error:', rpcErr.message || rpcErr);\n          return { exists: false };\n        }\n        if (rpcData && typeof rpcData === 'object') {\n          const exists = !!(rpcData as any).exists;\n          const id = (rpcData as any).id;\n          return { exists, id };\n        }\n      } catch {}\n\n      return { exists: false };\n    } catch (e) {\n      console.warn('userExistsByPhone error:', e);\n      return { exists: false };\n    }\n  }\n\n  /**\n   * Sync Supabase password to agent_credentials table for fallback authentication\n   */\n  private static async syncSupabasePasswordToAgentCredentials(\n    userId: string, \n    email: string, \n    password: string\n  ): Promise<void> {\n    try {\n      // Import AgentManagementService here to avoid circular dependency\n      const { AgentManagementService } = await import('./agentManagementService');\n      \n      // Check if agent credentials already exist and are not temporary\n      const { data: existingCreds, error: credsError } = await (supabase as any)\n        .from('agent_credentials')\n        .select('username, is_temporary, agent_id')\n        .eq('username', email)\n        .single();\n\n      if (credsError && credsError.code !== 'PGRST116') {\n        // PGRST116 is \"not found\" error, which is expected if no credentials exist\n        console.warn(' Error checking existing credentials:', credsError.message);\n        return;\n      }\n\n      // Only sync if credentials don't exist or are temporary\n      if (!existingCreds || (existingCreds as any)?.is_temporary) {\n        await AgentManagementService.setAgentCredentials(userId, email, password, false);\n        console.log(' Synced Supabase password to agent_credentials for:', email);\n      } else {\n        console.log(' Agent credentials already exist and are not temporary for:', email);\n      }\n    } catch (error) {\n      console.warn(' Failed to sync password to agent_credentials:', error);\n      // Don't fail the login if sync fails\n    }\n  }\n\n  static async tryAgentLogin(username: string, password: string): Promise<AuthResponse | null> {\n    try {\n      // Cast client for RPC call not present in generated Database types\n      const { data, error } = await (supabase as any).rpc('authenticate_managed_agent', {\n        p_username: username,\n        p_password: password\n      });\n\n      if (error) {\n        console.log(' Agent RPC auth error:', error.message || error);\n        return {\n          user: null,\n          error: error.message || 'Agent authentication failed',\n          session: null\n        };\n      }\n\n      if (data && (data as any).ok) {\n        const agent = (data as any).agent;\n\n        const appUser = AuthService.convertAgentToAppUser(agent);\n        return {\n          user: appUser,\n          error: null,\n          session: null\n        };\n      }\n\n      // If RPC returned ok=false, surface its error message\n      if (data && (data as any).error) {\n        const errMsg = (data as any).error;\n        // Provide a friendly message for gating\n        const message = errMsg === 'Password change required'\n          ? 'Password change required. Please use the invite link or reset your password.'\n          : errMsg;\n        return {\n          user: null,\n          error: message,\n          session: null\n        };\n      }\n\n      return {\n        user: null,\n        error: 'Agent authentication failed',\n        session: null\n      };\n    } catch (err) {\n      console.log(' Agent login fallback error:', err);\n      return {\n        user: null,\n        error: 'Agent authentication failed',\n        session: null\n      };\n    }\n  }\n\n  // Convert agent basic info to app User type\n  static convertAgentToAppUser(agent: { id: string; name: string; email: string; role: string }): User {\n    return {\n      id: agent.id,\n      email: agent.email,\n      name: agent.name || agent.email,\n      role: 'agent',\n      department: 'Sales',\n      status: 'active' as const,\n      position: 'Travel Agent',\n      phone: '',\n      avatar: '',\n      permissions: getPermissionsByRole('agent'),\n    };\n  }\n\n  static async signUp(email: string, password: string, userData: Partial<AuthUser>): Promise<AuthResponse> {\n    try {\n      const { data, error } = await authHelpers.signUp(email, password, {\n        name: userData.name,\n        role: userData.role || 'agent',\n        department: userData.department, \n        phone: userData.phone,\n        position: userData.position || userData.role || 'Agent',\n        employee_id: userData.employee_id ?? userData.employeeId,\n        company_name: userData.company_name,\n        city: userData.city,\n        country: userData.country,\n        // Forward optional metadata control for password change requirement\n        must_change_password: userData.must_change_password === true,\n      });\n  \n      if (error) {\n        // Fallback: attempt admin user creation if configured\n        const msg = error.message || '';\n        const isServerSaveError = msg.toLowerCase().includes('database error saving new user');\n        if (isServerSaveError && isAdminClientConfigured && adminSupabase) {\n          try {\n            const { data: adminCreate, error: adminErr } = await adminSupabase.auth.admin.createUser({\n              email,\n              password,\n              user_metadata: {\n                name: userData.name,\n                role: userData.role || 'agent',\n                department: userData.department,\n                phone: userData.phone,\n                position: userData.position || userData.role || 'Agent',\n                employee_id: userData.employee_id ?? userData.employeeId,\n                company_name: userData.company_name,\n                city: userData.city,\n                country: userData.country,\n                must_change_password: userData.must_change_password === true,\n              }\n            });\n  \n            if (!adminErr && adminCreate?.user?.id) {\n              // Create profile using admin client to avoid RLS\n              await adminSupabase\n                .from('profiles')\n                .insert([{ \n                  id: adminCreate.user.id,\n                  name: userData.name || email,\n                  email,\n                  role: userData.role || 'agent',\n                  department: userData.department,\n                  phone: userData.phone,\n                  status: 'active',\n                  position: userData.position || userData.role || 'Agent',\n                  employee_id: userData.employee_id ?? userData.employeeId,\n                  company_name: userData.company_name,\n                  city: userData.city,\n                  country: userData.country,\n                  must_change_password: userData.must_change_password === true,\n                }]);\n  \n              const appUser: User = {\n                id: adminCreate.user.id,\n                email,\n                name: userData.name || email,\n                role: userData.role || 'agent',\n                department: userData.department,\n                phone: userData.phone || '',\n                status: 'inactive',\n                position: userData.position || userData.role || 'Agent',\n                employeeId: userData.employee_id ?? userData.employeeId,\n                permissions: getPermissionsByRole(userData.role || 'agent'),\n                avatar: '',\n              };\n  \n              return {\n                user: appUser,\n                error: null,\n                session: null\n              };\n            }\n          } catch (adminCreateEx) {\n            // fall through to return original error\n          }\n        }\n  \n        return {\n          user: null,\n          error: error.message,\n          session: null\n        };\n      }\n  \n      if (data.user) {\n        // Upsert profile idempotently (trigger may already have created it)\n        // Use admin client when available to bypass RLS; otherwise rely on trigger only\n        try {\n          if (isAdminClientConfigured && adminSupabase) {\n            const { error: adminProfileErr } = await adminSupabase\n              .from('profiles')\n              .upsert([\n                {\n                  id: data.user.id,\n                  name: userData.name || email,\n                  email: email,\n                  role: userData.role || 'agent',\n                  department: userData.department,\n                  phone: userData.phone,\n                  status: 'active',\n                  position: userData.position || userData.role || 'Agent',\n                  employee_id: userData.employee_id ?? userData.employeeId,\n                  company_name: userData.company_name,\n                  city: userData.city,\n                  country: userData.country,\n                }\n              ], { onConflict: 'id' });\n            if (adminProfileErr) {\n              console.warn('Admin profile upsert error (non-blocking):', adminProfileErr);\n            }\n          } else {\n            // No admin client; proactively ensure profile exists via SECURITY DEFINER RPC\n            try {\n              await AuthService.ensureProfileExists(data.user);\n            } catch (ensureEx) {\n              console.warn('ensureProfileExists after signUp failed (non-blocking):', ensureEx);\n            }\n          }\n        } catch (profileUpsertEx) {\n          console.warn('Profile upsert exception (non-blocking):', profileUpsertEx);\n        }\n\n        // Prefer returning the ensured profile if available\n        let ensuredUser: any = null;\n        try {\n          ensuredUser = await AuthService.ensureProfileExists(data.user);\n        } catch {}\n\n        const appUser: User = ensuredUser\n          ? convertToAppUser(ensuredUser)\n          : {\n              id: data.user.id,\n              email: email,\n              name: userData.name || email,\n              role: userData.role || 'agent',\n              department: userData.department,\n              phone: userData.phone || '',\n              status: 'active',\n              position: userData.position || userData.role || 'Agent',\n              employeeId: userData.employee_id ?? userData.employeeId,\n              permissions: getPermissionsByRole(userData.role || 'agent'),\n              avatar: '',\n            };\n  \n        return {\n          user: appUser,\n          error: null,\n          session: data.session\n        };\n      }\n  \n      return {\n        user: null,\n        error: 'Sign up failed',\n        session: null\n      };\n    } catch (error) {\n      return {\n        user: null,\n        error: error instanceof Error ? error.message : 'Sign up failed',\n        session: null\n      };\n    }\n  }\n\n  /**\n   * Sign in with Google OAuth and assign agent role\n   */\n  static async signInWithGoogle(role: string = 'agent'): Promise<AuthResponse> {\n    try {\n      console.log(' Attempting Google OAuth sign-in with role:', role);\n      \n      // Initiate Google OAuth flow\n      const { data, error } = await authHelpers.signInWithGoogle(role);\n      \n      if (error) {\n        console.error(' Google OAuth error:', error);\n        return {\n          user: null,\n          error: error.message || 'Google authentication failed',\n          session: null\n        };\n      }\n\n      // The OAuth flow will redirect to Google and back to /login\n      // The session will be handled by the auth state change listener\n      console.log(' Google OAuth initiated successfully');\n      \n      return {\n        user: null, // User will be set by auth state change listener\n        error: null,\n        session: null // Session will be set after redirect\n      };\n    } catch (error) {\n      console.error(' Google OAuth error:', error);\n      return {\n        user: null,\n        error: error instanceof Error ? error.message : 'Google authentication failed',\n        session: null\n      };\n    }\n  }\n\n  static async signOut(): Promise<{ error: string | null }> {\n    try {\n      const { error } = await authHelpers.signOut();\n      return { error: error?.message || null };\n    } catch (error) {\n      return { error: error instanceof Error ? error.message : 'Sign out failed' };\n    }\n  }\n\n  static async getCurrentSession(): Promise<{ user: User | null; session: any; error: string | null }> {\n    try {\n      const { data: { session }, error } = await supabase.auth.getSession();\n      \n      if (error) {\n        return { user: null, session: null, error: error.message };\n      }\n\n      if (!session?.user) {\n        return { user: null, session: null, error: null };\n      }\n\n      // Fetch current user's profile directly; self-heal if missing\n      const { data: profileRow, error: profileErr } = await supabase\n        .from('profiles')\n        .select('*')\n        .eq('id', (session.user as any).id)\n        .maybeSingle();\n\n      console.log(' getCurrentSession - Profile query result:', { profileRow, profileErr });\n\n      const profileData: any = profileRow || await AuthService.ensureProfileExists(session.user);\n      if (!profileData) {\n        console.log(' Profile not found for user:', (session.user as any).id);\n        return { user: null, session: session, error: 'Profile not found' };\n      }\n      \n      console.log(' Profile data found:', profileData.id, 'with role:', profileData.role);\n\n      // Post-login enrichment: if metadata contains fields missing in profile, persist them\n      try {\n        const meta: any = (session.user as any)?.user_metadata || (session.user as any)?.app_metadata || {};\n        const updates: Partial<AuthUser> = {};\n        const hasValue = (v: any) => v !== undefined && v !== null && String(v).trim() !== '';\n\n        if (!hasValue((profileData as any)?.name) && hasValue(meta.name)) {\n          updates.name = meta.name;\n        }\n        if (!hasValue((profileData as any)?.phone) && hasValue(meta.phone)) {\n          updates.phone = meta.phone;\n        }\n        const metaCompany = (hasValue(meta.company_name) ? meta.company_name : (hasValue(meta.agency_name) ? meta.agency_name : undefined));\n        if (!hasValue((profileData as any)?.company_name) && hasValue(metaCompany)) {\n          updates.company_name = metaCompany as any;\n        }\n        if (!hasValue((profileData as any)?.city) && hasValue(meta.city)) {\n          updates.city = meta.city;\n        }\n        if (!hasValue((profileData as any)?.country) && hasValue(meta.country)) {\n          updates.country = meta.country;\n        }\n        // Ensure email stored in profiles if missing\n        const authEmail = (session.user as any)?.email;\n        if (!hasValue((profileData as any)?.email) && hasValue(authEmail)) {\n          updates.email = authEmail as any;\n        }\n\n        if (Object.keys(updates).length > 0) {\n          await AuthService.updateProfile((session.user as any).id, updates);\n          // Merge updates into profileData for return\n          Object.assign(profileData as any, updates);\n        }\n      } catch (enrichErr) {\n        console.warn(' Profile enrichment skipped:', enrichErr);\n      }\n\n      const appUser = convertToAppUser(profileData);\n      return { user: appUser, session: session, error: null };\n    } catch (error) {\n      return { \n        user: null, \n        session: null, \n        error: error instanceof Error ? error.message : 'Session check failed' \n      };\n    }\n  }\n\n  static async resetPassword(email: string): Promise<{ error: string | null }> {\n    try {\n      const { error } = await authHelpers.resetPassword(email);\n      return { error: error?.message || null };\n    } catch (error) {\n      return { error: error instanceof Error ? error.message : 'Password reset failed' };\n    }\n  }\n\n  /**\n   * Re-authenticate the current user using their current password before sensitive actions.\n   */\n  static async reauthenticateWithPassword(currentPassword: string): Promise<{ ok: boolean; error?: string }> {\n    try {\n      const { data: { user }, error: getUserError } = await supabase.auth.getUser();\n      if (getUserError || !user || !user.email) {\n        return { ok: false, error: 'User not authenticated' };\n      }\n      const { error } = await supabase.auth.signInWithPassword({\n        email: user.email as string,\n        password: currentPassword,\n      });\n      if (error) {\n        return { ok: false, error: error.message || 'Invalid current password' };\n      }\n      return { ok: true };\n    } catch (e) {\n      return { ok: false, error: e instanceof Error ? e.message : 'Re-authentication failed' };\n    }\n  }\n\n  /**\n   * Enhanced password update that handles both Supabase and DB-backed agents\n   */\n  static async updatePassword(newPassword: string): Promise<{ error: string | null }> {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      \n      if (!user) {\n        return { error: 'User not authenticated' };\n      }\n\n      // Determine role and email without querying profiles to avoid RLS recursion\n      const meta: any = (user as any)?.user_metadata || (user as any)?.app_metadata || {};\n      const role: string = meta.role || 'agent';\n      const emailForAgent: string | null = user.email || null;\n\n      // Update Supabase password\n      const { error: supabaseError } = await authHelpers.updatePassword(newPassword);\n      \n      if (supabaseError) {\n        return { error: (supabaseError as any).message || 'Password update failed' };\n      }\n\n      // Clear metadata flag requiring password change, if present\n      try {\n        await supabase.auth.updateUser({\n          // Only update metadata; password already updated above\n          data: { must_change_password: false }\n        });\n      } catch (metaErr) {\n        console.warn(' Failed to clear must_change_password metadata (non-blocking):', metaErr);\n      }\n\n      // If user is an agent, also update their DB credentials\n      if (role === 'agent' && emailForAgent) {\n        try {\n          // Import AgentManagementService here to avoid circular dependency\n          const { AgentManagementService } = await import('./agentManagementService');\n          \n          await AgentManagementService.setAgentCredentials(\n            user.id,\n            emailForAgent,\n            newPassword,\n            false\n          );\n          console.log(' Updated both Supabase and DB credentials for agent:', emailForAgent);\n        } catch (dbError) {\n          console.warn(' Failed to update DB credentials, but Supabase password updated:', dbError);\n          // Don't fail the entire operation if DB sync fails\n        }\n      }\n\n      return { error: null };\n    } catch (error) {\n      console.error(' Password update error:', error);\n      return { error: error instanceof Error ? error.message : 'Password update failed' };\n    }\n  }\n\n  static async updateProfile(userId: string, updates: Partial<AuthUser>): Promise<{ user: User | null; error: string | null }> {\n    try {\n      const { data, error } = await supabase\n        .from('profiles')\n        .update({\n          name: updates.name,\n          email: updates.email,\n          phone: updates.phone,\n          department: updates.department,\n          position: updates.position,\n          employee_id: updates.employee_id ?? updates.employeeId,\n          company_name: updates.company_name,\n          city: updates.city,\n          country: updates.country,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', userId)\n        .select()\n        .single();\n\n      if (error) {\n        return { user: null, error: error.message };\n      }\n\n      const appUser = convertToAppUser(data);\n      return { user: appUser, error: null };\n    } catch (error) {\n      return { user: null, error: error instanceof Error ? error.message : 'Profile update failed' };\n    }\n  }\n\n  /**\n   * Check if user needs to change password (for temporary credentials)\n   */\n  static async checkPasswordChangeRequired(): Promise<{ required: boolean; reason?: string }> {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      \n      if (!user) {\n        return { required: false };\n      }\n\n      // Check user metadata flag first for general users\n      const meta: any = (user as any)?.user_metadata || (user as any)?.app_metadata || {};\n      if (meta.must_change_password === true) {\n        return {\n          required: true,\n          reason: 'Your account requires a password change before proceeding.'\n        };\n      }\n\n      // Determine role and email from auth user metadata to avoid profiles RLS recursion\n      const role: string = typeof meta.role === 'string' ? meta.role : 'agent';\n      const emailForAgent: string | null = (user as any)?.email || null;\n\n      // For agents, check if they have temporary credentials\n      if (role === 'agent' && emailForAgent) {\n        const { data: credData, error: credErr } = await (supabase as any)\n          .rpc('get_agent_credentials_status', { p_username: emailForAgent });\n\n        if (credErr) {\n          console.warn(' Error checking agent credentials via RPC:', credErr.message || credErr);\n          return { required: false };\n        }\n\n        // RPC returns a row with fields: credential_exists, is_temporary, agent_id\n        if ((credData as any)?.is_temporary) {\n          return {\n            required: true,\n            reason: 'You are using temporary credentials. Please change your password for security.'\n          };\n        }\n      }\n\n      return { required: false };\n    } catch (error) {\n      console.warn(' Failed to check password change requirement:', error);\n      return { required: false };\n    }\n  }\n\n  /**\n   * Ensure a profile row exists for the given auth user id; upsert minimal data if missing\n   */\n  private static async ensureProfileExists(authUser: { id: string; email?: string; user_metadata?: any; app_metadata?: any }): Promise<any | null> {\n    try {\n      // First, try reading existing profile directly\n      if (authUser?.id) {\n        const { data: existing, error: readErr } = await supabase\n          .from('profiles' as any)\n          .select('*')\n          .eq('id', authUser.id)\n          .maybeSingle();\n        if (!readErr && existing) {\n          return existing;\n        }\n      }\n      // Use admin client to upsert minimal profile without RLS recursion\n      if (isAdminClientConfigured && adminSupabase && authUser?.id) {\n        // Determine role via current session RPC when available; default to 'user'\n        let role: string = 'user';\n        \n        // Check if user came from Google OAuth with specified role\n        const metadata = authUser?.user_metadata || {};\n        console.log(' ensureProfileExists - Checking metadata for role:', metadata);\n        \n        if (metadata.role) {\n          role = metadata.role;\n          console.log(' Found role in metadata:', role);\n        } else {\n          try {\n            const { data: roleData, error: roleErr } = await (supabase as any).rpc('get_current_user_role');\n            if (!roleErr && typeof roleData === 'string' && roleData) {\n              role = roleData;\n              console.log(' Found role via RPC:', role);\n            } else {\n              console.log(' No role found via RPC, defaulting to user');\n            }\n          } catch (e) {\n            console.log(' RPC error, defaulting to user role:', e);\n          }\n        }\n\n        const name = (authUser?.user_metadata?.name) \n          || (authUser?.email ? String(authUser.email).split('@')[0] : 'User');\n        const email = authUser?.email || null;\n        const phone = authUser?.user_metadata?.phone || null;\n\n        const payload: any = {\n          id: authUser.id,\n          name,\n          email,\n          role,\n          phone,\n          status: 'active',\n          position: role || 'User',\n          must_change_password: (authUser?.user_metadata?.must_change_password === true),\n          updated_at: new Date().toISOString()\n        };\n\n        const { data: upserted, error: upsertErr } = await adminSupabase\n          .from('profiles')\n          .upsert([payload], { onConflict: 'id' })\n          .select()\n          .single();\n\n        if (!upsertErr && upserted) {\n          console.log(' Profile ensured via admin client:', upserted.id, 'with role:', upserted.role);\n          return upserted;\n        } else {\n          console.warn('Admin profile upsert error (non-blocking):', upsertErr);\n        }\n      }\n\n      return null;\n    } catch (e) {\n      console.warn(' ensureProfileExists error:', e);\n      return null;\n    }\n  }\n}","\nimport { supabase, adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\n\n// Prefer admin client if configured for server-side writes\nconst dbClient: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\nconst DB_LOGIN_TABLE = 'staff_login_records';\nconst DB_ACTIVE_TABLE = 'staff_active_sessions';\n\nexport interface LoginRecord {\n  id: string;\n  staffId: string;\n  staffName: string;\n  loginTime: string;\n  logoutTime?: string;\n  duration?: number; // in minutes\n  status: 'active' | 'logged-out';\n  ipAddress?: string;\n  userAgent?: string;\n  department?: string;\n  city?: string;\n  country?: string;\n}\n\nexport interface ActiveSession {\n  staffId: string;\n  staffName: string;\n  loginTime: string;\n  lastActivity: string;\n  status: 'active';\n  department?: string;\n  city?: string;\n  country?: string;\n}\n\nexport type LoginFilters = {\n  department?: string;\n  country?: string;\n  city?: string;\n};\n\nconst LOGIN_RECORDS_KEY = 'staff_login_records';\nconst ACTIVE_SESSIONS_KEY = 'active_staff_sessions';\n\nexport const getLoginRecords = (): LoginRecord[] => {\n  try {\n    const stored = localStorage.getItem(LOGIN_RECORDS_KEY);\n    return stored ? JSON.parse(stored) : [];\n  } catch (error) {\n    console.error('Error reading login records:', error);\n    return [];\n  }\n};\n\nexport const getActiveStaffSessions = (): ActiveSession[] => {\n  try {\n    const stored = localStorage.getItem(ACTIVE_SESSIONS_KEY);\n    return stored ? JSON.parse(stored) : [];\n  } catch (error) {\n    console.error('Error reading active sessions:', error);\n    return [];\n  }\n};\n\n// Supabase-backed fetchers with local fallback\nexport const fetchLoginRecords = async (limit: number = 1000, filters?: LoginFilters): Promise<LoginRecord[]> => {\n  try {\n    if (!dbClient) throw new Error('No Supabase client');\n    let query = dbClient\n      .from(DB_LOGIN_TABLE)\n      .select('*')\n      .order('login_time', { ascending: false })\n      .limit(limit);\n\n    if (filters?.department && filters.department !== 'all' && filters.department !== 'Unknown') {\n      query = query.eq('department', filters.department);\n    }\n    if (filters?.country && filters.country !== 'all' && filters.country !== 'Unknown') {\n      query = query.eq('country', filters.country);\n    }\n    if (filters?.city && filters.city !== 'all' && filters.city !== 'Unknown') {\n      query = query.eq('city', filters.city);\n    }\n\n    const { data, error } = await query;\n    if (error) throw error;\n    if (!Array.isArray(data)) return [];\n    return data.map((row: any) => ({\n      id: String(row.id),\n      staffId: String(row.staff_id),\n      staffName: String(row.staff_name || ''),\n      loginTime: String(row.login_time),\n      logoutTime: row.logout_time ? String(row.logout_time) : undefined,\n      duration: typeof row.duration_minutes === 'number' ? row.duration_minutes : undefined,\n      status: (row.status === 'active' ? 'active' : 'logged-out'),\n      ipAddress: row.ip_address || undefined,\n      userAgent: row.user_agent || undefined,\n      department: row.department || undefined,\n      city: row.city || undefined,\n      country: row.country || undefined,\n    }));\n  } catch (e) {\n    console.warn('DB fetch staff login records failed, using local fallback:', e);\n    return getLoginRecords();\n  }\n};\n\nexport const fetchActiveStaffSessions = async (filters?: LoginFilters): Promise<ActiveSession[]> => {\n  try {\n    if (!dbClient) throw new Error('No Supabase client');\n    let query = dbClient\n      .from(DB_ACTIVE_TABLE)\n      .select('*')\n      .eq('status', 'active')\n      .order('last_activity', { ascending: false });\n\n    if (filters?.department && filters.department !== 'all' && filters.department !== 'Unknown') {\n      query = query.eq('department', filters.department);\n    }\n    if (filters?.country && filters.country !== 'all' && filters.country !== 'Unknown') {\n      query = query.eq('country', filters.country);\n    }\n    if (filters?.city && filters.city !== 'all' && filters.city !== 'Unknown') {\n      query = query.eq('city', filters.city);\n    }\n\n    const { data, error } = await query;\n    if (error) throw error;\n    if (!Array.isArray(data)) return [];\n    return data.map((row: any) => ({\n      staffId: String(row.staff_id),\n      staffName: String(row.staff_name || ''),\n      loginTime: String(row.login_time),\n      lastActivity: String(row.last_activity),\n      status: 'active',\n      department: row.department || undefined,\n      city: row.city || undefined,\n      country: row.country || undefined,\n    }));\n  } catch (e) {\n    console.warn('DB fetch active staff sessions failed, using local fallback:', e);\n    return getActiveStaffSessions();\n  }\n};\n\nexport const recordStaffLogin = (staffId: string, staffName: string): string => {\n  try {\n    const loginId = `staff_login_${Date.now()}_${staffId}`;\n    const loginTime = new Date().toISOString();\n\n    // Local storage fallback (for offline mode)\n    try {\n      const existingActive = getLoginRecords().find(r => r.staffId === staffId && r.status === 'active');\n      const loginRecord: LoginRecord = existingActive || {\n        id: loginId,\n        staffId,\n        staffName,\n        loginTime,\n        status: 'active',\n        ipAddress: 'localhost',\n        userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,\n      };\n      const activeSession: ActiveSession = {\n        staffId,\n        staffName,\n        loginTime,\n        lastActivity: loginTime,\n        status: 'active'\n      };\n      const existingRecords = getLoginRecords();\n      if (!existingActive) {\n        existingRecords.push(loginRecord);\n        localStorage.setItem(LOGIN_RECORDS_KEY, JSON.stringify(existingRecords));\n      }\n      const activeSessions = getActiveStaffSessions();\n      const idx = activeSessions.findIndex(s => s.staffId === staffId);\n      if (idx !== -1) activeSessions[idx] = activeSession; else activeSessions.push(activeSession);\n      localStorage.setItem(ACTIVE_SESSIONS_KEY, JSON.stringify(activeSessions));\n    } catch {}\n\n    // Supabase writes (best-effort, non-blocking)\n    (async () => {\n      try {\n        if (!dbClient) return;\n\n        // If already active, avoid duplicating login records; just update heartbeat\n        try {\n          const { data: existingActive } = await dbClient\n            .from(DB_ACTIVE_TABLE)\n            .select('staff_id, login_record_id')\n            .eq('staff_id', staffId)\n            .eq('status', 'active')\n            .maybeSingle();\n          if (existingActive) {\n            const now = new Date().toISOString();\n            await dbClient\n              .from(DB_ACTIVE_TABLE)\n              .update({ last_activity: now, updated_at: now })\n              .eq('staff_id', staffId);\n            return; // Skip creating a new login record\n          }\n        } catch {}\n\n        // Attempt to enrich location/department from profiles\n        let department: string | undefined;\n        let city: string | undefined;\n        let country: string | undefined;\n        try {\n          const { data: profile } = await dbClient\n            .from('profiles')\n            .select('department, city, country')\n            .eq('id', staffId)\n            .maybeSingle();\n          if (profile) {\n            department = (profile as any).department ?? undefined;\n            city = (profile as any).city ?? undefined;\n            country = (profile as any).country ?? undefined;\n          }\n        } catch {}\n\n        const { error: loginErr } = await dbClient\n          .from(DB_LOGIN_TABLE)\n          .upsert({\n            id: loginId,\n            staff_id: staffId,\n            staff_name: staffName,\n            login_time: loginTime,\n            status: 'active',\n            ip_address: undefined,\n            user_agent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,\n            department,\n            city,\n            country,\n            updated_at: new Date().toISOString(),\n          }, { onConflict: 'id' });\n        if (loginErr) throw loginErr;\n\n        const { error: sessErr } = await dbClient\n          .from(DB_ACTIVE_TABLE)\n          .upsert({\n            staff_id: staffId,\n            staff_name: staffName,\n            login_time: loginTime,\n            last_activity: loginTime,\n            status: 'active',\n            login_record_id: loginId,\n            department,\n            city,\n            country,\n            updated_at: new Date().toISOString(),\n          }, { onConflict: 'staff_id' });\n        if (sessErr) throw sessErr;\n      } catch (dbWriteErr) {\n        console.warn('Supabase staff login write failed:', dbWriteErr);\n      }\n    })();\n\n    return loginId;\n  } catch (error) {\n    console.error('Error recording staff login:', error);\n    return '';\n  }\n};\n\nexport const recordStaffLogout = (staffId: string): void => {\n  try {\n    const logoutTime = new Date().toISOString();\n\n    // Local fallback update\n    try {\n      const loginRecords = getLoginRecords();\n      const activeRecord = loginRecords.find(\n        record => record.staffId === staffId && record.status === 'active'\n      );\n      if (activeRecord) {\n        activeRecord.logoutTime = logoutTime;\n        activeRecord.status = 'logged-out';\n        activeRecord.duration = Math.floor(\n          (new Date(logoutTime).getTime() - new Date(activeRecord.loginTime).getTime()) / (1000 * 60)\n        );\n        localStorage.setItem(LOGIN_RECORDS_KEY, JSON.stringify(loginRecords));\n      }\n      const activeSessions = getActiveStaffSessions();\n      const updatedSessions = activeSessions.filter(s => s.staffId !== staffId);\n      localStorage.setItem(ACTIVE_SESSIONS_KEY, JSON.stringify(updatedSessions));\n    } catch {}\n\n    // Supabase updates (best-effort)\n    (async () => {\n      try {\n        if (!dbClient) return;\n        const { data: activeRec, error: fetchErr } = await dbClient\n          .from(DB_LOGIN_TABLE)\n          .select('id,login_time')\n          .eq('staff_id', staffId)\n          .eq('status', 'active')\n          .limit(1)\n          .maybeSingle();\n        if (fetchErr) throw fetchErr;\n        const loginTime = activeRec?.login_time ? new Date(activeRec.login_time).getTime() : null;\n        const durationMinutes = loginTime ? Math.floor((new Date(logoutTime).getTime() - loginTime) / (1000 * 60)) : null;\n\n        const { error: updErr } = await dbClient\n          .from(DB_LOGIN_TABLE)\n          .update({\n            logout_time: logoutTime,\n            status: 'logged-out',\n            duration_minutes: durationMinutes ?? undefined,\n            updated_at: new Date().toISOString(),\n          })\n          .eq('staff_id', staffId)\n          .eq('status', 'active');\n        if (updErr) throw updErr;\n\n        const { error: delErr } = await dbClient\n          .from(DB_ACTIVE_TABLE)\n          .delete()\n          .eq('staff_id', staffId);\n        if (delErr) throw delErr;\n      } catch (dbErr) {\n        console.warn('Supabase staff logout update failed:', dbErr);\n      }\n    })();\n  } catch (error) {\n    console.error('Error recording staff logout:', error);\n  }\n};\n\nexport const updateStaffActivity = (staffId: string): void => {\n  try {\n    // Local heartbeat\n    try {\n      const activeSessions = getActiveStaffSessions();\n      const sessionIndex = activeSessions.findIndex(s => s.staffId === staffId);\n      if (sessionIndex !== -1) {\n        activeSessions[sessionIndex].lastActivity = new Date().toISOString();\n        localStorage.setItem(ACTIVE_SESSIONS_KEY, JSON.stringify(activeSessions));\n      }\n    } catch {}\n\n    // Supabase heartbeat\n    (async () => {\n      try {\n        if (!dbClient) return;\n        const now = new Date().toISOString();\n        const { error } = await dbClient\n          .from(DB_ACTIVE_TABLE)\n          .update({ last_activity: now, updated_at: now })\n          .eq('staff_id', staffId);\n        if (error) throw error;\n      } catch (e) {\n        console.warn('Supabase staff activity update failed:', e);\n      }\n    })();\n  } catch (error) {\n    console.error('Error updating staff activity:', error);\n  }\n};\n\nexport const getStaffLoginHistory = (staffId: string, days: number = 30): LoginRecord[] => {\n  const records = getLoginRecords();\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - days);\n  \n  return records.filter(\n    record => record.staffId === staffId && \n    new Date(record.loginTime) >= cutoffDate\n  ).sort((a, b) => new Date(b.loginTime).getTime() - new Date(a.loginTime).getTime());\n};\n\nexport const getTotalWorkingHours = (staffId: string, date: string): number => {\n  const records = getLoginRecords();\n  const targetDate = new Date(date).toDateString();\n  \n  const dayRecords = records.filter(record => {\n    const recordDate = new Date(record.loginTime).toDateString();\n    return record.staffId === staffId && recordDate === targetDate && record.duration;\n  });\n  \n  return dayRecords.reduce((total, record) => total + (record.duration || 0), 0);\n};\n\nexport const isStaffCurrentlyActive = (staffId: string): boolean => {\n  const activeSessions = getActiveStaffSessions();\n  return activeSessions.some(session => session.staffId === staffId);\n};\n","import { supabase } from '@/lib/supabaseClient';\nimport { User } from '@/types/User';\n\nexport interface UserTrackingData {\n  createdBy?: string;\n  updatedBy?: string;\n  createdByUser?: string;  // Database field name\n  updatedByUser?: string;  // Database field name\n  createdAt?: string;\n  updatedAt?: string;\n}\n\nexport interface UserInfo {\n  id: string;\n  name: string;\n  email: string;\n  role: string;\n  department: string;\n}\n\nexport class UserTrackingService {\n  private static instance: UserTrackingService;\n  private currentUser: User | null = null;\n\n  static getInstance(): UserTrackingService {\n    if (!UserTrackingService.instance) {\n      UserTrackingService.instance = new UserTrackingService();\n    }\n    return UserTrackingService.instance;\n  }\n\n  /**\n   * Set the current user for tracking purposes\n   */\n  setCurrentUser(user: User | null): void {\n    this.currentUser = user;\n  }\n\n  /**\n   * Get the current user\n   */\n  getCurrentUser(): User | null {\n    return this.currentUser;\n  }\n\n  /**\n   * Get current user ID for database operations\n   */\n  getCurrentUserId(): string | null {\n    return this.currentUser?.id || null;\n  }\n\n  /**\n   * Get user tracking data for creating new records\n   */\n  getCreateTrackingData(): UserTrackingData {\n    const userId = this.getCurrentUserId();\n    const now = new Date().toISOString();\n\n    return {\n      createdBy: userId || undefined,\n      updatedBy: userId || undefined,\n      createdByUser: userId || undefined,\n      updatedByUser: userId || undefined,\n      createdAt: now,\n      updatedAt: now\n    };\n  }\n\n  /**\n   * Get user tracking data for updating existing records\n   */\n  getUpdateTrackingData(): UserTrackingData {\n    const userId = this.getCurrentUserId();\n    const now = new Date().toISOString();\n\n    return {\n      updatedBy: userId || undefined,\n      updatedByUser: userId || undefined,\n      updatedAt: now\n    };\n  }\n\n  /**\n   * Get user information by ID from the database\n   */\n  async getUserInfo(userId: string): Promise<UserInfo | null> {\n    try {\n      const { data, error } = await supabase\n        .from('profiles')\n        .select('id, name, email, role, department')\n        .eq('id', userId)\n        .single();\n\n      if (error || !data) {\n        console.warn(`Failed to fetch user info for ${userId}:`, error);\n        return null;\n      }\n\n      return {\n        id: data.id,\n        name: data.name || 'Unknown User',\n        email: data.email || '',\n        role: data.role || 'user',\n        department: data.department || 'General'\n      };\n    } catch (error) {\n      console.error('Error fetching user info:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get multiple users' information by IDs\n   */\n  async getUsersInfo(userIds: string[]): Promise<Record<string, UserInfo>> {\n    try {\n      const { data, error } = await supabase\n        .from('profiles')\n        .select('id, name, email, role, department')\n        .in('id', userIds);\n\n      if (error || !data) {\n        console.warn('Failed to fetch users info:', error);\n        return {};\n      }\n\n      const usersMap: Record<string, UserInfo> = {};\n      data.forEach(user => {\n        usersMap[user.id] = {\n          id: user.id,\n          name: user.name || 'Unknown User',\n          email: user.email || '',\n          role: user.role || 'user',\n          department: user.department || 'General'\n        };\n      });\n\n      return usersMap;\n    } catch (error) {\n      console.error('Error fetching users info:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Format user display name\n   */\n  formatUserDisplay(userInfo: UserInfo | null): string {\n    if (!userInfo) return 'Unknown User';\n    return `${userInfo.name} (${userInfo.role})`;\n  }\n\n  /**\n   * Format user display with department\n   */\n  formatUserDisplayWithDepartment(userInfo: UserInfo | null): string {\n    if (!userInfo) return 'Unknown User';\n    return `${userInfo.name} - ${userInfo.department} (${userInfo.role})`;\n  }\n\n  /**\n   * Check if current user can edit a record based on creation/ownership\n   */\n  canEditRecord(recordCreatedBy?: string): boolean {\n    const currentUserId = this.getCurrentUserId();\n    if (!currentUserId) return false;\n\n    // Super admin can edit anything\n    if (this.currentUser?.role === 'super_admin') return true;\n\n    // Managers can edit records in their department\n    if (this.currentUser?.role === 'manager') return true;\n\n    // Users can edit their own records\n    return recordCreatedBy === currentUserId;\n  }\n\n  /**\n   * Check if current user can delete a record\n   */\n  canDeleteRecord(recordCreatedBy?: string): boolean {\n    const currentUserId = this.getCurrentUserId();\n    if (!currentUserId) return false;\n\n    // Super admin can delete anything\n    if (this.currentUser?.role === 'super_admin') return true;\n\n    // Managers can delete records in their department\n    if (this.currentUser?.role === 'manager') return true;\n\n    // Regular users cannot delete records (even their own)\n    return false;\n  }\n\n  /**\n   * Get audit trail for a record\n   */\n  async getAuditTrail(tableName: string, recordId: string): Promise<any[]> {\n    try {\n      // This would require an audit log table to be implemented\n      // For now, return empty array\n      console.log(`Audit trail requested for ${tableName}:${recordId}`);\n      return [];\n    } catch (error) {\n      console.error('Error fetching audit trail:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Log an action for audit purposes\n   */\n  async logAction(action: string, tableName: string, recordId: string, details?: any): Promise<void> {\n    try {\n      const userId = this.getCurrentUserId();\n      if (!userId) return;\n\n      // This would log to an audit table\n      console.log('Action logged:', {\n        userId,\n        action,\n        tableName,\n        recordId,\n        details,\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error('Error logging action:', error);\n    }\n  }\n}\n\n// Export singleton instance\nexport const userTrackingService = UserTrackingService.getInstance();","import { initialCountries } from '@/pages/inventory/countries/data/countryData';\n\nexport interface CurrencyInfo {\n  code: string;\n  symbol: string;\n  name: string;\n  decimals: number;\n}\n\nexport interface CountryInfo {\n  code: string;\n  name: string;\n  currency: string;\n  currencySymbol: string;\n  region: string;\n}\n\nexport interface ExchangeRate {\n  id?: string;\n  from: string;\n  to: string;\n  fromCurrency?: string;\n  toCurrency?: string;\n  rate: number;\n  margin: number;\n  lastUpdated: string;\n  additionalSurcharge?: number;\n  isFixed?: boolean;\n  isRealTime?: boolean;\n  isCustom?: boolean;\n}\n\nexport class CurrencyService {\n  private static currencyMap: Map<string, CurrencyInfo> = new Map([\n    ['USD', { code: 'USD', symbol: '$', name: 'US Dollar', decimals: 2 }],\n    ['EUR', { code: 'EUR', symbol: '', name: 'Euro', decimals: 2 }],\n    ['GBP', { code: 'GBP', symbol: '', name: 'British Pound', decimals: 2 }],\n    ['JPY', { code: 'JPY', symbol: '', name: 'Japanese Yen', decimals: 0 }],\n    ['CAD', { code: 'CAD', symbol: 'C$', name: 'Canadian Dollar', decimals: 2 }],\n    ['AUD', { code: 'AUD', symbol: 'A$', name: 'Australian Dollar', decimals: 2 }],\n    ['CHF', { code: 'CHF', symbol: 'CHF', name: 'Swiss Franc', decimals: 2 }],\n    ['CNY', { code: 'CNY', symbol: '', name: 'Chinese Yuan', decimals: 2 }],\n    ['INR', { code: 'INR', symbol: '', name: 'Indian Rupee', decimals: 2 }],\n    ['AED', { code: 'AED', symbol: '.', name: 'UAE Dirham', decimals: 2 }],\n    ['SGD', { code: 'SGD', symbol: 'S$', name: 'Singapore Dollar', decimals: 2 }],\n    ['THB', { code: 'THB', symbol: '', name: 'Thai Baht', decimals: 2 }],\n    ['MYR', { code: 'MYR', symbol: 'RM', name: 'Malaysian Ringgit', decimals: 2 }],\n    ['IDR', { code: 'IDR', symbol: 'Rp', name: 'Indonesian Rupiah', decimals: 0 }],\n    ['PHP', { code: 'PHP', symbol: '', name: 'Philippine Peso', decimals: 2 }],\n    ['VND', { code: 'VND', symbol: '', name: 'Vietnamese Dong', decimals: 0 }],\n    ['KRW', { code: 'KRW', symbol: '', name: 'South Korean Won', decimals: 0 }],\n    ['BRL', { code: 'BRL', symbol: 'R$', name: 'Brazilian Real', decimals: 2 }],\n    ['MXN', { code: 'MXN', symbol: '$', name: 'Mexican Peso', decimals: 2 }],\n    ['ZAR', { code: 'ZAR', symbol: 'R', name: 'South African Rand', decimals: 2 }],\n    ['NZD', { code: 'NZD', symbol: 'NZ$', name: 'New Zealand Dollar', decimals: 2 }],\n  ]);\n\n  static getCurrencyInfo(currencyCode: string): CurrencyInfo {\n    const currency = this.currencyMap.get(currencyCode.toUpperCase());\n    return currency || { code: 'USD', symbol: '$', name: 'US Dollar', decimals: 2 };\n  }\n\n  static formatCurrency(amount: number, currencyCode: string): string {\n    const currency = this.getCurrencyInfo(currencyCode);\n    const rounded = Math.round(amount * Math.pow(10, currency.decimals)) / Math.pow(10, currency.decimals);\n    \n    return `${currency.symbol}${rounded.toLocaleString('en-US', {\n      minimumFractionDigits: currency.decimals,\n      maximumFractionDigits: currency.decimals\n    })}`;\n  }\n\n  static formatCurrencyInput(amount: number, currencyCode: string): string {\n    const currency = this.getCurrencyInfo(currencyCode);\n    return amount.toFixed(currency.decimals);\n  }\n\n  static getCountryInfo(): CountryInfo[] {\n    return initialCountries.map(country => ({\n      code: country.code,\n      name: country.name,\n      currency: country.currency,\n      currencySymbol: country.currencySymbol,\n      region: country.region\n    }));\n  }\n\n  static getCountryByCode(countryCode: string): CountryInfo | null {\n    const countries = this.getCountryInfo();\n    return countries.find(c => c.code === countryCode) || null;\n  }\n\n  static getCurrencyByCountryCode(countryCode: string): CurrencyInfo {\n    const country = this.getCountryByCode(countryCode);\n    if (country) {\n      return this.getCurrencyInfo(country.currency);\n    }\n    return this.getCurrencyInfo('USD');\n  }\n\n  static getAvailableCurrencies(): CurrencyInfo[] {\n    return Array.from(this.currencyMap.values()).sort((a, b) => a.code.localeCompare(b.code));\n  }\n\n  static getCountriesByCurrency(currencyCode: string): CountryInfo[] {\n    const countries = this.getCountryInfo();\n    return countries.filter(c => c.currency === currencyCode);\n  }\n\n  static calculateWithMargin(rate: number, margin: number, multiplier: number = 1, surcharge: number = 0): number {\n    // Calculate final rate with margin and surcharge\n    const withMargin = rate * (1 + margin / 100);\n    return (withMargin + surcharge) * multiplier;\n  }\n\n  static getDefaultRates(): ExchangeRate[] {\n    return [\n      { \n        id: '1',\n        from: 'USD', \n        to: 'THB', \n        fromCurrency: 'USD',\n        toCurrency: 'THB',\n        rate: 35.7, \n        margin: 2, \n        lastUpdated: new Date().toISOString(),\n        additionalSurcharge: 0,\n        isFixed: false,\n        isRealTime: true,\n        isCustom: false\n      },\n      { \n        id: '2',\n        from: 'THB', \n        to: 'USD', \n        fromCurrency: 'THB',\n        toCurrency: 'USD',\n        rate: 0.028, \n        margin: 2, \n        lastUpdated: new Date().toISOString(),\n        additionalSurcharge: 0,\n        isFixed: false,\n        isRealTime: true,\n        isCustom: false\n      },\n      { \n        id: '3',\n        from: 'USD', \n        to: 'EUR', \n        fromCurrency: 'USD',\n        toCurrency: 'EUR',\n        rate: 0.92, \n        margin: 1.5, \n        lastUpdated: new Date().toISOString(),\n        additionalSurcharge: 0,\n        isFixed: false,\n        isRealTime: true,\n        isCustom: false\n      },\n      { \n        id: '4',\n        from: 'EUR', \n        to: 'USD', \n        fromCurrency: 'EUR',\n        toCurrency: 'USD',\n        rate: 1.09, \n        margin: 1.5, \n        lastUpdated: new Date().toISOString(),\n        additionalSurcharge: 0,\n        isFixed: false,\n        isRealTime: true,\n        isCustom: false\n      },\n    ];\n  }\n\n  static getApiUsage(): { used: number; limit: number; remaining: number } {\n    return { used: 0, limit: 1000, remaining: 1000 };\n  }\n\n  static async fetchAllRealTimeRates(): Promise<{ rates: ExchangeRate[]; isRealTime: boolean }> {\n    // Mock implementation - in real app would call external API\n    return {\n      rates: this.getDefaultRates(),\n      isRealTime: true\n    };\n  }\n\n  static clearCache(): void {\n    // Mock implementation for cache clearing\n    console.log('Currency cache cleared');\n  }\n}","\nimport { StaffNotification, NotificationPreferences, Query } from '@/types/query';\n\nclass StaffNotificationService {\n  private notifications: StaffNotification[] = [];\n  private preferences: Map<string, NotificationPreferences> = new Map();\n  private notificationId = 1;\n\n  // Generate a new notification ID\n  private generateId(): string {\n    return `notification_${this.notificationId++}_${Date.now()}`;\n  }\n\n  // Create a new notification\n  createNotification(notification: Omit<StaffNotification, 'id' | 'timestamp'>): StaffNotification {\n    const newNotification: StaffNotification = {\n      ...notification,\n      id: this.generateId(),\n      timestamp: new Date().toISOString()\n    };\n\n    this.notifications.unshift(newNotification);\n    return newNotification;\n  }\n\n  // Get notifications for a specific staff member\n  async getNotificationsForStaff(staffId: string): Promise<StaffNotification[]> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    return this.notifications\n      .filter(n => n.staffId === staffId)\n      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n  }\n\n  // Mark notification as read\n  async markAsRead(notificationId: string): Promise<void> {\n    const notification = this.notifications.find(n => n.id === notificationId);\n    if (notification) {\n      notification.read = true;\n    }\n  }\n\n  // Mark multiple notifications as read\n  async markMultipleAsRead(notificationIds: string[]): Promise<void> {\n    this.notifications.forEach(notification => {\n      if (notificationIds.includes(notification.id)) {\n        notification.read = true;\n      }\n    });\n  }\n\n  // Dismiss a notification\n  async dismissNotification(notificationId: string): Promise<void> {\n    const index = this.notifications.findIndex(n => n.id === notificationId);\n    if (index > -1) {\n      this.notifications.splice(index, 1);\n    }\n  }\n\n  // Get user notification preferences\n  async getPreferences(staffId: string): Promise<NotificationPreferences> {\n    let userPreferences = this.preferences.get(staffId);\n    \n    if (!userPreferences) {\n      // Create default preferences\n      userPreferences = {\n        staffId,\n        browserNotifications: true,\n        emailNotifications: true,\n        assignments: true,\n        statusUpdates: true,\n        followUpReminders: true,\n        urgentOnly: false\n      };\n      this.preferences.set(staffId, userPreferences);\n    }\n    \n    return userPreferences;\n  }\n\n  // Update user notification preferences\n  async updatePreferences(preferences: NotificationPreferences): Promise<void> {\n    this.preferences.set(preferences.staffId, preferences);\n  }\n\n  // Show browser notification\n  showBrowserNotification(notification: StaffNotification): void {\n    if ('Notification' in window && Notification.permission === 'granted') {\n      const browserNotification = new Notification(notification.title, {\n        body: notification.message,\n        icon: '/favicon.ico',\n        badge: '/favicon.ico',\n        tag: notification.id,\n        requireInteraction: notification.priority === 'urgent',\n        silent: notification.priority === 'low'\n      });\n\n      // Auto-close after 5 seconds for non-urgent notifications\n      if (notification.priority !== 'urgent') {\n        setTimeout(() => {\n          browserNotification.close();\n        }, 5000);\n      }\n\n      // Handle click to navigate to query\n      browserNotification.onclick = () => {\n        window.focus();\n        if (notification.actionUrl) {\n          window.location.href = notification.actionUrl;\n        }\n        browserNotification.close();\n      };\n    }\n  }\n\n  // Simulate email notification\n  async sendEmailNotification(notification: StaffNotification, recipientEmail: string): Promise<void> {\n    // Simulate email sending delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    console.log(' Email Notification Sent:', {\n      to: recipientEmail,\n      subject: notification.title,\n      body: notification.message,\n      priority: notification.priority,\n      timestamp: new Date().toISOString()\n    });\n\n    // In a real implementation, this would integrate with an email service\n    // like SendGrid, AWS SES, or similar\n  }\n\n  // Create assignment notification with enhanced content\n  createAssignmentNotification(query: Query, staffId: string, assignerName: string): StaffNotification {\n    const priority = this.calculatePriority(query);\n    const urgencyText = priority === 'urgent' ? ' [URGENT]' : '';\n    \n    const notification: Omit<StaffNotification, 'id' | 'timestamp'> = {\n      staffId,\n      queryId: query.id,\n      type: 'assignment',\n      title: `New Enquiry Assigned${urgencyText}`,\n      message: `You have been assigned enquiry ${query.id} for ${query.destination.country} by ${assignerName}. Travel dates: ${new Date(query.travelDates.from).toLocaleDateString()} - ${new Date(query.travelDates.to).toLocaleDateString()}`,\n      read: false,\n      actionRequired: true,\n      priority,\n      actionUrl: `/queries/${query.id}`\n    };\n\n    return this.createNotification(notification);\n  }\n\n  // Create status change notification\n  createStatusChangeNotification(query: Query, staffId: string, oldStatus: string, newStatus: string): StaffNotification {\n    const notification: Omit<StaffNotification, 'id' | 'timestamp'> = {\n      staffId,\n      queryId: query.id,\n      type: 'status_change',\n      title: 'Enquiry Status Updated',\n      message: `Enquiry ${query.id} status changed from ${oldStatus} to ${newStatus}`,\n      read: false,\n      actionRequired: newStatus === 'proposal-sent',\n      priority: newStatus === 'cancelled' ? 'high' : 'normal',\n      actionUrl: `/queries/${query.id}`\n    };\n\n    return this.createNotification(notification);\n  }\n\n  // Create follow-up reminder notification\n  createFollowUpReminder(query: Query, staffId: string): StaffNotification {\n    const notification: Omit<StaffNotification, 'id' | 'timestamp'> = {\n      staffId,\n      queryId: query.id,\n      type: 'follow_up_due',\n      title: 'Follow-up Due',\n      message: `Follow-up required for enquiry ${query.id} - ${query.destination.country}`,\n      read: false,\n      actionRequired: true,\n      priority: 'high',\n      actionUrl: `/queries/${query.id}`\n    };\n\n    return this.createNotification(notification);\n  }\n\n  // Create urgent query notification\n  createUrgentQueryNotification(query: Query, staffId: string, reason: string): StaffNotification {\n    const notification: Omit<StaffNotification, 'id' | 'timestamp'> = {\n      staffId,\n      queryId: query.id,\n      type: 'urgent_query',\n      title: ' URGENT: Immediate Action Required',\n      message: `Enquiry ${query.id} requires immediate attention: ${reason}`,\n      read: false,\n      actionRequired: true,\n      priority: 'urgent',\n      actionUrl: `/queries/${query.id}`,\n      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() // 24 hours\n    };\n\n    return this.createNotification(notification);\n  }\n\n  // Calculate notification priority based on query details\n  private calculatePriority(query: Query): 'low' | 'normal' | 'high' | 'urgent' {\n    const travelDate = new Date(query.travelDates.from);\n    const daysUntilTravel = Math.floor((travelDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24));\n    const totalPax = query.paxDetails.adults + query.paxDetails.children + query.paxDetails.infants;\n\n    // Urgent: Travel within 7 days\n    if (daysUntilTravel <= 7) return 'urgent';\n    \n    // High: Luxury packages, large groups, or travel within 30 days\n    if (query.packageType === 'luxury' || totalPax >= 8 || daysUntilTravel <= 30) return 'high';\n    \n    // Normal: Standard enquiries\n    if (totalPax >= 4 || daysUntilTravel <= 60) return 'normal';\n    \n    // Low: Small groups with distant travel dates\n    return 'low';\n  }\n\n  // Process notification with preferences\n  async processNotification(notification: StaffNotification, recipientEmail?: string): Promise<void> {\n    const preferences = await this.getPreferences(notification.staffId);\n    \n    // Check if notification should be sent based on preferences\n    if (preferences.urgentOnly && notification.priority !== 'urgent') {\n      return;\n    }\n\n    // Check notification type preferences\n    const typeEnabled = this.isNotificationTypeEnabled(notification.type, preferences);\n    if (!typeEnabled) {\n      return;\n    }\n\n    // Send browser notification\n    if (preferences.browserNotifications) {\n      this.showBrowserNotification(notification);\n    }\n\n    // Send email notification\n    if (preferences.emailNotifications && recipientEmail) {\n      await this.sendEmailNotification(notification, recipientEmail);\n    }\n  }\n\n  // Check if notification type is enabled\n  private isNotificationTypeEnabled(type: StaffNotification['type'], preferences: NotificationPreferences): boolean {\n    switch (type) {\n      case 'assignment':\n        return preferences.assignments;\n      case 'status_change':\n        return preferences.statusUpdates;\n      case 'follow_up_due':\n        return preferences.followUpReminders;\n      case 'proposal_request':\n      case 'urgent_query':\n        return true; // Always enabled for critical notifications\n      default:\n        return true;\n    }\n  }\n\n  // Get notification count by priority\n  getNotificationCountByPriority(notifications: StaffNotification[]): Record<string, number> {\n    return notifications.reduce((counts, notification) => {\n      counts[notification.priority] = (counts[notification.priority] || 0) + 1;\n      return counts;\n    }, {} as Record<string, number>);\n  }\n\n  // Clean up expired notifications\n  cleanupExpiredNotifications(): void {\n    const now = new Date().getTime();\n    this.notifications = this.notifications.filter(notification => {\n      if (notification.expiresAt) {\n        return new Date(notification.expiresAt).getTime() > now;\n      }\n      return true;\n    });\n  }\n\n  // Get notification statistics\n  getNotificationStats(staffId: string): {\n    total: number;\n    unread: number;\n    urgent: number;\n    highPriority: number;\n    actionRequired: number;\n  } {\n    const staffNotifications = this.notifications.filter(n => n.staffId === staffId);\n    \n    return {\n      total: staffNotifications.length,\n      unread: staffNotifications.filter(n => !n.read).length,\n      urgent: staffNotifications.filter(n => n.priority === 'urgent').length,\n      highPriority: staffNotifications.filter(n => n.priority === 'high').length,\n      actionRequired: staffNotifications.filter(n => n.actionRequired && !n.read).length\n    };\n  }\n}\n\nexport const staffNotificationService = new StaffNotificationService();\n","import { supabase, authHelpers } from '@/lib/supabaseClient';\nimport { Json } from '@/integrations/supabase/types';\n\n// Type definitions for app settings\nexport interface AppSetting {\n  id: string;\n  category: string;\n  setting_key: string;\n  setting_value?: string;\n  setting_json?: Json;\n  created_at: string;\n  updated_at: string;\n  updated_by?: string;\n}\n\nexport interface AppSettingInsert {\n  category: string;\n  setting_key: string;\n  setting_value?: string;\n  setting_json?: Json;\n  updated_by?: string;\n}\n\nexport interface AppSettingUpdate {\n  category?: string;\n  setting_key?: string;\n  setting_value?: string;\n  setting_json?: Json;\n  updated_by?: string;\n}\n\n// Categories for organizing settings\nexport const SETTING_CATEGORIES = {\n  GENERAL: 'General',\n  SEO: 'SEO & Meta',\n  BRANDING: 'Branding & UI',\n  PERMISSIONS: 'Permissions & Roles',\n  AUTHENTICATION: 'Authentication & Security',\n  NOTIFICATIONS: 'Notifications & Communication',\n  PAYMENT: 'Payment & Finance',\n  INTEGRATIONS: 'Integrations',\n  MAINTENANCE: 'System Maintenance',\n  CONTENT: 'Custom Content'\n} as const;\n\nexport type SettingCategory = typeof SETTING_CATEGORIES[keyof typeof SETTING_CATEGORIES];\n\n// Service response interface\nexport interface AppSettingsServiceResponse<T = any> {\n  data: T | null;\n  error: string | null;\n  success: boolean;\n}\n\n// For now, we'll use localStorage as a fallback until the database table is created\nconst STORAGE_KEY = 'app_settings_fallback';\n\n// Allowed roles for accessing settings\nconst ALLOWED_ROLES = ['super_admin', 'manager'];\n\nclass AppSettingsService {\n  // Check if user has required permissions\n  static async checkPermissions(): Promise<boolean> {\n    try {\n      // Guard: ensure we have an active session before calling getUser\n      const { session, error: sessionError } = await authHelpers.getSession();\n      if (sessionError || !session) {\n        console.debug('AppSettingsService: No active session  skipping settings check');\n        return false;\n      }\n\n      const { user } = await authHelpers.getUser();\n      if (!user) {\n        console.log(' AppSettingsService: No authenticated user');\n        return false;\n      }\n\n      // Use get_current_user_role function instead of direct table query\n      const { data: userRole, error: roleError } = await supabase\n        .rpc('get_current_user_role');\n\n      if (roleError) {\n        console.error(' AppSettingsService: Error getting user role:', roleError);\n        return false;\n      }\n\n      if (!userRole) {\n        console.log(' AppSettingsService: No role found for user');\n        return false;\n      }\n\n      // Check if user has required role\n      const hasRequiredRole = ALLOWED_ROLES.includes(userRole);\n      console.log(' AppSettingsService: Permission check result:', { role: userRole, hasRequiredRole });\n      \n      return hasRequiredRole;\n    } catch (error) {\n      console.error('Error checking permissions:', error);\n      return false;\n    }\n  }\n\n  // Get all settings grouped by category (using localStorage fallback)\n  static async getAllSettings(): Promise<AppSettingsServiceResponse<Record<string, AppSetting[]>>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      // Try localStorage fallback\n      const stored = localStorage.getItem(STORAGE_KEY);\n      const settings: AppSetting[] = stored ? JSON.parse(stored) : [];\n      \n      // Group by category\n      const grouped = settings.reduce((acc, setting) => {\n        if (!acc[setting.category]) {\n          acc[setting.category] = [];\n        }\n        acc[setting.category].push(setting);\n        return acc;\n      }, {} as Record<string, AppSetting[]>);\n\n      return {\n        data: grouped,\n        error: null,\n        success: true\n      };\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Get settings by category (using localStorage fallback)\n  static async getSettingsByCategory(category: string): Promise<AppSettingsServiceResponse<AppSetting[]>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      // Try localStorage fallback\n      const stored = localStorage.getItem(STORAGE_KEY);\n      const settings: AppSetting[] = stored ? JSON.parse(stored) : [];\n      \n      const categorySettings = settings.filter(s => s.category === category);\n\n      return {\n        data: categorySettings,\n        error: null,\n        success: true\n      };\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Get a specific setting (using localStorage fallback)\n  static async getSetting(category: string, settingKey: string): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      // Try localStorage fallback\n      const stored = localStorage.getItem(STORAGE_KEY);\n      const settings: AppSetting[] = stored ? JSON.parse(stored) : [];\n      \n      const setting = settings.find(s => s.category === category && s.setting_key === settingKey);\n\n      return {\n        data: setting || null,\n        error: null,\n        success: true\n      };\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Create a new setting (using localStorage fallback)\n  static async createSetting(setting: AppSettingInsert): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      // Get current user\n      const { user } = await authHelpers.getUser();\n      \n      // Create new setting\n      const newSetting: AppSetting = {\n        id: crypto.randomUUID(),\n        category: setting.category,\n        setting_key: setting.setting_key,\n        setting_value: setting.setting_value,\n        setting_json: setting.setting_json,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        updated_by: user?.id\n      };\n\n      // Save to localStorage\n      const stored = localStorage.getItem(STORAGE_KEY);\n      const settings: AppSetting[] = stored ? JSON.parse(stored) : [];\n      \n      // Check if setting already exists\n      const existingIndex = settings.findIndex(s => \n        s.category === setting.category && s.setting_key === setting.setting_key\n      );\n      \n      if (existingIndex >= 0) {\n        // Update existing\n        settings[existingIndex] = { ...settings[existingIndex], ...newSetting };\n      } else {\n        // Add new\n        settings.push(newSetting);\n      }\n      \n      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));\n\n      return {\n        data: newSetting,\n        error: null,\n        success: true\n      };\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Update an existing setting (using localStorage fallback)\n  static async updateSetting(\n    category: string, \n    settingKey: string, \n    updates: AppSettingUpdate\n  ): Promise<AppSettingsServiceResponse<AppSetting | null>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      // Get current user\n      const { user } = await authHelpers.getUser();\n      \n      // Get from localStorage\n      const stored = localStorage.getItem(STORAGE_KEY);\n      const settings: AppSetting[] = stored ? JSON.parse(stored) : [];\n      \n      const settingIndex = settings.findIndex(s => \n        s.category === category && s.setting_key === settingKey\n      );\n      \n      if (settingIndex === -1) {\n        return {\n          data: null,\n          error: 'Setting not found',\n          success: false\n        };\n      }\n      \n      // Update the setting\n      settings[settingIndex] = {\n        ...settings[settingIndex],\n        ...updates,\n        updated_at: new Date().toISOString(),\n        updated_by: user?.id\n      };\n      \n      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));\n\n      return {\n        data: settings[settingIndex],\n        error: null,\n        success: true\n      };\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Delete a setting (using localStorage fallback)\n  static async deleteSetting(category: string, settingKey: string): Promise<AppSettingsServiceResponse<boolean>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: false,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      // Get from localStorage\n      const stored = localStorage.getItem(STORAGE_KEY);\n      const settings: AppSetting[] = stored ? JSON.parse(stored) : [];\n      \n      const settingIndex = settings.findIndex(s => \n        s.category === category && s.setting_key === settingKey\n      );\n      \n      if (settingIndex === -1) {\n        return {\n          data: false,\n          error: 'Setting not found',\n          success: false\n        };\n      }\n      \n      // Remove the setting\n      settings.splice(settingIndex, 1);\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));\n\n      return {\n        data: true,\n        error: null,\n        success: true\n      };\n    } catch (error: any) {\n      return {\n        data: false,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n\n  // Get setting value directly\n  static async getSettingValue(category: string, settingKey: string): Promise<any> {\n    const result = await this.getSetting(category, settingKey);\n    if (result.success && result.data) {\n      return result.data.setting_json || result.data.setting_value;\n    }\n    return null;\n  }\n\n  // Get all categories\n  static async getCategories(): Promise<AppSettingsServiceResponse<string[]>> {\n    try {\n      const hasPermission = await this.checkPermissions();\n      if (!hasPermission) {\n        return {\n          data: null,\n          error: 'Insufficient permissions',\n          success: false\n        };\n      }\n\n      // Get from localStorage\n      const stored = localStorage.getItem(STORAGE_KEY);\n      const settings: AppSetting[] = stored ? JSON.parse(stored) : [];\n      \n      const categories = [...new Set(settings.map(s => s.category))];\n\n      return {\n        data: categories,\n        error: null,\n        success: true\n      };\n    } catch (error: any) {\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n  }\n}\n\n// Export both the class and an instance\nexport { AppSettingsService };\nexport const appSettingsService = new AppSettingsService();","type TelemetryEvent = {\n  id: string;\n  timestamp: string;\n  category: string; // e.g., 'location_cache'\n  action: string;   // e.g., 'refresh' | 'prewarm'\n  payload?: Record<string, any>;\n};\n\nimport { supabase } from '@/lib/supabaseClient';\n\nclass TelemetryService {\n  private storageKey = 'telemetry_events';\n  private maxEvents = 1000;\n  private uploaderRunning = false;\n  private uploadTimer: number | null = null;\n  private baseIntervalMs = 30000; // 30s\n  private currentIntervalMs = this.baseIntervalMs;\n  private maxIntervalMs = 5 * 60 * 1000; // 5 minutes\n  private endpointUrl: string | null = (import.meta as any)?.env?.VITE_TELEMETRY_ENDPOINT || null;\n  private useSupabase = ((import.meta as any)?.env?.VITE_ENABLE_TELEMETRY_SUPABASE === 'true');\n\n  private load(): TelemetryEvent[] {\n    try {\n      const raw = typeof window !== 'undefined' ? localStorage.getItem(this.storageKey) : null;\n      if (!raw) return [];\n      const parsed = JSON.parse(raw);\n      return Array.isArray(parsed) ? parsed : [];\n    } catch {\n      return [];\n    }\n  }\n\n  private save(events: TelemetryEvent[]): void {\n    try {\n      if (typeof window !== 'undefined') {\n        localStorage.setItem(this.storageKey, JSON.stringify(events.slice(-this.maxEvents)));\n      }\n    } catch {\n      // Ignore storage errors in dev\n    }\n  }\n\n  recordEvent(category: string, action: string, payload?: Record<string, any>): void {\n    const event: TelemetryEvent = {\n      id: `${category}_${action}_${Date.now()}`,\n      timestamp: new Date().toISOString(),\n      category,\n      action,\n      payload: this.sanitizePayload(payload || {}),\n    };\n    const events = this.load();\n    events.push(event);\n    this.save(events);\n    // Also surface in console during development for quick visibility\n    if (import.meta.env.DEV) {\n      // eslint-disable-next-line no-console\n      console.debug('[Telemetry]', category, action, payload || {});\n    }\n  }\n\n  getEvents(category?: string): TelemetryEvent[] {\n    const events = this.load();\n    return category ? events.filter(e => e.category === category) : events;\n  }\n\n  configure(opts: { endpointUrl?: string | null; useSupabase?: boolean; intervalMs?: number } = {}): void {\n    if (typeof opts.endpointUrl !== 'undefined') this.endpointUrl = opts.endpointUrl || null;\n    if (typeof opts.useSupabase !== 'undefined') this.useSupabase = !!opts.useSupabase;\n    if (typeof opts.intervalMs === 'number' && opts.intervalMs > 5000) {\n      this.baseIntervalMs = opts.intervalMs;\n      this.currentIntervalMs = opts.intervalMs;\n    }\n  }\n\n  startUploader(): void {\n    if (this.uploaderRunning) return;\n    this.uploaderRunning = true;\n    const schedule = () => {\n      if (!this.uploaderRunning) return;\n      this.uploadTimer = window.setTimeout(async () => {\n        const ok = await this.flush();\n        // Backoff on failure; reset on success\n        if (ok) {\n          this.currentIntervalMs = this.baseIntervalMs;\n        } else {\n          this.currentIntervalMs = Math.min(this.currentIntervalMs * 2, this.maxIntervalMs);\n        }\n        schedule();\n      }, this.currentIntervalMs);\n    };\n    schedule();\n  }\n\n  stopUploader(): void {\n    this.uploaderRunning = false;\n    if (this.uploadTimer) {\n      clearTimeout(this.uploadTimer);\n      this.uploadTimer = null;\n    }\n  }\n\n  async flush(): Promise<boolean> {\n    const events = this.load();\n    if (!events.length) return true;\n\n    // Prefer HTTP endpoint if configured; else attempt Supabase\n    try {\n      if (this.endpointUrl) {\n        const res = await fetch(this.endpointUrl, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ events }),\n        });\n        if (!res.ok) throw new Error(`HTTP ${res.status}`);\n        this.save([]);\n        return true;\n      } else if (this.useSupabase) {\n        // Map events to telemetry table rows\n        const rows = events.map(e => ({\n          id: e.id,\n          timestamp: e.timestamp,\n          category: e.category,\n          action: e.action,\n          payload: e.payload || {},\n        }));\n        // Cast to untyped client to avoid strict schema union blocking custom tables\n        const client: any = supabase;\n        const { error } = await client.from('telemetry_events').insert(rows);\n        if (error) throw error;\n        this.save([]);\n        return true;\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      if (import.meta.env.DEV) console.warn('Telemetry flush failed:', err);\n      return false;\n    }\n\n    // No sink configured; treat as success so we don't backoff endlessly\n    return true;\n  }\n\n  private sanitizePayload(payload: Record<string, any>): Record<string, any> {\n    // Drop known PII keys; limit string sizes; basic safety\n    const disallowed = new Set(['email', 'name', 'userId', 'phone', 'address']);\n    const result: Record<string, any> = {};\n    for (const [k, v] of Object.entries(payload)) {\n      if (disallowed.has(k)) continue;\n      if (typeof v === 'string') {\n        result[k] = v.length > 256 ? v.slice(0, 256) : v;\n      } else if (typeof v === 'object' && v !== null) {\n        // Shallow clone to avoid circular refs\n        result[k] = JSON.parse(JSON.stringify(v));\n      } else {\n        result[k] = v;\n      }\n    }\n    return result;\n  }\n}\n\nexport const telemetryService = new TelemetryService();","import { adminSupabase, supabase } from '@/lib/supabaseClient';\nimport type { Tables } from '@/integrations/supabase/types';\nimport { v4 as uuidv4 } from 'uuid';\nimport { telemetryService } from '@/services/telemetryService';\n\nexport type LocationCodeRow = Tables<'location_codes'>;\n\n/**\n * Service for resolving location codes to full names and location details\n */\nclass LocationResolutionService {\n  private locationCache: Map<string, LocationCodeRow> = new Map();\n  private cacheExpiry: number = 5 * 60 * 1000; // 5 minutes\n  private lastCacheUpdate: number = 0;\n  private lastCacheSource: 'supabase' | 'localStorage' | 'sample' | 'unknown' = 'unknown';\n  private lastRefreshDurationMs: number = 0;\n\n  /**\n   * Get location details by code\n   */\n  async getLocationByCode(code: string): Promise<LocationCodeRow | null> {\n    // Check cache first\n    if (this.isValidCache() && this.locationCache.has(code)) {\n      return this.locationCache.get(code) || null;\n    }\n\n    // Refresh cache if needed\n    if (!this.isValidCache()) {\n      await this.refreshCache();\n    }\n\n    return this.locationCache.get(code) || null;\n  }\n\n  /**\n   * Get full name for a location code\n   */\n  async getLocationFullName(code: string): Promise<string | null> {\n    const location = await this.getLocationByCode(code);\n    return location?.full_name || null;\n  }\n\n  /**\n   * Resolve multiple location codes to full names\n   */\n  async resolveLocationCodes(codes: string[]): Promise<Record<string, string | null>> {\n    const result: Record<string, string | null> = {};\n    \n    for (const code of codes) {\n      result[code] = await this.getLocationFullName(code);\n    }\n    \n    return result;\n  }\n\n  /**\n   * Get all active locations\n   */\n  async getAllActiveLocations(): Promise<LocationCodeRow[]> {\n    if (!this.isValidCache()) {\n      await this.refreshCache();\n    }\n    \n    return Array.from(this.locationCache.values()).filter(loc => loc.status === 'active');\n  }\n\n  /**\n   * Search locations by partial code or name\n   */\n  async searchLocations(query: string, limit: number = 10): Promise<LocationCodeRow[]> {\n    if (!this.isValidCache()) {\n      await this.refreshCache();\n    }\n\n    const searchTerm = query.toLowerCase();\n    const results = Array.from(this.locationCache.values())\n      .filter(loc => \n        loc.status === 'active' && (\n          loc.code.toLowerCase().includes(searchTerm) ||\n          loc.full_name.toLowerCase().includes(searchTerm) ||\n          loc.city?.toLowerCase().includes(searchTerm) ||\n          loc.country?.toLowerCase().includes(searchTerm)\n        )\n      )\n      .slice(0, limit);\n\n    return results;\n  }\n\n  /**\n   * Refresh the location cache\n   */\n  private async refreshCache(): Promise<void> {\n    const refreshStart = Date.now();\n    try {\n      // Use admin client for better performance, fallback to regular client\n      const client = adminSupabase || supabase;\n      \n      const { data, error } = await client\n        .from('location_codes')\n        .select('*')\n        .eq('status', 'active')\n        .order('code', { ascending: true });\n\n      if (error) {\n        const errorMessage = error.message?.toLowerCase() || '';\n        const errorCode = error.code || '';\n        \n        // Handle specific error codes that indicate database access issues (like RLS policies)\n        if (\n          errorCode === '406' ||\n          errorCode === 'PGRST301' ||\n          errorCode === 'PGRST116' ||\n          errorMessage.includes('not acceptable') ||\n          errorMessage.includes('permission denied') ||\n          errorMessage.includes('does not exist')\n        ) {\n          console.warn('LocationResolutionService: Database table not accessible due to permissions/RLS policies:', error);\n        } else {\n          console.warn('LocationResolutionService: Failed to refresh location cache from Supabase. Falling back to local/sample data.', error);\n        }\n        // Fallback: try loading from local storage or sample data\n        const fallback = this.loadFallback();\n        if (fallback.rows.length > 0) {\n          this.rebuildCache(fallback.rows);\n          this.lastCacheUpdate = Date.now();\n          this.lastCacheSource = fallback.source;\n          this.lastRefreshDurationMs = Date.now() - refreshStart;\n          telemetryService.recordEvent('location_cache', 'refresh', {\n            source: this.lastCacheSource,\n            rows: this.locationCache.size,\n            duration_ms: this.lastRefreshDurationMs,\n            success: false,\n            error_code: errorCode,\n            error_message: error.message || 'unknown',\n          });\n        }\n        return;\n      }\n\n      // If Supabase returns no data, use local/sample fallback to keep UX smooth\n      if (data && data.length > 0) {\n        this.rebuildCache(data);\n        this.lastCacheSource = 'supabase';\n      } else {\n        const fallback = this.loadFallback();\n        this.rebuildCache(fallback.rows);\n        this.lastCacheSource = fallback.source;\n      }\n\n      this.lastCacheUpdate = Date.now();\n      this.lastRefreshDurationMs = Date.now() - refreshStart;\n      telemetryService.recordEvent('location_cache', 'refresh', {\n        source: this.lastCacheSource,\n        rows: this.locationCache.size,\n        duration_ms: this.lastRefreshDurationMs,\n        success: true,\n      });\n    } catch (error) {\n      console.warn('LocationResolutionService: Exception while refreshing cache. Falling back to local/sample data.', error);\n      const fallback = this.loadFallback();\n      if (fallback.rows.length > 0) {\n        this.rebuildCache(fallback.rows);\n        this.lastCacheUpdate = Date.now();\n        this.lastCacheSource = fallback.source;\n        this.lastRefreshDurationMs = Date.now() - refreshStart;\n        telemetryService.recordEvent('location_cache', 'refresh', {\n          source: this.lastCacheSource,\n          rows: this.locationCache.size,\n          duration_ms: this.lastRefreshDurationMs,\n          success: false,\n          error_message: error instanceof Error ? error.message : 'unknown',\n        });\n      }\n    }\n  }\n\n  /**\n   * Check if cache is still valid\n   */\n  private isValidCache(): boolean {\n    return Date.now() - this.lastCacheUpdate < this.cacheExpiry;\n  }\n\n  /**\n   * Clear the cache (useful for testing or forced refresh)\n   */\n  clearCache(): void {\n    this.locationCache.clear();\n    this.lastCacheUpdate = 0;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; lastUpdate: Date | null; isValid: boolean } {\n    return {\n      size: this.locationCache.size,\n      lastUpdate: this.lastCacheUpdate ? new Date(this.lastCacheUpdate) : null,\n      isValid: this.isValidCache()\n    };\n  }\n\n  /**\n   * Get last cache source and timing for telemetry & monitoring\n   */\n  getLastCacheSource(): { source: string; duration_ms: number } {\n    return { source: this.lastCacheSource, duration_ms: this.lastRefreshDurationMs };\n  }\n\n  /**\n   * Public method to pre-warm cache on app start without blocking UI\n   */\n  async prewarmCache(force: boolean = false): Promise<void> {\n    if (force || !this.isValidCache()) {\n      const start = Date.now();\n      await this.refreshCache();\n      telemetryService.recordEvent('location_cache', 'prewarm', {\n        source: this.lastCacheSource,\n        rows: this.locationCache.size,\n        duration_ms: Date.now() - start,\n      });\n    }\n  }\n\n  /**\n   * Attempt to load location data from localStorage or a small sample dataset.\n   * Provides resilience when Supabase is unreachable in local/dev environments.\n   */\n  private loadFallback(): { rows: LocationCodeRow[]; source: 'localStorage' | 'sample' } {\n    try {\n      // Try localStorage first (used by LocationCodesManager and hooks)\n      const raw = typeof window !== 'undefined' ? localStorage.getItem('locationCodes') : null;\n      if (raw) {\n        const parsed = JSON.parse(raw);\n        if (Array.isArray(parsed)) {\n          return {\n            rows: parsed\n              .filter((loc: any) => (loc?.status ?? 'active') === 'active')\n              .map((loc: any) => this.mapLocalToRow(loc)),\n            source: 'localStorage',\n          };\n        }\n      }\n    } catch (e) {\n      // Ignore localStorage JSON parse errors and continue to sample fallback\n      console.warn('LocationResolutionService: Failed to load localStorage locationCodes, using sample data.', e);\n    }\n\n    // Minimal sample dataset to ensure the app remains usable without Supabase\n    const now = new Date().toISOString();\n    const sample: LocationCodeRow[] = [\n      {\n        id: uuidv4(), code: 'DXB', full_name: 'Dubai International Airport', category: 'airport',\n        country: 'United Arab Emirates', city: 'Dubai', status: 'active', notes: 'Sample fallback',\n        latitude: 25.2532, longitude: 55.3657, created_at: now, updated_at: now\n      },\n      {\n        id: uuidv4(), code: 'DWC', full_name: 'Al Maktoum International Airport', category: 'airport',\n        country: 'United Arab Emirates', city: 'Dubai', status: 'active', notes: 'Sample fallback',\n        latitude: 24.9182, longitude: 55.1742, created_at: now, updated_at: now\n      },\n      {\n        id: uuidv4(), code: 'AUH', full_name: 'Abu Dhabi International Airport', category: 'airport',\n        country: 'United Arab Emirates', city: 'Abu Dhabi', status: 'active', notes: 'Sample fallback',\n        latitude: 24.4539, longitude: 54.3773, created_at: now, updated_at: now\n      },\n      {\n        id: uuidv4(), code: 'SHJ', full_name: 'Sharjah International Airport', category: 'airport',\n        country: 'United Arab Emirates', city: 'Sharjah', status: 'active', notes: 'Sample fallback',\n        latitude: 25.3286, longitude: 55.5170, created_at: now, updated_at: now\n      },\n      {\n        id: uuidv4(), code: 'DEL', full_name: 'Indira Gandhi International Airport', category: 'airport',\n        country: 'India', city: 'Delhi', status: 'active', notes: 'Sample fallback',\n        latitude: 28.5562, longitude: 77.1000, created_at: now, updated_at: now\n      },\n      {\n        id: uuidv4(), code: 'BOM', full_name: 'Chhatrapati Shivaji Maharaj International Airport', category: 'airport',\n        country: 'India', city: 'Mumbai', status: 'active', notes: 'Sample fallback',\n        latitude: 19.0896, longitude: 72.8656, created_at: now, updated_at: now\n      },\n      {\n        id: uuidv4(), code: 'BLR', full_name: 'Kempegowda International Airport', category: 'airport',\n        country: 'India', city: 'Bangalore', status: 'active', notes: 'Sample fallback',\n        latitude: 13.1986, longitude: 77.7066, created_at: now, updated_at: now\n      },\n      {\n        id: uuidv4(), code: 'DXB APT', full_name: 'Dubai Airport City', category: 'city',\n        country: 'United Arab Emirates', city: 'Dubai', status: 'active', notes: 'Sample city code',\n        latitude: 25.2048, longitude: 55.2708, created_at: now, updated_at: now\n      },\n    ];\n\n    return { rows: sample, source: 'sample' };\n  }\n\n  private mapLocalToRow(loc: any): LocationCodeRow {\n    const now = new Date().toISOString();\n    const latitude = typeof loc?.latitude === 'string' ? Number(loc.latitude) : (loc?.latitude ?? null);\n    const longitude = typeof loc?.longitude === 'string' ? Number(loc.longitude) : (loc?.longitude ?? null);\n    return {\n      id: loc.id || uuidv4(),\n      code: loc.code,\n      full_name: loc.fullName || loc.full_name || loc.name || loc.code,\n      category: loc.category || 'city',\n      country: loc.country || 'Unknown',\n      city: loc.city || null,\n      status: loc.status || 'active',\n      notes: loc.notes ?? null,\n      latitude: Number.isFinite(latitude) ? latitude as number : null,\n      longitude: Number.isFinite(longitude) ? longitude as number : null,\n      created_at: loc.created_at || now,\n      updated_at: loc.updated_at || now,\n    } as LocationCodeRow;\n  }\n\n  private rebuildCache(rows: LocationCodeRow[] | null | undefined): void {\n    this.locationCache.clear();\n    (rows || []).forEach((location) => {\n      if (location && location.code) {\n        this.locationCache.set(location.code, location);\n      }\n    });\n  }\n}\n\n// Export singleton instance\nexport const locationResolutionService = new LocationResolutionService();\n\n/**\n * Utility function to resolve location codes in transport route data\n */\nexport async function resolveTransportRouteLocations(route: any): Promise<any> {\n  const resolvedRoute = { ...route };\n\n  // Resolve start location\n  if (route.start_location_code && !route.start_location_full_name) {\n    resolvedRoute.start_location_full_name = await locationResolutionService.getLocationFullName(route.start_location_code);\n  }\n\n  // Resolve end location\n  if (route.end_location_code && !route.end_location_full_name) {\n    resolvedRoute.end_location_full_name = await locationResolutionService.getLocationFullName(route.end_location_code);\n  }\n\n  // Resolve intermediate stops if they have location codes\n  if (route.intermediate_stops && Array.isArray(route.intermediate_stops)) {\n    resolvedRoute.intermediate_stops = await Promise.all(\n      route.intermediate_stops.map(async (stop: any) => {\n        if (stop.location_code && !stop.location_full_name) {\n          return {\n            ...stop,\n            location_full_name: await locationResolutionService.getLocationFullName(stop.location_code)\n          };\n        }\n        return stop;\n      })\n    );\n  }\n\n  // Resolve sightseeing locations if they have location codes\n  if (route.sightseeing_locations && Array.isArray(route.sightseeing_locations)) {\n    resolvedRoute.sightseeing_locations = await Promise.all(\n      route.sightseeing_locations.map(async (location: any) => {\n        if (location.location_code && !location.location_full_name) {\n          return {\n            ...location,\n            location_full_name: await locationResolutionService.getLocationFullName(location.location_code)\n          };\n        }\n        return location;\n      })\n    );\n  }\n\n  return resolvedRoute;\n}","import { supabase } from '@/lib/supabaseClient';\n\n// Get the API base URL from environment or use current origin\nconst getApiBaseUrl = () => {\n  // In development, use the API server on port 3002\n  if (import.meta.env.DEV) {\n    return 'http://localhost:3002';\n  }\n  // In production, use the deployed URL or current origin\n  // For Vercel deployments, use the current origin since API routes are served from the same domain\n  return window.location.origin;\n};\n\nexport const sendOtp = async (phone: string, type: 'login' | 'register' = 'login') => {\n  try {\n    const baseUrl = getApiBaseUrl();\n    console.log('Sending OTP to:', `${baseUrl}/api/sms/sendOtp`);\n    \n    const response = await fetch(`${baseUrl}/api/sms/sendOtp`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ phone, purpose: type }),\n    });\n\n    console.log('Response status:', response.status);\n    console.log('Response headers:', response.headers);\n    \n    // Check if response has content\n    const contentType = response.headers.get('content-type');\n    console.log('Content-Type:', contentType);\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Error response text:', errorText);\n      return { data: null, error: { message: `HTTP ${response.status}: ${errorText || 'Failed to send OTP'}` } };\n    }\n    \n    // Only try to parse JSON if content-type indicates JSON\n    if (contentType && contentType.includes('application/json')) {\n      const data = await response.json();\n      return { data, error: null };\n    } else {\n      // If not JSON, return the text response\n      const text = await response.text();\n      console.log('Non-JSON response:', text);\n      return { data: { message: text, status: 'sent' }, error: null };\n    }\n  } catch (error) {\n    console.error('Error sending OTP:', error);\n    return { data: null, error: { message: error instanceof Error ? error.message : 'Network error. Please check your connection.' } };\n  }\n};\n\nexport const verifyOtp = async (phone: string, requestId: string, otp: string) => {\n  try {\n    const baseUrl = getApiBaseUrl();\n    const response = await fetch(`${baseUrl}/api/sms/verifyOtp`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ phone, request_id: requestId, otp }),\n    });\n\n    const data = await response.json();\n    \n    if (!response.ok) {\n      return { data: null, error: { message: data.error || 'Failed to verify OTP' } };\n    }\n    \n    return { data, error: null };\n  } catch (error) {\n    console.error('Error verifying OTP:', error);\n    return { data: null, error: { message: 'Network error. Please check your connection.' } };\n  }\n};\n\nexport const upsertAgentWithPhone = async (phone: string, name: string) => {\n  try {\n    const baseUrl = getApiBaseUrl();\n    const response = await fetch(`${baseUrl}/api/auth/upsert-agent-phone`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ phone, name }),\n    });\n\n    const data = await response.json();\n    \n    if (!response.ok) {\n      return { data: null, error: { message: data.error || 'Failed to create agent account' } };\n    }\n    \n    return { data, error: null };\n  } catch (error) {\n    console.error('Error creating agent account:', error);\n    return { data: null, error: { message: 'Network error. Please check your connection.' } };\n  }\n};\n\nexport const getSmsConfigStatus = async () => {\n  try {\n    const baseUrl = getApiBaseUrl();\n    const response = await fetch(`${baseUrl}/api/sms/config-status`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({}),\n    });\n\n    const data = await response.json();\n    \n    if (!response.ok) {\n      return { ok: false, data: null, error: { message: data.error || 'Failed to get SMS config' } };\n    }\n    \n    return { ok: true, data, error: null };\n  } catch (error) {\n    console.error('Error getting SMS config:', error);\n    return { ok: false, data: null, error: { message: 'Network error. Please check your connection.' } };\n  }\n};\n\nexport const updateAccountEmail = async (userId: string, newEmail: string) => {\n  try {\n    const baseUrl = getApiBaseUrl();\n    const response = await fetch(`${baseUrl}/api/auth/update-email`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ user_id: userId, new_email: newEmail }),\n    });\n\n    const data = await response.json();\n    \n    if (!response.ok) {\n      return { data: null, error: { message: data.error || 'Failed to update email' } };\n    }\n    \n    return { data, error: null };\n  } catch (error) {\n    console.error('Error updating email:', error);\n    return { data: null, error: { message: 'Network error. Please check your connection.' } };\n  }\n};\n","import { supabase, adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\nimport { \n  ManagedAgent, \n  CreateAgentRequest, \n  UpdateAgentRequest, \n  AgentSignupRequest, \n  AgentFilters, \n  AgentApprovalRequest,\n  StaffMember,\n  AgentStatus\n} from '../types/agentManagement';\nimport { storeAgentCredentials } from '@/utils/agentAuth';\n\nexport class AgentManagementService {\n  // Helpers: detect missing table errors and localStorage fallback\n  private static isMissingTableError(error: any): boolean {\n    // Handle Supabase/PostgREST variants like PGRST205 and message wording\n    const code = (error && error.code) || '';\n    const msg = (error && (error.message || error)) || '';\n    const text = typeof msg === 'string' ? msg.toLowerCase() : '';\n    return (\n      code === 'PGRST205' ||\n      text.includes('could not find the table') ||\n      text.includes('schema cache') ||\n      text.includes('does not exist')\n    );\n  }\n\n  // Detect auth, permission or RLS-related errors to enable safe fallback\n  private static isAuthOrPermissionError(error: any): boolean {\n    const msg = (error && (error.message || error)) || '';\n    if (typeof msg !== 'string') return false;\n    const m = msg.toLowerCase();\n    return (\n      m.includes('permission denied') ||\n      m.includes('row level security') ||\n      m.includes('rls') ||\n      m.includes('not authenticated') ||\n      m.includes('auth') && m.includes('error') ||\n      m.includes('jwt') ||\n      m.includes('insert permission denied')\n    );\n  }\n\n  private static readAgentsFromStorage(): ManagedAgent[] {\n    try {\n      const raw = localStorage.getItem('managed_agents_fallback');\n      const list = raw ? JSON.parse(raw) : [];\n      return Array.isArray(list) ? list : [];\n    } catch {\n      return [];\n    }\n  }\n\n  private static writeAgentsToStorage(agents: ManagedAgent[]): void {\n    try {\n      localStorage.setItem('managed_agents_fallback', JSON.stringify(agents));\n    } catch {}\n  }\n  \n  // Normalize array-like fields that may arrive as JSON strings or Postgres array literals\n  private static normalizeArrayField(val: any): string[] | undefined {\n    if (val == null) return undefined;\n    if (Array.isArray(val)) {\n      return val.map((v) => (v == null ? '' : String(v))).filter(Boolean);\n    }\n    if (typeof val === 'string') {\n      const s = val.trim();\n      if (!s) return undefined;\n      // JSON array string: [\"a\",\"b\"]\n      if (s.startsWith('[') && s.endsWith(']')) {\n        try {\n          const parsed = JSON.parse(s);\n          return Array.isArray(parsed)\n            ? parsed.map((v: any) => (v == null ? '' : String(v))).filter(Boolean)\n            : undefined;\n        } catch {}\n      }\n      // Postgres array literal: {a,b,c} or {\"a\",\"b\"}\n      if (s.startsWith('{') && s.endsWith('}')) {\n        const inner = s.slice(1, -1);\n        const rawItems = inner.length ? inner.split(',') : [];\n        return rawItems\n          .map((item) => item.trim().replace(/^\"(.*)\"$/, '$1').replace(/\\\\\"/g, '\"'))\n          .filter(Boolean);\n      }\n      // Fallback: single string value\n      return [s];\n    }\n    return undefined;\n  }\n\n  // Normalize commission_structure when it comes as jsonb or JSON string\n  private static normalizeCommissionStructure(val: any): { type?: string; value?: number } | undefined {\n    if (val == null) return undefined;\n    let obj = val;\n    if (typeof obj === 'string') {\n      const s = obj.trim();\n      if (!s) return undefined;\n      try {\n        obj = JSON.parse(s);\n      } catch {\n        return undefined;\n      }\n    }\n    if (typeof obj === 'object') {\n      const type = (obj as any)?.type;\n      const rawValue = (obj as any)?.value;\n      const value = typeof rawValue === 'string' ? Number(rawValue) : rawValue;\n      return { type, value };\n    }\n    return undefined;\n  }\n  // Get all agents with optional filters (public.agents merged with profiles)\n  static async getAgents(filters?: AgentFilters): Promise<{ data: ManagedAgent[] | null; error: any }> {\n    try {\n      let agentQuery = (supabase as any)\n        .from('agents' as any)\n        .select('id,user_id,status,created_at,updated_at,created_by,source_type,source_details,agency_name,name,email,business_phone,profile_image,country,city,suspension_reason,suspended_at,suspended_by')\n        .order('created_at', { ascending: false });\n\n      if (filters?.status) {\n        agentQuery = agentQuery.eq('status', filters.status);\n      }\n\n      // Attempt to restrict view for staff users (best-effort without relying on missing columns)\n      let currentUserId: string | undefined;\n      let currentRole: string | undefined;\n      try {\n        const { data: { user } } = await supabase.auth.getUser();\n        currentUserId = user?.id;\n        // TEMPORARILY DISABLED: profiles query causing RLS infinite recursion\n        // TODO: Fix RLS policies on profiles table to enable role-based filtering\n        /*\n        if (currentUserId) {\n          const { data: me } = await supabase\n            .from('profiles')\n            .select('id,role')\n            .eq('id', currentUserId)\n            .maybeSingle();\n          currentRole = (me as any)?.role;\n        }\n        */\n        // Note: strict DB-side filtering by creator is disabled because agents.created_by is not available\n      } catch {}\n\n      const { data: agentsCore, error: agentsError } = await agentQuery;\n\n      if (agentsError && this.isMissingTableError(agentsError)) {\n        // Fallback to localStorage\n        let agents = this.readAgentsFromStorage();\n        if ((currentRole || '').toLowerCase() === 'staff' && currentUserId) {\n          agents = agents.filter(a => (a.created_by || '') === currentUserId);\n        }\n        if (filters?.status) {\n          agents = agents.filter(a => a.status === filters.status);\n        }\n        if (filters?.search) {\n          const s = (filters.search || '').toLowerCase();\n           agents = agents.filter(a =>\n             (a.name || '').toLowerCase().includes(s) ||\n             (a.email || '').toLowerCase().includes(s) ||\n             (a.company_name || '').toLowerCase().includes(s)\n           );\n        }\n        if (filters?.assigned_staff) {\n          agents = agents.filter(a => (a.assigned_staff || []).includes(filters.assigned_staff!));\n        }\n        return { data: agents, error: null };\n      }\n\n      if (!agentsCore || agentsCore.length === 0) {\n        return { data: [], error: null };\n      }\n\n      const ids = agentsCore.map(a => a.id);\n      // TEMPORARILY DISABLED: profiles query causing RLS infinite recursion\n      // const { data: profiles, error: profilesError } = await (supabase as any)\n      //   .from('profiles' as any)\n      //   .select('id,name,email,phone,company_name,created_at,updated_at,role')\n      //   .in('id', ids);\n\n      // if (profilesError) {\n      //   return { data: null, error: profilesError };\n      // }\n      \n      // Use empty profiles array to avoid recursion\n      const profiles: any[] = [];\n\n      const profileMap = new Map<string, any>();\n      (profiles || []).forEach(p => profileMap.set(p.id, p));\n\n      let merged: ManagedAgent[] = agentsCore.map((a: any) => {\n        const p = profileMap.get(a.id) || {};\n        // Prefer values from agents table; fall back to profiles if enabled later\n        const name = (a as any)?.name || (p as any)?.name || '';\n        const email = (a as any)?.email || (p as any)?.email || '';\n        const phone = (a as any)?.business_phone || (p as any)?.phone || '';\n        const company_name = (p as any)?.company_name || (a as any)?.agency_name || '';\n        const created_at = (a as any)?.created_at || (p as any)?.created_at || new Date().toISOString();\n        const updated_at = (a as any)?.updated_at || (p as any)?.updated_at || created_at;\n        return {\n          id: a.id,\n          user_id: (a as any)?.user_id,\n          name,\n          email,\n          phone,\n          company_name,\n          profile_image: (a as any)?.profile_image ?? (p as any)?.profile_image ?? undefined,\n          country: (a as any)?.country ?? (p as any)?.country ?? undefined,\n          city: (a as any)?.city ?? (p as any)?.city ?? undefined,\n          status: (a.status as AgentStatus) || ('pending' as AgentStatus),\n          role: 'agent',\n          source_type: a.source_type,\n          source_details: a.source_details,\n          created_by: a.created_by,\n          assigned_staff: [],\n          login_credentials: {},\n          suspension_reason: (a as any)?.suspension_reason ?? undefined,\n          suspended_at: (a as any)?.suspended_at ?? undefined,\n          suspended_by: (a as any)?.suspended_by ?? undefined,\n          created_at,\n          updated_at\n        } as ManagedAgent;\n      });\n\n      if (filters?.search) {\n        const s = filters.search.toLowerCase();\n        merged = merged.filter(a =>\n          (a.name || '').toLowerCase().includes(s) ||\n          (a.email || '').toLowerCase().includes(s) ||\n          (a.company_name || '').toLowerCase().includes(s)\n        );\n      }\n\n      return { data: merged, error: null };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Get a single agent by ID (agents + profiles)\n  static async getAgentById(id: string): Promise<{ data: ManagedAgent | null; error: any }> {\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { data: agentCore, error: agentError } = await (client as any)\n        .from('agents' as any)\n        // Read all relevant agent-owned columns\n        .select('id,user_id,status,created_at,updated_at,created_by,source_type,source_details,agency_name,agency_code,name,email,country,city,preferred_language,business_type,commission_type,commission_value,commission_structure,profile_image,business_phone,business_address,license_number,iata_number,specializations,website,alternate_email,mobile_numbers,documents,suspension_reason,suspended_at,suspended_by')\n        .eq('id', id)\n        .maybeSingle();\n\n      if (agentError && this.isMissingTableError(agentError)) {\n        // Final fallback: try Supabase Auth admin lookup to hydrate minimal agent\n        if (isAdminClientConfigured && adminSupabase) {\n          try {\n            const { data: adminUserData, error: adminUserError } = await (adminSupabase as any).auth.admin.getUserById(id);\n            if (!adminUserError && adminUserData?.user) {\n              const u = (adminUserData as any).user;\n              const mergedFromAuth: ManagedAgent = {\n                id: u.id,\n                user_id: u.id,\n                name: (u.user_metadata?.name as string) || '',\n                email: (u.email as string) || '',\n                phone: undefined,\n                company_name: '',\n                profile_image: undefined,\n                country: undefined,\n                city: undefined,\n                status: ('inactive' as AgentStatus),\n                role: 'agent',\n                source_type: 'other',\n                source_details: 'Derived from auth user',\n                created_by: undefined,\n                assigned_staff: [],\n                login_credentials: {},\n                created_at: (u.created_at as string) || new Date().toISOString(),\n                updated_at: (u.updated_at as string) || (u.created_at as string) || new Date().toISOString()\n              };\n              return { data: mergedFromAuth, error: null };\n            }\n          } catch {}\n        }\n\n        // Final fallback: try Supabase Auth admin lookup to hydrate minimal agent\n        if (isAdminClientConfigured && adminSupabase) {\n          try {\n            const { data: adminUserData, error: adminUserError } = await (adminSupabase as any).auth.admin.getUserById(id);\n            if (!adminUserError && adminUserData?.user) {\n              const u = (adminUserData as any).user;\n              const mergedFromAuth: ManagedAgent = {\n                id: u.id,\n                name: (u.user_metadata?.name as string) || '',\n                email: (u.email as string) || '',\n                phone: undefined,\n                company_name: '',\n                profile_image: undefined,\n                country: undefined,\n                city: undefined,\n                status: ('inactive' as AgentStatus),\n                role: 'agent',\n                source_type: 'other',\n                source_details: 'Derived from auth user',\n                created_by: undefined,\n                assigned_staff: [],\n                login_credentials: {},\n                created_at: (u.created_at as string) || new Date().toISOString(),\n                updated_at: (u.updated_at as string) || (u.created_at as string) || new Date().toISOString()\n              };\n              return { data: mergedFromAuth, error: null };\n            }\n          } catch {}\n        }\n\n        const agents = this.readAgentsFromStorage();\n        const found = agents.find(a => a.id === id) || null;\n        return { data: found, error: found ? null : 'Not found' };\n      }\n\n      if (!agentCore) {\n        // Try lookup by user_id first, then hydrate from profiles when missing\n        try {\n          const { data: byUser } = await (client as any)\n            .from('agents' as any)\n            .select('id,status,created_at,updated_at,created_by,source_type,source_details,agency_name,name,email,country,city,preferred_language,business_type,commission_type,commission_value,commission_structure,profile_image,business_phone,business_address,license_number,iata_number,specializations,website,alternate_email,mobile_numbers,documents,suspension_reason,suspended_at,suspended_by,user_id')\n            .eq('user_id', id)\n            .maybeSingle();\n          if (byUser) {\n            const merged: ManagedAgent = {\n              id: (byUser as any)?.id || id,\n              user_id: (byUser as any)?.user_id || id,\n              name: (byUser as any)?.name || (byUser as any)?.agency_name || '',\n              email: (byUser as any)?.email || '',\n              phone: (byUser as any)?.business_phone || undefined,\n              company_name: (byUser as any)?.agency_name || '',\n              profile_image: (byUser as any)?.profile_image ?? undefined,\n              country: (byUser as any)?.country ?? undefined,\n              city: (byUser as any)?.city ?? undefined,\n              status: ((byUser as any)?.status as AgentStatus) || ('pending' as AgentStatus),\n              role: 'agent',\n              type: (byUser as any)?.business_type || undefined,\n              commission_type: (byUser as any)?.commission_type || undefined,\n              commission_value: (byUser as any)?.commission_value || undefined,\n              commission_structure: AgentManagementService.normalizeCommissionStructure((byUser as any)?.commission_structure) || undefined,\n              source_type: (byUser as any)?.source_type,\n              source_details: (byUser as any)?.source_details,\n              created_by: (byUser as any)?.created_by,\n              assigned_staff: [],\n              login_credentials: {},\n              created_at: (byUser as any)?.created_at || new Date().toISOString(),\n              updated_at: (byUser as any)?.updated_at || new Date().toISOString(),\n              business_phone: (byUser as any)?.business_phone || undefined,\n              business_address: (byUser as any)?.business_address || undefined,\n              license_number: (byUser as any)?.license_number || undefined,\n              iata_number: (byUser as any)?.iata_number || undefined,\n              specializations: AgentManagementService.normalizeArrayField((byUser as any)?.specializations) || undefined,\n              preferred_language: (byUser as any)?.preferred_language ?? undefined,\n              alternate_email: (byUser as any)?.alternate_email || undefined,\n              website: (byUser as any)?.website || undefined,\n              partnership: (byUser as any)?.partnership || undefined,\n              mobile_numbers: AgentManagementService.normalizeArrayField((byUser as any)?.mobile_numbers) || undefined,\n              documents: AgentManagementService.normalizeArrayField((byUser as any)?.documents) || undefined,\n              suspension_reason: (byUser as any)?.suspension_reason ?? undefined,\n              suspended_at: (byUser as any)?.suspended_at ?? undefined,\n              suspended_by: (byUser as any)?.suspended_by ?? undefined,\n            };\n            if (!merged.commission_type && merged.commission_structure?.type) {\n              merged.commission_type = merged.commission_structure.type as any;\n            }\n            if ((merged.commission_value == null || merged.commission_value === undefined) && merged.commission_structure?.value != null) {\n              merged.commission_value = merged.commission_structure.value as any;\n            }\n            return { data: merged, error: null };\n          }\n        } catch {}\n        // Fallback: try to hydrate from profiles when agents row is missing\n        try {\n          const { data: profile } = await (client as any)\n            .from('profiles' as any)\n            .select('id,name,email,phone,company_name,profile_image,country,city,created_at,updated_at')\n            .eq('id', id)\n            .maybeSingle();\n\n          if (profile) {\n            const merged: ManagedAgent = {\n              id,\n              user_id: id,\n              name: (profile as any)?.name || '',\n              email: (profile as any)?.email || '',\n              phone: (profile as any)?.phone || undefined,\n              company_name: (profile as any)?.company_name || '',\n              profile_image: (profile as any)?.profile_image ?? undefined,\n              country: (profile as any)?.country ?? undefined,\n              city: (profile as any)?.city ?? undefined,\n              status: ('inactive' as AgentStatus),\n              role: 'agent',\n              source_type: 'other',\n              source_details: 'Derived from profile',\n              created_by: undefined,\n              assigned_staff: [],\n              login_credentials: {},\n              created_at: (profile as any)?.created_at || new Date().toISOString(),\n              updated_at: (profile as any)?.updated_at || new Date().toISOString()\n            };\n            return { data: merged, error: null };\n          }\n        } catch {}\n\n        // Fallback: try to hydrate from profiles when agents row is missing\n        try {\n          const { data: profile } = await (client as any)\n            .from('profiles' as any)\n            .select('id,name,email,phone,company_name,profile_image,country,city,created_at,updated_at')\n            .eq('id', id)\n            .maybeSingle();\n\n          if (profile) {\n            const merged: ManagedAgent = {\n              id,\n              name: (profile as any)?.name || '',\n              email: (profile as any)?.email || '',\n              phone: (profile as any)?.phone || undefined,\n              company_name: (profile as any)?.company_name || '',\n              profile_image: (profile as any)?.profile_image ?? undefined,\n              country: (profile as any)?.country ?? undefined,\n              city: (profile as any)?.city ?? undefined,\n              status: ('inactive' as AgentStatus),\n              role: 'agent',\n              source_type: 'other',\n              source_details: 'Derived from profile',\n              created_by: undefined,\n              assigned_staff: [],\n              login_credentials: {},\n              created_at: (profile as any)?.created_at || new Date().toISOString(),\n              updated_at: (profile as any)?.updated_at || new Date().toISOString()\n            };\n            return { data: merged, error: null };\n          }\n        } catch {}\n\n        const agents = this.readAgentsFromStorage();\n        const found = agents.find(a => a.id === id) || null;\n        return { data: found, error: found ? null : 'Not found' };\n      }\n\n      const merged: ManagedAgent = {\n        id,\n        user_id: (agentCore as any)?.user_id || id,\n        name: (agentCore as any)?.name || (agentCore as any)?.agency_name || '',\n        email: (agentCore as any)?.email || '',\n        phone: (agentCore as any)?.business_phone || undefined,\n        company_name: (agentCore as any)?.agency_name || '',\n        agency_code: (agentCore as any)?.agency_code || undefined,\n        profile_image: (agentCore as any)?.profile_image ?? undefined,\n        country: (agentCore as any)?.country ?? undefined,\n        city: (agentCore as any)?.city ?? undefined,\n        status: (agentCore.status as AgentStatus) || ('pending' as AgentStatus),\n        role: 'agent',\n        type: (agentCore as any)?.business_type || undefined,\n        commission_type: (agentCore as any)?.commission_type || undefined,\n        commission_value: (agentCore as any)?.commission_value || undefined,\n        commission_structure: AgentManagementService.normalizeCommissionStructure((agentCore as any)?.commission_structure) || undefined,\n        source_type: (agentCore as any)?.source_type,\n        source_details: (agentCore as any)?.source_details,\n        created_by: (agentCore as any)?.created_by,\n        assigned_staff: [],\n        login_credentials: {},\n        created_at: (agentCore as any)?.created_at || new Date().toISOString(),\n        updated_at: (agentCore as any)?.updated_at || new Date().toISOString(),\n        // Extended fields\n        business_phone: (agentCore as any)?.business_phone || undefined,\n        business_address: (agentCore as any)?.business_address || undefined,\n        license_number: (agentCore as any)?.license_number || undefined,\n        iata_number: (agentCore as any)?.iata_number || undefined,\n        specializations: AgentManagementService.normalizeArrayField((agentCore as any)?.specializations) || undefined,\n        preferred_language: (agentCore as any)?.preferred_language ?? undefined,\n        alternate_email: (agentCore as any)?.alternate_email || undefined,\n        website: (agentCore as any)?.website || undefined,\n        partnership: (agentCore as any)?.partnership || undefined,\n        // note: mobile_numbers in agentCore is array or null\n        mobile_numbers: AgentManagementService.normalizeArrayField((agentCore as any)?.mobile_numbers) || undefined,\n        documents: AgentManagementService.normalizeArrayField((agentCore as any)?.documents) || undefined,\n        suspension_reason: (agentCore as any)?.suspension_reason ?? undefined,\n        suspended_at: (agentCore as any)?.suspended_at ?? undefined,\n        suspended_by: (agentCore as any)?.suspended_by ?? undefined,\n      };\n\n      // Derive commission_type/value from commission_structure for UI if missing\n      if (!merged.commission_type && merged.commission_structure?.type) {\n        merged.commission_type = merged.commission_structure.type as any;\n      }\n      if ((merged.commission_value == null || merged.commission_value === undefined) && merged.commission_structure?.value != null) {\n        merged.commission_value = merged.commission_structure.value as any;\n      }\n\n      return { data: merged, error: null };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Create a new agent (by admin/staff) -> create profile + agents row\n  static async createAgent(agentData: CreateAgentRequest): Promise<{ data: ManagedAgent | null; error: any }> {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      const defaultStatus: AgentStatus = 'inactive';\n\n      // Resolve creator profile for source attribution\n      let creatorProfile: { id: string; name?: string; role?: string; email?: string } | null = null;\n      if (user?.id) {\n        try {\n          const { data: cp } = await supabase\n            .from('profiles')\n            .select('id,name,role,email')\n            .eq('id', user.id)\n            .maybeSingle();\n          creatorProfile = (cp as any) || null;\n        } catch {}\n      }\n\n      const creatorLabel = (creatorProfile?.role || '').toLowerCase() === 'admin' ? 'Admin' : 'Staff';\n      const sourceDetails = creatorProfile\n        ? `Created by ${creatorLabel}: ${creatorProfile.name || creatorProfile.email || ''}`\n        : (user?.email ? `Created by: ${user.email}` : 'Created internally');\n\n      // Determine primary staff to assign\n      const primaryStaffId = agentData.primary_staff_id || creatorProfile?.id || user?.id || null;\n\n      // Attempt transactional creation via RPC\n      const { data: rpcData, error: rpcError } = await (supabase as any).rpc('create_new_agent', {\n        p_name: agentData.name,\n        p_email: agentData.email,\n        p_phone: agentData.phone ?? null,\n        p_company_name: agentData.company_name ?? null,\n        p_agency_code: (agentData as any)?.agency_code ?? null,\n        p_country: null,\n        p_city: null,\n        p_business_type: null,\n        p_source_type: 'other',\n        p_source_details: sourceDetails,\n        p_staff_id: primaryStaffId ?? null,\n        p_notes: agentData.notes ?? null,\n      });\n\n      // Fallback: local storage when RPC fails hard (e.g., missing function or permission)\n      if (rpcError || !rpcData || (rpcData as any)?.ok === false) {\n        const errorMsg = (rpcError as any)?.message || (rpcData as any)?.error || 'Failed to create agent';\n\n        // Soft fallback to local storage to keep UI responsive in dev\n        const now = new Date().toISOString();\n        const localId = (typeof crypto !== 'undefined' && (crypto as any).randomUUID)\n          ? (crypto as any).randomUUID()\n          : `local_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;\n\n        const newAgent: ManagedAgent = {\n          id: localId,\n          name: agentData.name,\n          email: agentData.email,\n          phone: agentData.phone,\n          company_name: agentData.company_name || '',\n          status: agentData.status || defaultStatus,\n          role: 'agent',\n          source_type: 'other',\n          source_details: sourceDetails,\n          created_by: creatorProfile?.id || user?.id || undefined,\n          assigned_staff: Array.isArray(agentData.assigned_staff) ? agentData.assigned_staff : [],\n          login_credentials: {},\n          created_at: now,\n          updated_at: now,\n        } as ManagedAgent;\n\n        const stored = this.readAgentsFromStorage();\n        stored.unshift(newAgent);\n        this.writeAgentsToStorage(stored);\n\n        return { data: newAgent, error: errorMsg };\n      }\n\n      const result = rpcData as any;\n      const agentId: string | undefined = result?.agent_id ? String(result.agent_id) : undefined;\n\n      if (!agentId) {\n        // If server reported an existing agent, try to fetch it\n        const existingId = result?.agent_id ? String(result.agent_id) : undefined;\n        if (existingId) {\n          const existing = await this.getAgentById(existingId);\n          return { data: existing.data, error: null };\n        }\n        return { data: null, error: 'Agent creation returned no ID' };\n      }\n\n      // Optionally update status to requested value if differs from RPC default\n      if (agentData.status === 'active') {\n        try {\n          await this.updateAgent({ id: agentId, status: 'active' });\n        } catch {}\n      }\n\n      // Persist secondary staff assignments (besides primary) if provided\n      const additionalStaff = (agentData.assigned_staff || []).filter(sid => String(sid) !== String(primaryStaffId || ''));\n      if (additionalStaff.length > 0) {\n        for (const sid of additionalStaff) {\n          try {\n            await this.addStaffAssignmentToAgent(agentId, String(sid), { isPrimary: false, notes: agentData.notes });\n          } catch {}\n        }\n      }\n\n      // Return full merged agent\n      const full = await this.getAgentById(agentId);\n      return { data: full.data as any, error: null };\n\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Update an existing agent (profiles + agents extended fields)\n  static async updateAgent(agentData: UpdateAgentRequest): Promise<{ data: ManagedAgent | null; error: any }> {\n    try {\n      const {\n        id,\n        status,\n        name,\n        email,\n        phone,\n        company_name,\n        profile_image,\n        preferred_language,\n        country,\n        city,\n        type,\n        commission_type,\n        commission_value,\n        source_type,\n        source_details,\n        // extended\n        business_phone,\n        business_address,\n        license_number,\n        iata_number,\n        specializations,\n        alternate_email,\n        website,\n        partnership,\n        mobile_numbers,\n      } = agentData;\n\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\n      // Profiles update removed; all fields now persisted in 'agents' table.\n\n      // Build agents update payload\n      const agentUpdate: any = {};\n      if (status !== undefined) agentUpdate.status = status;\n      if (type !== undefined) agentUpdate.business_type = type;\n      if (commission_type !== undefined) agentUpdate.commission_type = commission_type;\n      if (commission_value !== undefined) agentUpdate.commission_value = typeof commission_value === 'string' ? parseFloat(commission_value) : commission_value as any;\n      if (source_type !== undefined) agentUpdate.source_type = source_type;\n      if (source_details !== undefined) agentUpdate.source_details = source_details;\n      // Keep agents table in sync: map company_name  agency_name\n      if (company_name !== undefined) agentUpdate.agency_name = company_name;\n      if (country !== undefined) agentUpdate.country = country;\n      if (city !== undefined) agentUpdate.city = city;\n      // Core identity fields\n      if (name !== undefined) agentUpdate.name = name;\n      if (email !== undefined) agentUpdate.email = email;\n      if (profile_image !== undefined) agentUpdate.profile_image = profile_image;\n      if (preferred_language !== undefined) agentUpdate.preferred_language = preferred_language;\n      // Extended fields in agents table\n      if (business_phone !== undefined) agentUpdate.business_phone = business_phone;\n      if (business_address !== undefined) agentUpdate.business_address = business_address;\n      if (license_number !== undefined) agentUpdate.license_number = license_number;\n      if (iata_number !== undefined) agentUpdate.iata_number = iata_number;\n      if (specializations !== undefined) agentUpdate.specializations = specializations as any;\n      if (alternate_email !== undefined) agentUpdate.alternate_email = alternate_email;\n      if (website !== undefined) agentUpdate.website = website;\n      if (mobile_numbers !== undefined) agentUpdate.mobile_numbers = mobile_numbers;\n\n      if (Object.keys(agentUpdate).length > 0) {\n        const { error: agentErr } = await client\n          .from('agents')\n          .upsert({ id, user_id: id, ...agentUpdate }, { onConflict: 'id' });\n        // If there is a hard Supabase error (not missing table or permission), bubble it up.\n        if (agentErr && !this.isMissingTableError(agentErr) && !this.isAuthOrPermissionError(agentErr)) {\n          return { data: null, error: agentErr };\n        }\n\n        // Fallback path: if table is missing or RLS/permission blocks writes, persist to local storage\n        if (agentErr && (this.isMissingTableError(agentErr) || this.isAuthOrPermissionError(agentErr))) {\n          const now = new Date().toISOString();\n          const stored = this.readAgentsFromStorage();\n          const idx = stored.findIndex(a => a.id === id);\n          let updated: ManagedAgent;\n          if (idx >= 0) {\n            const prev = stored[idx];\n            updated = {\n              ...prev,\n              status: agentUpdate.status ?? prev.status,\n              name: agentUpdate.name ?? prev.name,\n              email: agentUpdate.email ?? prev.email,\n              phone: agentUpdate.business_phone ?? prev.phone,\n              company_name: agentUpdate.agency_name ?? prev.company_name,\n              profile_image: agentUpdate.profile_image ?? prev.profile_image,\n              preferred_language: agentUpdate.preferred_language ?? prev.preferred_language,\n              country: agentUpdate.country ?? prev.country,\n              city: agentUpdate.city ?? prev.city,\n              type: agentUpdate.business_type ?? prev.type,\n              commission_type: agentUpdate.commission_type ?? prev.commission_type,\n              commission_value: agentUpdate.commission_value ?? prev.commission_value,\n              source_type: agentUpdate.source_type ?? prev.source_type,\n              source_details: agentUpdate.source_details ?? prev.source_details,\n              business_phone: agentUpdate.business_phone ?? prev.business_phone,\n              business_address: agentUpdate.business_address ?? prev.business_address,\n              license_number: agentUpdate.license_number ?? prev.license_number,\n              iata_number: agentUpdate.iata_number ?? prev.iata_number,\n              specializations: (agentUpdate.specializations as any) ?? prev.specializations,\n              alternate_email: agentUpdate.alternate_email ?? prev.alternate_email,\n              website: agentUpdate.website ?? prev.website,\n              mobile_numbers: (agentUpdate.mobile_numbers as any) ?? prev.mobile_numbers,\n              updated_at: now\n            };\n            stored[idx] = updated;\n          } else {\n            updated = {\n              id,\n              user_id: id,\n              name: (agentUpdate.name as any) || '',\n              email: (agentUpdate.email as any) || '',\n              phone: (agentUpdate.business_phone as any) || undefined,\n              company_name: (agentUpdate.agency_name as any) || '',\n              profile_image: (agentUpdate.profile_image as any) ?? undefined,\n              preferred_language: (agentUpdate.preferred_language as any) ?? undefined,\n              country: (agentUpdate.country as any) ?? undefined,\n              city: (agentUpdate.city as any) ?? undefined,\n              status: ((agentUpdate.status as any) as AgentStatus) || ('inactive' as AgentStatus),\n              role: 'agent',\n              type: (agentUpdate.business_type as any) ?? undefined,\n              commission_type: (agentUpdate.commission_type as any) ?? undefined,\n              commission_value: (agentUpdate.commission_value as any) ?? undefined,\n              source_type: (agentUpdate.source_type as any) ?? undefined,\n              source_details: (agentUpdate.source_details as any) ?? undefined,\n              created_by: undefined,\n              assigned_staff: [],\n              login_credentials: {},\n              created_at: now,\n              updated_at: now,\n              business_phone: (agentUpdate.business_phone as any) ?? undefined,\n              business_address: (agentUpdate.business_address as any) ?? undefined,\n              license_number: (agentUpdate.license_number as any) ?? undefined,\n              iata_number: (agentUpdate.iata_number as any) ?? undefined,\n              specializations: (agentUpdate.specializations as any) ?? undefined,\n              alternate_email: (agentUpdate.alternate_email as any) ?? undefined,\n              website: (agentUpdate.website as any) ?? undefined,\n              partnership: undefined,\n              mobile_numbers: (agentUpdate.mobile_numbers as any) ?? undefined,\n            } as ManagedAgent;\n            stored.push(updated);\n          }\n          this.writeAgentsToStorage(stored);\n          return { data: updated, error: null };\n        }\n      }\n\n      // Persist non-agents columns in agent_settings.preferences\n      const prefsPatch: any = {};\n      if (partnership !== undefined) prefsPatch.partnership = partnership;\n\n      if (Object.keys(prefsPatch).length > 0) {\n        const { error: prefsErr } = await this.patchAgentSettingsPreferences(id, prefsPatch);\n        if (prefsErr) {\n          // Non-fatal: continue but report error\n          console.warn('patchAgentSettingsPreferences error:', prefsErr);\n        }\n      }\n\n      // Attempt to read the updated agent; if not found due to missing DB row or RLS, return local fallback\n      const result = await this.getAgentById(id);\n      if (result && result.error && (typeof result.error === 'string') && result.error.toLowerCase() === 'not found') {\n        const now = new Date().toISOString();\n        const stored = this.readAgentsFromStorage();\n        const idx = stored.findIndex(a => a.id === id);\n        let updated: ManagedAgent;\n        if (idx >= 0) {\n          const prev = stored[idx];\n          updated = {\n            ...prev,\n            status: (agentUpdate.status as any) ?? prev.status,\n            name: (agentUpdate.name as any) ?? prev.name,\n            email: (agentUpdate.email as any) ?? prev.email,\n            phone: (agentUpdate.business_phone as any) ?? prev.phone,\n            company_name: (agentUpdate.agency_name as any) ?? prev.company_name,\n            profile_image: (agentUpdate.profile_image as any) ?? prev.profile_image,\n            preferred_language: (agentUpdate.preferred_language as any) ?? prev.preferred_language,\n            country: (agentUpdate.country as any) ?? prev.country,\n            city: (agentUpdate.city as any) ?? prev.city,\n            type: (agentUpdate.business_type as any) ?? prev.type,\n            commission_type: (agentUpdate.commission_type as any) ?? prev.commission_type,\n            commission_value: (agentUpdate.commission_value as any) ?? prev.commission_value,\n            source_type: (agentUpdate.source_type as any) ?? prev.source_type,\n            source_details: (agentUpdate.source_details as any) ?? prev.source_details,\n            business_phone: (agentUpdate.business_phone as any) ?? prev.business_phone,\n            business_address: (agentUpdate.business_address as any) ?? prev.business_address,\n            license_number: (agentUpdate.license_number as any) ?? prev.license_number,\n            iata_number: (agentUpdate.iata_number as any) ?? prev.iata_number,\n            specializations: (agentUpdate.specializations as any) ?? prev.specializations,\n            alternate_email: (agentUpdate.alternate_email as any) ?? prev.alternate_email,\n            website: (agentUpdate.website as any) ?? prev.website,\n            mobile_numbers: (agentUpdate.mobile_numbers as any) ?? prev.mobile_numbers,\n            updated_at: now\n          };\n          stored[idx] = updated;\n        } else {\n          updated = {\n            id,\n            user_id: id,\n            name: (agentUpdate.name as any) || '',\n            email: (agentUpdate.email as any) || '',\n            phone: (agentUpdate.business_phone as any) || undefined,\n            company_name: (agentUpdate.agency_name as any) || '',\n            profile_image: (agentUpdate.profile_image as any) ?? undefined,\n            preferred_language: (agentUpdate.preferred_language as any) ?? undefined,\n            country: (agentUpdate.country as any) ?? undefined,\n            city: (agentUpdate.city as any) ?? undefined,\n            status: ((agentUpdate.status as any) as AgentStatus) || ('inactive' as AgentStatus),\n            role: 'agent',\n            type: (agentUpdate.business_type as any) ?? undefined,\n            commission_type: (agentUpdate.commission_type as any) ?? undefined,\n            commission_value: (agentUpdate.commission_value as any) ?? undefined,\n            source_type: (agentUpdate.source_type as any) ?? undefined,\n            source_details: (agentUpdate.source_details as any) ?? undefined,\n            created_by: undefined,\n            assigned_staff: [],\n            login_credentials: {},\n            created_at: now,\n            updated_at: now,\n            business_phone: (agentUpdate.business_phone as any) ?? undefined,\n            business_address: (agentUpdate.business_address as any) ?? undefined,\n            license_number: (agentUpdate.license_number as any) ?? undefined,\n            iata_number: (agentUpdate.iata_number as any) ?? undefined,\n            specializations: (agentUpdate.specializations as any) ?? undefined,\n            alternate_email: (agentUpdate.alternate_email as any) ?? undefined,\n            website: (agentUpdate.website as any) ?? undefined,\n            partnership: undefined,\n            mobile_numbers: (agentUpdate.mobile_numbers as any) ?? undefined,\n          } as ManagedAgent;\n          stored.push(updated);\n        }\n        this.writeAgentsToStorage(stored);\n        return { data: updated, error: null };\n      }\n      return result;\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Patch agent_settings.preferences JSON with a shallow merge\n  static async patchAgentSettingsPreferences(agentId: string, patch: any): Promise<{ error: any }> {\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { data: existing, error: selErr } = await client\n        .from('agent_settings')\n        .select('id,preferences')\n        .eq('agent_id', agentId)\n        .maybeSingle();\n      if (selErr && !this.isMissingTableError(selErr) && !this.isAuthOrPermissionError(selErr)) {\n        return { error: selErr };\n      }\n      const currentPrefs = (existing as any)?.preferences || {};\n      const merged = { ...currentPrefs, ...patch };\n\n      if ((existing as any)?.id) {\n        const { error } = await client\n          .from('agent_settings')\n          .update({ preferences: merged, updated_at: new Date().toISOString() })\n          .eq('id', (existing as any).id);\n        return { error };\n      } else {\n        const { error } = await client\n          .from('agent_settings')\n          .insert({ agent_id: agentId, preferences: merged, created_at: new Date().toISOString(), updated_at: new Date().toISOString() });\n        return { error };\n      }\n    } catch (err) {\n      return { error: err };\n    }\n  }\n\n  // Sync agent email across Supabase Auth (admin) and profiles table.\n  static async syncAgentEmailAcrossAuth(agentId: string, newEmail: string): Promise<{ error: any }> {\n    try {\n      // 1) Update Supabase Auth user email (requires admin client)\n      try {\n        if (isAdminClientConfigured && adminSupabase) {\n          await (adminSupabase as any).auth.admin.updateUserById(agentId, { email: newEmail });\n        } else {\n          console.warn('Admin client not configured; skipping Auth email sync');\n        }\n      } catch (authErr) {\n        // Non-fatal: continue but report\n        console.warn('Auth email update failed:', authErr);\n      }\n\n      // 2) Update profiles.email for consistency\n      try {\n        const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n        const { error: profileErr } = await client\n          .from('profiles')\n          .update({ email: newEmail, updated_at: new Date().toISOString() })\n          .eq('id', agentId);\n        if (profileErr && !this.isMissingTableError(profileErr) && !this.isAuthOrPermissionError(profileErr)) {\n          console.warn('profiles email sync failed:', profileErr);\n        }\n      } catch (profCatch) {\n        console.warn('profiles email sync error:', profCatch);\n      }\n\n      // 3) Best-effort: ensure agents.email is also in sync (callers usually do this already)\n      try {\n        const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n        const { error: agentErr } = await client\n          .from('agents')\n          .update({ email: newEmail, updated_at: new Date().toISOString() })\n          .eq('id', agentId);\n        if (agentErr && !this.isMissingTableError(agentErr) && !this.isAuthOrPermissionError(agentErr)) {\n          console.warn('agents email sync failed:', agentErr);\n        }\n      } catch (agentCatch) {\n        console.warn('agents email sync error:', agentCatch);\n      }\n\n      return { error: null };\n    } catch (error) {\n      return { error };\n    }\n  }\n\n  // Delete/deactivate an agent (set status inactive in public.agents)\n  static async deleteAgent(id: string): Promise<{ error: any }> {\n    try {\n      const { error } = await supabase\n        .from('agents')\n        .update({ status: 'inactive' })\n        .eq('id', id);\n      return { error };\n    } catch (error) {\n      return { error };\n    }\n  }\n\n  // Public agent signup\n  static async signupAgent(signupData: AgentSignupRequest): Promise<{ data: ManagedAgent | null; error: any }> {\n    try {\n      // Determine auto-approval setting\n      let autoApprove = false;\n      try {\n        const stored = localStorage.getItem('app_settings_fallback');\n        const settings = stored ? JSON.parse(stored) : [];\n        const found = settings.find((s: any) => s.category === 'Permissions & Roles' && s.setting_key === 'agents.auto_approve_signup');\n        if (found && (found.is_active !== false)) {\n          autoApprove = String(found.setting_value).toLowerCase() === 'true';\n        }\n      } catch {}\n\n      const status: AgentStatus = autoApprove ? 'active' : 'inactive';\n\n      // Duplicate email check before signup\n      try {\n        const dupeClient = isAdminClientConfigured && adminSupabase ? adminSupabase : supabase;\n        const { data: existingProfiles, error: dupeErr } = await dupeClient\n          .from('profiles')\n          .select('id')\n          .eq('email', signupData.email)\n          .limit(1);\n        if (!dupeErr && Array.isArray(existingProfiles) && existingProfiles.length > 0) {\n          return { data: null, error: 'Email already registered' };\n        }\n      } catch {}\n\n      // Sign up the agent in Supabase Auth\n      const { data: signUpData, error: signUpErr } = await supabase.auth.signUp({\n        email: signupData.email,\n        password: signupData.password || this.generateTemporaryPassword(),\n        options: {\n          emailRedirectTo: `${window.location.origin}/login`,\n          data: {\n            role: 'agent',\n            name: signupData.name,\n            phone: signupData.phone,\n            company_name: signupData.company_name\n          }\n        }\n      });\n\n      if (signUpErr) {\n        console.warn('Supabase Auth signup error; falling back:', signUpErr);\n      }\n\n      const authUserId: string | undefined = (signUpData as any)?.user?.id;\n      let profileId: string | undefined = authUserId;\n\n      // If no auth user was created, try admin to create one to satisfy FK\n      if (!profileId && isAdminClientConfigured && adminSupabase) {\n        try {\n          const { data: created, error: adminCreateErr } = (adminSupabase as any).auth.admin.createUser({\n            email: signupData.email,\n            password: signupData.password || this.generateTemporaryPassword(),\n            email_confirm: true,\n            user_metadata: {\n              role: 'agent',\n              name: signupData.name,\n              phone: signupData.phone,\n              company_name: signupData.company_name\n            }\n          });\n          if (!adminCreateErr && created?.user?.id) {\n            profileId = created.user.id;\n          }\n        } catch (e) {\n          console.warn('Admin createUser failed during signup:', e);\n        }\n      }\n\n      if (!profileId) {\n        // Final fallback only relevant for local storage path\n        profileId = (crypto?.randomUUID ? crypto.randomUUID() : Date.now().toString());\n      }\n\n      // If admin client is available, upsert profile and agents using admin client (bypass RLS)\n      if (isAdminClientConfigured && adminSupabase) {\n        try {\n          await adminSupabase\n            .from('profiles')\n            .upsert({\n              id: profileId,\n              name: signupData.name,\n              email: signupData.email,\n              phone: signupData.phone,\n              company_name: signupData.company_name,\n              role: 'agent',\n              city: signupData.city,\n              country: signupData.country,\n              updated_at: new Date().toISOString()\n            }, { onConflict: 'id' });\n\n          // Insert into agents table with all form fields using raw SQL\n          const { data: agentCore, error: agentErr } = await adminSupabase\n            .from('agents')\n            .upsert({\n              id: profileId,\n              user_id: profileId,\n              agency_name: signupData.company_name,\n              agency_code: signupData.agency_code,\n              business_phone: signupData.phone,\n              business_address: signupData.business_address,\n              specializations: Array.isArray(signupData.specializations)\n                ? signupData.specializations\n                : (signupData.specializations ? [signupData.specializations] : []),\n              status,\n              created_by: profileId,\n              source_type: signupData.source_type || 'organic',\n              source_details: signupData.source_details || 'direct_signup'\n            }, { onConflict: 'id' })\n            .select('id,status,created_at,updated_at,created_by,source_type,source_details')\n            .single();\n\n          // Update additional fields that are not in the typed interface using raw SQL\n          if (!agentErr && agentCore) {\n            await adminSupabase\n              .from('agents')\n              .update({\n                name: signupData.name,\n                email: signupData.email,\n                city: signupData.city,\n                country: signupData.country,\n                type: signupData.type,\n                agent_type: signupData.type,\n                notes: signupData.notes\n              } as any)\n              .eq('id', profileId);\n          }\n\n          if (!agentErr && agentCore) {\n            const merged: ManagedAgent = {\n              id: agentCore.id,\n              name: signupData.name,\n              email: signupData.email,\n              phone: signupData.phone,\n              company_name: signupData.company_name || '',\n              agency_code: signupData.agency_code || '',\n              notes: signupData.notes || '',\n              status: (agentCore.status as AgentStatus) || status,\n              role: 'agent',\n              created_by: (agentCore as any)?.created_by || profileId!,\n              source_type: (agentCore as any)?.source_type || ('organic' as any),\n              source_details: (agentCore as any)?.source_details || 'direct_signup',\n              assigned_staff: [],\n              login_credentials: {},\n              created_at: agentCore.created_at || new Date().toISOString(),\n              updated_at: agentCore.updated_at || new Date().toISOString()\n            };\n            return { data: merged, error: null };\n          }\n        } catch (e) {\n          console.warn('Admin upsert during signup failed; will try session client:', e);\n        }\n      }\n\n      // Session client fallback: attempt inserts; if RLS/FK errors, use local storage\n      const profileInsert = await supabase\n        .from('profiles')\n        .insert([{ id: profileId, name: signupData.name, email: signupData.email, phone: signupData.phone, company_name: signupData.company_name, role: 'agent', city: signupData.city, country: signupData.country }]);\n      if ((profileInsert as any)?.error) {\n        console.warn('Profile insert during signup failed (likely RLS/FK):', (profileInsert as any).error);\n      }\n\n      const agentInsert = await supabase\n        .from('agents')\n        .insert([{ \n          id: profileId, \n          user_id: profileId, \n          // Map form fields to agents table columns (only properly typed fields)\n          name: signupData.name,\n          email: signupData.email,\n          agency_name: signupData.company_name,\n          agency_code: signupData.agency_code,\n          business_phone: signupData.phone,\n          business_address: signupData.business_address,\n          city: signupData.city,\n          country: signupData.country,\n          type: signupData.type,\n          agent_type: signupData.type,\n          notes: signupData.notes,\n          specializations: Array.isArray(signupData.specializations)\n            ? signupData.specializations\n            : (signupData.specializations ? [signupData.specializations] : []),\n          status,\n          created_by: profileId\n        }]);\n      const insertErr = (agentInsert as any).error;\n\n      if (insertErr && (this.isMissingTableError(insertErr) || this.isAuthOrPermissionError(insertErr))) {\n        const agents = this.readAgentsFromStorage();\n        const now = new Date().toISOString();\n        const username = signupData.desired_username || (signupData.email?.split('@')[0] || 'agent');\n        const newAgent: ManagedAgent = {\n          id: profileId,\n          name: signupData.name,\n          email: signupData.email,\n          phone: signupData.phone,\n          company_name: signupData.company_name,\n          agency_code: signupData.agency_code,\n          notes: signupData.notes,\n          // Include additional form fields\n          country: signupData.country,\n          city: signupData.city,\n          type: signupData.type as 'individual' | 'company',\n          status,\n          role: 'agent',\n          created_by: profileId,\n          // Fallback local record uses signup attribution when available\n          source_type: (signupData.source_type as any) || 'organic',\n          source_details: signupData.source_details || 'direct_signup',\n          assigned_staff: [],\n          login_credentials: { username },\n          created_at: now,\n          updated_at: now\n        };\n        agents.unshift(newAgent);\n        this.writeAgentsToStorage(agents);\n\n        if (signupData.password) {\n          try {\n            storeAgentCredentials({\n              agentId: newAgent.id,\n              username,\n              password: signupData.password,\n              email: newAgent.email,\n              forcePasswordChange: false,\n              isTemporary: false,\n              createdAt: now,\n              createdBy: { staffId: profileId!, staffName: signupData.name || 'Agent' }\n            });\n          } catch (credErr) {\n            console.warn('Failed to store credentials locally:', credErr);\n          }\n        }\n        return { data: newAgent, error: null };\n      }\n\n      return { data: null, error: null };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Approve/reject agent (super admin only)\n  static async approveAgent(approvalData: AgentApprovalRequest): Promise<{ data: ManagedAgent | null; error: any }> {\n    try {\n      const { id, status, assigned_staff } = approvalData;\n      const client = isAdminClientConfigured ? adminSupabase : supabase;\n\n      // Centralize approval via RPC when activating; otherwise fallback to direct update\n      if (status === 'active') {\n        const { data: rpcData, error: rpcError } = await (client as any).rpc('approve_agent', { p_id: id });\n        if (rpcError) {\n          // Fallback to direct update if RPC unavailable\n          console.warn('approve_agent RPC failed, falling back:', rpcError);\n        } else if (rpcData && (rpcData as any).ok) {\n          // Merge updated agent\n          const { data: agentCore } = await client\n            .from('agents')\n            .select('id,status,created_at,updated_at')\n            .eq('id', id)\n            .single();\n\n          if (agentCore) {\n            const { data: profile } = await client\n              .from('profiles')\n              .select('name,email,phone,company_name,role,created_at,updated_at')\n              .eq('id', id)\n              .single();\n\n            const merged: ManagedAgent = {\n              id: agentCore.id,\n              name: (profile as any)?.name || '',\n              email: (profile as any)?.email || '',\n              phone: (profile as any)?.phone || '',\n              company_name: (profile as any)?.company_name || '',\n              status: (agentCore as any).status as any,\n              role: (profile as any)?.role || 'agent',\n              source_type: undefined,\n              source_details: undefined,\n              created_by: undefined,\n              assigned_staff: assigned_staff || [],\n              login_credentials: {},\n              created_at: (agentCore as any)?.created_at || (profile as any)?.created_at || new Date().toISOString(),\n              updated_at: (agentCore as any)?.updated_at || (profile as any)?.updated_at || new Date().toISOString()\n            };\n            return { data: merged, error: null };\n          }\n        } else if (rpcData && (rpcData as any).error) {\n          return { data: null, error: (rpcData as any).error };\n        }\n      }\n\n      // Persist status to public.agents when not activating via RPC; assigned_staff is tracked locally\n      const upd = await client\n        .from('agents')\n        .update({ status })\n        .eq('id', id)\n        .select('id,status,created_at,updated_at')\n        .single();\n\n      const data = (upd as any).data || null;\n      const error = (upd as any).error || null;\n\n      if (error && this.isMissingTableError(error)) {\n        // Fallback to localStorage\n        const agents = this.readAgentsFromStorage();\n        const idx = agents.findIndex(a => a.id === id);\n        if (idx >= 0) {\n          const updatePayload: Partial<ManagedAgent> = {\n            status: status as any,\n            ...(assigned_staff ? { assigned_staff } : {})\n          };\n          const updated = { ...agents[idx], ...updatePayload, updated_at: new Date().toISOString() } as ManagedAgent;\n          agents[idx] = updated;\n          this.writeAgentsToStorage(agents);\n          return { data: updated, error: null };\n        }\n        return { data: null, error: 'Agent not found' };\n      }\n\n      // Return full merged agent\n      const full = await this.getAgentById(id);\n      return { data: full.data as any, error };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Generate credentials for approved agent\n  static async generateCredentials(id: string): Promise<{ data: { username: string; temporaryPassword: string } | null; error: any }> {\n    try {\n      // Get agent details to create username\n      const { data: agent, error: agentError } = await supabase\n        .from('profiles')\n        .select('name, email')\n        .eq('id', id)\n        .single();\n\n      if (agentError || !agent) {\n        return { data: null, error: agentError || 'Agent not found' };\n      }\n\n      // Generate username from email or name (prefer full email for login)\n      const baseFromEmail = (agent as any).email ? String((agent as any).email).toLowerCase().trim() : '';\n      const baseFromName = (agent as any).name ? String((agent as any).name).toLowerCase().replace(/\\s+/g, '') : '';\n      const username = baseFromEmail || baseFromName || `agent_${id.slice(0, 6)}`;\n      const temporaryPassword = this.generateTemporaryPassword();\n\n      // Set credentials via secure RPC (temporary)\n      const client = isAdminClientConfigured ? adminSupabase : supabase;\n      const { error } = await (client as any).rpc('set_agent_credentials', {\n        p_id: id,\n        p_username: username,\n        p_password: temporaryPassword,\n        p_is_temporary: true\n      });\n\n      if (error) {\n        return { data: null, error };\n      }\n\n      return { data: { username, temporaryPassword }, error: null };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Reject agent application\n  static async rejectAgent(id: string, rejectionReason: string): Promise<{ data: ManagedAgent | null; error: any }> {\n    try {\n      const client = isAdminClientConfigured ? adminSupabase : supabase;\n      const { data, error } = await client\n        .from('agents')\n        .update({ status: 'rejected' })\n        .eq('id', id)\n        .select('id,status,created_at,updated_at')\n        .single();\n\n      if (error && this.isMissingTableError(error)) {\n        const agents = this.readAgentsFromStorage();\n        const idx = agents.findIndex(a => a.id === id);\n        if (idx >= 0) {\n          const updated = { ...agents[idx], status: 'rejected', updated_at: new Date().toISOString() } as ManagedAgent;\n          agents[idx] = updated;\n          this.writeAgentsToStorage(agents);\n          return { data: updated, error: null };\n        }\n      }\n\n      return { data: data as any, error };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Suspend an active agent\n  static async suspendAgent(id: string, reason: string): Promise<{ data: ManagedAgent | null; error: any }> {\n    try {\n      // Identify current user performing the action (best-effort)\n      let currentUserId: string | undefined;\n      try {\n        const { data: { user } } = await supabase.auth.getUser();\n        currentUserId = user?.id;\n      } catch {}\n\n      const client = isAdminClientConfigured ? adminSupabase : supabase;\n      const { data, error } = await client\n        .from('agents')\n        .update({ status: 'suspended', suspension_reason: reason, suspended_at: new Date().toISOString(), suspended_by: currentUserId })\n        .eq('user_id', id)\n        .select('id,status,created_at,updated_at,suspension_reason,suspended_at,suspended_by')\n        .single();\n\n      if (error && this.isMissingTableError(error)) {\n        const agents = this.readAgentsFromStorage();\n        const idx = agents.findIndex(a => a.id === id);\n        if (idx >= 0) {\n          const updated = { \n            ...agents[idx], \n            status: 'suspended', \n            suspension_reason: reason,\n            suspended_at: new Date().toISOString(),\n            suspended_by: currentUserId,\n            updated_at: new Date().toISOString() \n          } as ManagedAgent;\n          agents[idx] = updated;\n          this.writeAgentsToStorage(agents);\n          return { data: updated, error: null };\n        }\n      }\n\n      return { data: data as any, error };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Reactivate a suspended/rejected agent\n  static async reactivateAgent(id: string): Promise<{ data: ManagedAgent | null; error: any }> {\n    try {\n      const client = isAdminClientConfigured ? adminSupabase : supabase;\n      const { data, error } = await client\n        .from('agents')\n        .update({ status: 'active', suspension_reason: null, suspended_at: null, suspended_by: null })\n        .eq('id', id)\n        .select('id,status,created_at,updated_at,suspension_reason,suspended_at,suspended_by')\n        .single();\n\n      if (error && this.isMissingTableError(error)) {\n        const agents = this.readAgentsFromStorage();\n        const idx = agents.findIndex(a => a.id === id);\n        if (idx >= 0) {\n          const updated = { \n            ...agents[idx], \n            status: 'active', \n            suspension_reason: undefined,\n            suspended_at: undefined,\n            suspended_by: undefined,\n            updated_at: new Date().toISOString() \n          } as ManagedAgent;\n          agents[idx] = updated;\n          this.writeAgentsToStorage(agents);\n          return { data: updated, error: null };\n        }\n      }\n\n      return { data: data as any, error };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Reset agent credentials (overloaded method for backward compatibility)\n  static async resetCredentials(id: string, newCredentials?: { username: string; temporaryPassword: string }): Promise<{ data: { username: string; temporaryPassword: string } | null; error: any }> {\n    try {\n      let username: string;\n      let temporaryPassword: string;\n\n      if (newCredentials) {\n        // Use provided credentials\n        username = newCredentials.username;\n        temporaryPassword = newCredentials.temporaryPassword;\n      } else {\n        // Generate new credentials\n        const { data: agent, error: agentError } = await supabase\n          .from('profiles')\n          .select('name, email')\n          .eq('id', id)\n          .single();\n\n        if (agentError || !agent) {\n          return { data: null, error: agentError || 'Agent not found' };\n        }\n\n        const baseFromEmail = (agent as any).email ? String((agent as any).email).toLowerCase().trim() : '';\n        const baseFromName = (agent as any).name ? String((agent as any).name).toLowerCase().replace(/\\s+/g, '') : '';\n        username = baseFromEmail || baseFromName || `agent_${id.slice(0, 6)}`;\n        temporaryPassword = this.generateTemporaryPassword();\n      }\n\n      // Set hashed temporary credentials via RPC\n      const { error } = await (supabase as any).rpc('set_agent_credentials', {\n        p_id: id,\n        p_username: username,\n        p_password: temporaryPassword,\n        p_is_temporary: true\n      });\n\n      if (error) {\n        return { data: null, error };\n      }\n\n      return {\n        data: { username, temporaryPassword },\n        error: null\n      };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Get staff members for assignment\n  static async getStaffMembers(): Promise<{ data: StaffMember[] | null; error: any }> {\n    try {\n      // Fetch directly from profiles to avoid requiring a DB relationship\n      const { data, error } = await supabase\n        .from('profiles')\n        .select('id, name, email, role')\n        .in('role', ['staff', 'admin', 'super_admin']);\n\n      if (error) return { data: null, error };\n\n      if (!data) {\n        return { data: [], error: null };\n      }\n\n      const staffMembers = (data as any[]).map((item: any) => ({\n        id: item.id || '',\n        name: item.name || 'Unknown',\n        email: item.email || '',\n        role: item.role || 'staff'\n      }));\n\n      return { data: staffMembers, error: null };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Get agents assigned to current user (for staff)\n  static async getMyAssignedAgents(): Promise<{ data: ManagedAgent[] | null; error: any }> {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n\n      if (!user) {\n        return { data: null, error: 'Not authenticated' };\n      }\n\n      // Until DB columns exist, use local storage assignment info\n      const agents = this.readAgentsFromStorage();\n      const myAgents = agents.filter(a => {\n        const byCreator = (a as any).created_by === user.id;\n        const byAssignment = Array.isArray((a as any).assigned_staff) && ((a as any).assigned_staff as string[]).includes(user.id);\n        return byCreator || byAssignment;\n      });\n\n      return { data: myAgents, error: null };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Set agent credentials (permanent or temporary) using secure RPC\n  static async setAgentCredentials(id: string, username: string, password: string, isTemporary: boolean = false): Promise<{ error: any }> {\n    try {\n      const { error } = await (supabase as any).rpc('set_agent_credentials', {\n        p_id: id,\n        p_username: username,\n        p_password: password,\n        p_is_temporary: isTemporary\n      });\n\n      // If RPC succeeds, return immediately\n      if (!error) {\n        return { error: null };\n      }\n\n      // Fallback: persist credentials locally to avoid blocking activation UX\n      try {\n        const { data: { user } } = await supabase.auth.getUser();\n        const createdBy = {\n          staffId: (user as any)?.id || 'system',\n          staffName: (user as any)?.user_metadata?.name || 'System'\n        };\n\n        // Use email-style login (username passed in is email in our flows)\n        storeAgentCredentials({\n          agentId: String(id),\n          username: String(username).toLowerCase(),\n          password,\n          email: String(username).toLowerCase(),\n          forcePasswordChange: !!isTemporary,\n          isTemporary: !!isTemporary,\n          createdAt: new Date().toISOString(),\n          createdBy\n        });\n\n        console.warn('RPC set_agent_credentials failed, used local fallback:', error);\n        // Suppress error for UX continuity; credentials now usable via local fallback\n        return { error: null };\n      } catch (fallbackErr) {\n        console.error('Local credential fallback failed:', fallbackErr);\n        return { error: error || fallbackErr };\n      }\n    } catch (error) {\n      // Exception on RPC call: try local fallback as well\n      try {\n        const { data: { user } } = await supabase.auth.getUser();\n        const createdBy = {\n          staffId: (user as any)?.id || 'system',\n          staffName: (user as any)?.user_metadata?.name || 'System'\n        };\n\n        storeAgentCredentials({\n          agentId: String(id),\n          username: String(username).toLowerCase(),\n          password,\n          email: String(username).toLowerCase(),\n          forcePasswordChange: !!isTemporary,\n          isTemporary: !!isTemporary,\n          createdAt: new Date().toISOString(),\n          createdBy\n        });\n\n        console.warn('RPC set_agent_credentials exception, used local fallback:', error);\n        return { error: null };\n      } catch (fallbackErr) {\n        console.error('Local credential fallback failed after exception:', fallbackErr);\n        return { error };\n      }\n    }\n  }\n\n  // Authenticate agent against DB RPC\n  static async authenticateAgentWithDB(username: string, password: string): Promise<{ data: { id: string; name: string; email: string; role: string } | null; error: any }> {\n    try {\n      const { data, error } = await (supabase as any).rpc('authenticate_agent', {\n        p_username: username,\n        p_password: password\n      });\n\n      if (error) {\n        return { data: null, error };\n      }\n\n      if (data && (data as any).ok) {\n        return { data: (data as any).agent, error: null };\n      }\n\n      return { data: null, error: (data as any)?.error || 'Authentication failed' };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Generate temporary password\n  static generateTemporaryPassword(): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    for (let i = 0; i < 12; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  }\n\n  // New method: update agent source by email\n  static async updateAgentSourceByEmail(email: string, source_type: string, source_details: string): Promise<{ error: any }> {\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\n      const { data: profile, error: profileErr } = await client\n        .from('profiles')\n        .select('id')\n        .eq('email', email)\n        .maybeSingle();\n\n      if (profileErr) {\n        return { error: profileErr };\n      }\n\n      const id = (profile as any)?.id;\n      if (!id) {\n        return { error: 'Profile not found for email' };\n      }\n\n      const { data: agentExists } = await client\n        .from('agents')\n        .select('id')\n        .eq('id', id)\n        .maybeSingle();\n\n      if (!agentExists) {\n        const { error: upErr } = await client\n          .from('agents')\n          .upsert({ id, user_id: id, source_type, source_details }, { onConflict: 'id' });\n        if (upErr) {\n          return { error: upErr };\n        }\n      }\n\n      const { error } = await client\n        .from('agents')\n        .update({ source_type, source_details })\n        .eq('id', id);\n      return { error };\n    } catch (error) {\n      return { error };\n    }\n  }\n\n  // =============================\n  // Staff assignment persistence\n  // =============================\n\n  // Legacy local fallback store accessors (kept only for one-time migration)\n  private static readAssignmentsFallback(): Record<string, any[]> {\n    try {\n      const raw = localStorage.getItem('agent_staff_assignments_fallback');\n      const map = raw ? JSON.parse(raw) : {};\n      return (map && typeof map === 'object') ? map : {};\n    } catch {\n      return {};\n    }\n  }\n\n  private static writeAssignmentsFallback(map: Record<string, any[]>): void {\n    try {\n      localStorage.setItem('agent_staff_assignments_fallback', JSON.stringify(map));\n    } catch {}\n  }\n\n  // Get staff assignments for a specific agent (Supabase source of truth)\n  static async getAgentStaffAssignments(agentId: string): Promise<{ data: any[] | null; error: any }> {\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\n      // Read detailed assignments from agent_staff_assignments\n      const { data: assignmentRows, error: assignErr } = await client\n        .from('agent_staff_assignments' as any)\n        .select('agent_id, staff_id, is_primary, notes, assigned_at, assigned_by')\n        .eq('agent_id', agentId)\n        .order('is_primary', { ascending: false })\n        .order('assigned_at', { ascending: true });\n\n      if (assignErr) {\n        return { data: null, error: assignErr };\n      }\n\n      const rows = (assignmentRows as any[]) || [];\n      if (rows.length === 0) {\n        // If legacy local fallback exists for this agent, migrate it into Supabase automatically\n        try {\n          const fbMap = this.readAssignmentsFallback();\n          const fbRows = Array.isArray(fbMap[agentId]) ? fbMap[agentId] : [];\n          if (fbRows.length > 0) {\n            await this.migrateAssignmentsFallbackToSupabase(agentId);\n            const { data: reRows } = await client\n              .from('agent_staff_assignments' as any)\n              .select('agent_id, staff_id, is_primary, notes, assigned_at, assigned_by')\n              .eq('agent_id', agentId)\n              .order('is_primary', { ascending: false })\n              .order('assigned_at', { ascending: true });\n            if (Array.isArray(reRows) && reRows.length > 0) {\n              const staffIds2 = (reRows as any[]).map(r => String((r as any).staff_id));\n              const { data: profiles2 } = await client\n                .from('profiles' as any)\n                .select('id,name,role,email')\n                .in('id', staffIds2);\n              const profileMap2 = new Map<string, any>();\n              (profiles2 || []).forEach(p => profileMap2.set(String((p as any).id), p));\n              const migrated = (reRows as any[]).map((r: any) => {\n                const p = profileMap2.get(String(r.staff_id)) || {};\n                return {\n                  staffId: String(r.staff_id),\n                  staffName: (p as any)?.name || 'Unknown',\n                  role: (p as any)?.role || 'staff',\n                  isPrimary: !!r.is_primary,\n                  assignedAt: r.assigned_at,\n                  assignedBy: r.assigned_by ? String(r.assigned_by) : undefined,\n                  notes: r.notes ?? undefined\n                };\n              });\n              return { data: migrated, error: null };\n            }\n          }\n        } catch {}\n\n        // As a soft fallback, return bare assignments derived from agents.assigned_staff (DB column)\n        try {\n          const { data: agentRow } = await client\n            .from('agents' as any)\n            .select('assigned_staff')\n            .eq('id', agentId)\n            .maybeSingle();\n          const staffIds: string[] = Array.isArray((agentRow as any)?.assigned_staff)\n            ? ((agentRow as any)?.assigned_staff || []).map((x: any) => String(x))\n            : [];\n\n          if (staffIds.length === 0) {\n            return { data: [], error: null };\n          }\n\n          const { data: profiles } = await client\n            .from('profiles' as any)\n            .select('id,name,role,email')\n            .in('id', staffIds);\n          const profileMap = new Map<string, any>();\n          (profiles || []).forEach(p => profileMap.set(String((p as any).id), p));\n          const now = new Date().toISOString();\n\n          const derived = staffIds.map((sid: string, idx: number) => {\n            const p = profileMap.get(String(sid)) || {};\n            return {\n              staffId: String(sid),\n              staffName: (p as any)?.name || 'Unknown',\n              role: (p as any)?.role || 'staff',\n              isPrimary: idx === 0,\n              assignedAt: now,\n              assignedBy: undefined,\n              notes: undefined\n            };\n          });\n\n          return { data: derived, error: null };\n        } catch (innerErr) {\n          return { data: [], error: null };\n        }\n      }\n\n      // Enrich with profiles (assigned staff) and assigners (assigned_by)\n      const staffIds = rows.map(r => String((r as any).staff_id));\n      const assignerIds = Array.from(new Set(rows\n        .map(r => (r as any).assigned_by)\n        .filter((id: any) => !!id)\n        .map((id: any) => String(id))));\n\n      const { data: staffProfiles } = await client\n        .from('profiles' as any)\n        .select('id,name,role,email')\n        .in('id', staffIds);\n      const staffProfileMap = new Map<string, any>();\n      (staffProfiles || []).forEach(p => staffProfileMap.set(String((p as any).id), p));\n\n      let assignerProfileMap = new Map<string, any>();\n      if (assignerIds.length > 0) {\n        const { data: assignerProfiles } = await client\n          .from('profiles' as any)\n          .select('id,name,role,email')\n          .in('id', assignerIds);\n        assignerProfileMap = new Map<string, any>();\n        (assignerProfiles || []).forEach(p => assignerProfileMap.set(String((p as any).id), p));\n      }\n\n      const result = rows.map((r: any) => {\n        const staffProfile = staffProfileMap.get(String(r.staff_id)) || {};\n        const assignerId = r.assigned_by ? String(r.assigned_by) : undefined;\n        const assignerProfile = assignerId ? (assignerProfileMap.get(assignerId) || {}) : {};\n        return {\n          staffId: String(r.staff_id),\n          staffName: (staffProfile as any)?.name || 'Unknown',\n          role: (staffProfile as any)?.role || 'staff',\n          email: (staffProfile as any)?.email || undefined,\n          isPrimary: !!r.is_primary,\n          assignedAt: r.assigned_at,\n          assignedBy: assignerId,\n          assignedByName: (assignerProfile as any)?.name || undefined,\n          assignedByRole: (assignerProfile as any)?.role || undefined,\n          notes: r.notes ?? undefined\n        };\n      });\n\n      return { data: result, error: null };\n    } catch (error) {\n      return { data: null, error };\n    }\n  }\n\n  // Add a staff assignment to an agent (writes to agent_staff_assignments; triggers sync agents.assigned_staff)\n  static async addStaffAssignmentToAgent(agentId: string, staffId: string, options?: { isPrimary?: boolean; notes?: string; role?: string }): Promise<{ error: any }> {\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\n      // Determine assigned_by when available\n      let assignedBy: string | null = null;\n      try {\n        const { data: authData } = await supabase.auth.getUser();\n        assignedBy = authData?.user?.id ? String(authData.user.id) : null;\n      } catch {}\n\n      // Upsert into agent_staff_assignments to avoid duplicates\n      const payload: any = {\n        agent_id: agentId,\n        staff_id: staffId,\n        is_primary: !!options?.isPrimary,\n        notes: options?.notes ?? null,\n        assigned_by: assignedBy\n      };\n\n      const { error: upErr } = await client\n        .from('agent_staff_assignments' as any)\n        .upsert(payload, { onConflict: 'agent_id,staff_id' } as any);\n      if (upErr) {\n        return { error: upErr };\n      }\n\n      // Triggers handle syncing agents.assigned_staff\n      return { error: null };\n    } catch (error) {\n      return { error };\n    }\n  }\n\n  // Update assignment details (primary flag, notes) in DB\n  static async updateStaffAssignmentForAgent(agentId: string, staffId: string, updates: { isPrimary?: boolean; notes?: string }): Promise<{ error: any }> {\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\n      // Build patch only with provided fields\n      const patch: any = {};\n      if (typeof updates?.isPrimary === 'boolean') patch.is_primary = updates.isPrimary;\n      if (typeof updates?.notes === 'string') patch.notes = updates.notes;\n\n      if (Object.keys(patch).length === 0) {\n        return { error: null };\n      }\n\n      const { error: upErr } = await client\n        .from('agent_staff_assignments' as any)\n        .update(patch)\n        .eq('agent_id', agentId)\n        .eq('staff_id', staffId);\n      if (upErr) {\n        return { error: upErr };\n      }\n      return { error: null };\n    } catch (error) {\n      return { error };\n    }\n  }\n\n  // Remove a staff assignment (deletes row; trigger syncs agents.assigned_staff)\n  static async removeStaffAssignmentFromAgent(agentId: string, staffId: string): Promise<{ error: any }> {\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\n      const { error: delErr } = await client\n        .from('agent_staff_assignments' as any)\n        .delete()\n        .eq('agent_id', agentId)\n        .eq('staff_id', staffId);\n      if (delErr) {\n        return { error: delErr };\n      }\n      return { error: null };\n    } catch (error) {\n      return { error };\n    }\n  }\n\n  // One-time migration: push localStorage fallback assignments into Supabase\n  static async migrateAssignmentsFallbackToSupabase(targetAgentId?: string): Promise<{ migratedAgents: number; migratedRows: number; error: any }> {\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const fbMap = this.readAssignmentsFallback();\n      const entries = Object.entries(fbMap).filter(([agentId]) => !targetAgentId || String(agentId) === String(targetAgentId));\n\n      let migratedAgents = 0;\n      let migratedRows = 0;\n\n      for (const [agentId, list] of entries) {\n        const rows = Array.isArray(list) ? list : [];\n        if (rows.length === 0) continue;\n\n        for (const r of rows) {\n          const payload: any = {\n            agent_id: agentId,\n            staff_id: String(r.staffId),\n            is_primary: !!r.isPrimary,\n            notes: r.notes ?? null,\n            assigned_at: r.assignedAt ?? null,\n            assigned_by: r.assignedBy ? String(r.assignedBy) : null\n          };\n          const { error: upErr } = await client\n            .from('agent_staff_assignments' as any)\n            .upsert(payload, { onConflict: 'agent_id,staff_id' } as any);\n          if (upErr) {\n            return { migratedAgents, migratedRows, error: upErr };\n          }\n          migratedRows += 1;\n        }\n\n        migratedAgents += 1;\n        // Clear migrated agent from fallback\n        const map = this.readAssignmentsFallback();\n        delete map[agentId];\n        this.writeAssignmentsFallback(map);\n      }\n\n      return { migratedAgents, migratedRows, error: null };\n    } catch (error) {\n      return { migratedAgents: 0, migratedRows: 0, error };\n    }\n  }\n\n  private static readTaxInfoFromStorage(): Record<string, any[]> {\n    try {\n      const raw = localStorage.getItem('agent_tax_info_fallback');\n      const parsed = raw ? JSON.parse(raw) : {};\n      return parsed && typeof parsed === 'object' ? parsed : {};\n    } catch {\n      return {};\n    }\n  }\n\n  private static writeTaxInfoToStorage(map: Record<string, any[]>): void {\n    try {\n      localStorage.setItem('agent_tax_info_fallback', JSON.stringify(map));\n    } catch {\n      // ignore storage write errors\n    }\n  }\n\n  static async getAgentTaxInfo(agentId: string): Promise<{ data: any[] | null; error: any }> {\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { data, error } = await (client as any)\n        .from('agent_tax_info' as any)\n        .select('*')\n        .eq('agent_id', agentId)\n        .order('updated_at', { ascending: false });\n      if (error) {\n        if (this.isMissingTableError(error) || this.isAuthOrPermissionError(error)) {\n          const fb = this.readTaxInfoFromStorage();\n          const list = Array.isArray(fb[agentId]) ? fb[agentId] : [];\n          return { data: list, error: null };\n        }\n        return { data: null, error };\n      }\n      return { data: (data as any[]) || [], error: null };\n    } catch (error: any) {\n      if (this.isMissingTableError(error) || this.isAuthOrPermissionError(error)) {\n        const fb = this.readTaxInfoFromStorage();\n        const list = Array.isArray(fb[agentId]) ? fb[agentId] : [];\n        return { data: list, error: null };\n      }\n      return { data: null, error };\n    }\n  }\n\n  static async upsertAgentTaxInfo(agentId: string, record: any): Promise<{ data: any | null; error: any }> {\n    try {\n      const payload = { ...record, agent_id: agentId, updated_at: new Date().toISOString() };\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      if (payload.id) {\n        const { data, error } = await (client as any)\n          .from('agent_tax_info')\n          .update(payload)\n          .eq('id', payload.id)\n          .select('*')\n          .maybeSingle();\n        if (error && (this.isMissingTableError(error) || this.isAuthOrPermissionError(error))) {\n          const fb = this.readTaxInfoFromStorage();\n          const key = String(agentId);\n          const list = Array.isArray(fb[key]) ? fb[key] : [];\n          const idx = list.findIndex((r: any) => String(r.id) === String(payload.id));\n          const updated = {\n            ...(idx >= 0 ? list[idx] : {}),\n            ...payload,\n            updated_at: new Date().toISOString(),\n          };\n          if (idx >= 0) list[idx] = updated; else list.push(updated);\n          list.sort((a: any, b: any) => (a.updated_at > b.updated_at ? -1 : 1));\n          fb[key] = list;\n          this.writeTaxInfoToStorage(fb);\n          return { data: updated, error: null };\n        }\n        return { data: data || null, error };\n      } else {\n        const { data, error } = await (client as any)\n          .from('agent_tax_info')\n          .insert({ ...payload, created_at: new Date().toISOString() })\n          .select('*')\n          .maybeSingle();\n        if (error && (this.isMissingTableError(error) || this.isAuthOrPermissionError(error))) {\n          const fb = this.readTaxInfoFromStorage();\n          const key = String(agentId);\n          const list = Array.isArray(fb[key]) ? fb[key] : [];\n          const id = (globalThis?.crypto && typeof globalThis.crypto.randomUUID === 'function')\n            ? globalThis.crypto.randomUUID()\n            : Math.random().toString(36).slice(2);\n          const created = {\n            id,\n            ...payload,\n            agent_id: agentId,\n            tax_verified: payload?.tax_verified ?? false,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n          };\n          list.push(created);\n          list.sort((a: any, b: any) => (a.updated_at > b.updated_at ? -1 : 1));\n          fb[key] = list;\n          this.writeTaxInfoToStorage(fb);\n          return { data: created, error: null };\n        }\n        return { data: data || null, error };\n      }\n    } catch (error: any) {\n      if (this.isMissingTableError(error) || this.isAuthOrPermissionError(error)) {\n        const fb = this.readTaxInfoFromStorage();\n        const key = String(agentId);\n        const list = Array.isArray(fb[key]) ? fb[key] : [];\n        if (record?.id) {\n          const idx = list.findIndex((r: any) => String(r.id) === String(record.id));\n          const updated = {\n            ...(idx >= 0 ? list[idx] : {}),\n            ...record,\n            agent_id: agentId,\n            updated_at: new Date().toISOString(),\n          };\n          if (idx >= 0) list[idx] = updated; else list.push(updated);\n          list.sort((a: any, b: any) => (a.updated_at > b.updated_at ? -1 : 1));\n          fb[key] = list;\n          this.writeTaxInfoToStorage(fb);\n          return { data: updated, error: null };\n        } else {\n          const id = (globalThis?.crypto && typeof globalThis.crypto.randomUUID === 'function')\n            ? globalThis.crypto.randomUUID()\n            : Math.random().toString(36).slice(2);\n          const created = {\n            id,\n            ...record,\n            agent_id: agentId,\n            tax_verified: record?.tax_verified ?? false,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n          };\n          list.push(created);\n          list.sort((a: any, b: any) => (a.updated_at > b.updated_at ? -1 : 1));\n          fb[key] = list;\n          this.writeTaxInfoToStorage(fb);\n          return { data: created, error: null };\n        }\n      }\n      return { data: null, error };\n    }\n  }\n}","import { supabase, adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\n\n// Local row type for the optional tracking table\ntype StaffReferralRow = {\n  id?: string;\n  staff_id: string;\n  referral_code: string;\n  created_at?: string;\n};\n\nconst REFERRAL_TABLE = 'staff_referrals';\n\nfunction getBaseSignupUrl(): string {\n  // Prefer an explicit public site URL if provided; otherwise use current origin\n  const publicUrl = (import.meta as any)?.env?.VITE_PUBLIC_SITE_URL || (import.meta as any)?.env?.VITE_SITE_URL;\n  const origin = typeof window !== 'undefined' && window?.location?.origin ? window.location.origin : (publicUrl || '');\n  const base = (publicUrl || origin || '').replace(/\\/$/, '');\n  return `${base}/signup/agent?ref=`;\n}\n\nfunction uuidToBytes(uuid: string): Uint8Array {\n  const hex = uuid.replace(/-/g, '').toLowerCase();\n  const bytes = new Uint8Array(16);\n  for (let i = 0; i < 16; i++) {\n    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);\n  }\n  return bytes;\n}\n\nfunction bytesToBase64Url(bytes: Uint8Array): string {\n  let binary = '';\n  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);\n  if (typeof btoa === 'undefined') return '';\n  const base64 = btoa(binary);\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/g, '');\n}\n\nfunction base64UrlToBytes(b64: string): Uint8Array {\n  if (typeof atob === 'undefined') return new Uint8Array();\n  const padded = b64.replace(/-/g, '+').replace(/_/g, '/') + '=='.slice(0, (4 - (b64.length % 4)) % 4);\n  const binary = atob(padded);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);\n  return bytes;\n}\n\nfunction bytesToUuid(bytes: Uint8Array): string {\n  const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');\n  return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;\n}\n\nfunction buildReferralCode(staffId: string): string {\n  // Short, URL-safe, deterministic code derived from UUID\n  try {\n    if (typeof btoa === 'undefined') return `staff_${staffId}`;\n    const short = bytesToBase64Url(uuidToBytes(staffId));\n    return short ? `s_${short}` : `staff_${staffId}`; // ~24 chars\n  } catch {\n    return `staff_${staffId}`; // Fallback if parsing fails\n  }\n}\n\nexport function decodeReferralCodeToStaffId(code: string): string | null {\n  try {\n    const raw = code.startsWith('s_') ? code.slice(2) : null;\n    if (!raw) return null;\n    const bytes = base64UrlToBytes(raw);\n    return bytes.length === 16 ? bytesToUuid(bytes) : null;\n  } catch {\n    return null;\n  }\n}\n\nfunction buildReferralLink(code: string) {\n  return `${getBaseSignupUrl()}${code}`;\n}\n\nexport async function ensureReferralExistsForStaff(staffId: string): Promise<string> {\n  const code = buildReferralCode(staffId);\n  const link = buildReferralLink(code);\n\n  try {\n    // Prefer admin client for writes to bypass potential RLS; relax types for flexibility\n    const client: any = (isAdminClientConfigured ? adminSupabase : supabase) as any;\n\n    const res = await client\n      .from(REFERRAL_TABLE)\n      .select('referral_code')\n      .eq('staff_id', staffId)\n      .limit(1);\n\n    const data = (res?.data as Array<Pick<StaffReferralRow, 'referral_code'>> | null) || null;\n    const error = res?.error;\n\n    if (!error && data && data.length > 0 && data[0]?.referral_code) {\n      return buildReferralLink(data[0].referral_code);\n    }\n\n    // Attempt to insert if not found; ignore type restrictions by casting payload\n    const insertRes = await client\n      .from(REFERRAL_TABLE)\n      .insert({ staff_id: staffId, referral_code: code } as StaffReferralRow);\n\n    if (insertRes?.error) {\n      console.warn('Referral insert warning:', insertRes.error?.message);\n    }\n  } catch (e: any) {\n    console.warn('Referral ensure error:', e?.message || e);\n  }\n\n  return link;\n}\n\nexport async function getStaffReferralLink(staffId: string): Promise<string> {\n  const code = buildReferralCode(staffId);\n\n  try {\n    const client: any = (isAdminClientConfigured ? adminSupabase : supabase) as any;\n\n    const res = await client\n      .from(REFERRAL_TABLE)\n      .select('referral_code')\n      .eq('staff_id', staffId)\n      .limit(1);\n\n    const data = (res?.data as Array<Pick<StaffReferralRow, 'referral_code'>> | null) || null;\n    const error = res?.error;\n\n    if (!error && data && data.length > 0 && data[0]?.referral_code) {\n      return buildReferralLink(data[0].referral_code);\n    }\n\n    // If no record exists remotely, ensure creation and return deterministic link\n    return await ensureReferralExistsForStaff(staffId);\n  } catch (e: any) {\n    console.warn('Referral fetch error:', e?.message || e);\n    return buildReferralLink(code);\n  }\n}\n\nexport function getDeterministicStaffReferralLink(staffId: string): string {\n  return buildReferralLink(buildReferralCode(staffId));\n}\n\nexport async function recordReferralCodeIfMissing(referralCode: string): Promise<void> {\n  try {\n    const client: any = (isAdminClientConfigured ? adminSupabase : supabase) as any;\n    const possibleStaffId = decodeReferralCodeToStaffId(referralCode);\n\n    const payload: any = { referral_code: referralCode };\n    if (possibleStaffId) payload.staff_id = possibleStaffId;\n\n    const { error } = await client\n      .from(REFERRAL_TABLE)\n      .upsert(payload, { onConflict: 'referral_code' });\n\n    if (error) {\n      console.warn('Referral code upsert warning:', error.message);\n    }\n  } catch (e: any) {\n    console.warn('Referral code record error:', e?.message || e);\n  }\n}","import { supabase } from '@/lib/supabaseClient';\n\nconst sb = supabase as any;\n\nconst nameCache = new Map<string, string>();\nconst roleCache = new Map<string, string>();\n\nexport async function resolveProfileNameById(id?: string | null): Promise<string | null> {\n  if (!id) return null;\n  const cached = nameCache.get(id);\n  if (cached) return cached;\n\n  // Try staff_profiles first\n  try {\n    const { data, error } = await sb\n      .from('staff_profiles')\n      .select('name')\n      .eq('id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!error && data) {\n      const name = (data.name as string) || null;\n      if (name) { nameCache.set(id, name); return name; }\n    }\n  } catch {}\n\n  // Fallback to profiles table\n  try {\n    const { data, error } = await sb\n      .from('profiles')\n      .select('name,username,email')\n      .eq('id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!error && data) {\n      const name = (data.name as string) || (data.username as string) || (data.email as string) || null;\n      if (name) { nameCache.set(id, name); return name; }\n    }\n  } catch {}\n\n  // Fallback to public.staff table\n  try {\n    const { data, error } = await sb\n      .from('staff' as any)\n      .select('name,email')\n      .eq('id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!error && data) {\n      const name = (data.name as string) || (data.email as string) || null;\n      if (name) { nameCache.set(id, name); return name; }\n    }\n  } catch {}\n\n  // Secondary fallback: agents table (by user_id, then by id)\n  try {\n    // Try match by user_id first\n    const { data: agentByUser, error: agentUserErr } = await sb\n      .from('agents')\n      .select('name,agency_name,email,user_id,id')\n      .eq('user_id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!agentUserErr && agentByUser) {\n      const name = (agentByUser.name as string) || (agentByUser.agency_name as string) || (agentByUser.email as string) || null;\n      if (name) { nameCache.set(id, name); return name; }\n    }\n\n    // Fallback: match by agent id\n    const { data: agentById, error: agentIdErr } = await sb\n      .from('agents')\n      .select('name,agency_name,email,user_id,id')\n      .eq('id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!agentIdErr && agentById) {\n      const name = (agentById.name as string) || (agentById.agency_name as string) || (agentById.email as string) || null;\n      if (name) { nameCache.set(id, name); return name; }\n    }\n  } catch {}\n\n  return null;\n}\n\nexport async function resolveProfileRoleById(id?: string | null): Promise<string | null> {\n  if (!id) return null;\n  const cached = roleCache.get(id);\n  if (cached) return cached;\n\n  try {\n    const { data, error } = await sb\n      .from('staff_profiles')\n      .select('role')\n      .eq('id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!error && data) {\n      const role = (data.role as string) || null;\n      if (role) { roleCache.set(id, role); return role; }\n    }\n  } catch {}\n\n  // Fallback to profiles (if role exists there)\n  try {\n    const { data, error } = await sb\n      .from('profiles')\n      .select('role')\n      .eq('id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!error && data) {\n      const role = (data.role as string) || null;\n      if (role) { roleCache.set(id, role); return role; }\n    }\n  } catch {}\n\n  // Fallback to public.staff role\n  try {\n    const { data, error } = await sb\n      .from('staff' as any)\n      .select('role')\n      .eq('id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!error && data) {\n      const role = (data.role as string) || null;\n      if (role) { roleCache.set(id, role); return role; }\n    }\n  } catch {}\n\n  // Secondary fallback: agents table implies role 'agent'\n  try {\n    const { data: agentByUser, error: agentUserErr } = await sb\n      .from('agents')\n      .select('id,user_id')\n      .eq('user_id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!agentUserErr && agentByUser) {\n      roleCache.set(id, 'agent');\n      return 'agent';\n    }\n\n    const { data: agentById, error: agentIdErr } = await sb\n      .from('agents')\n      .select('id,user_id')\n      .eq('id', id)\n      .limit(1)\n      .maybeSingle();\n    if (!agentIdErr && agentById) {\n      roleCache.set(id, 'agent');\n      return 'agent';\n    }\n  } catch {}\n\n  return null;\n}","import { supabase } from '@/lib/supabaseClient';\nimport { WorkflowEvent } from '@/types/query';\nimport { resolveProfileNameById, resolveProfileRoleById } from './profilesHelper';\n\nconst sb = supabase as any;\n\nexport type WorkflowEventRow = {\n  id?: string; // UUID\n  enquiry_id: string; // UUID reference to public.enquiries.id\n  event_type: WorkflowEvent['type'];\n  user_id?: string | null;\n  user_name?: string | null;\n  user_role?: string | null;\n  details?: string | null;\n  metadata?: any | null;\n  created_at?: string; // timestamptz\n};\n\n// Resolve enquiry UUID from business id (enquiry_id)\nasync function resolveEnquiryUuid(enquiryBusinessId: string): Promise<string | null> {\n  const { data, error } = await sb\n    .from('enquiries')\n    .select('id')\n    .eq('enquiry_id', enquiryBusinessId)\n    .limit(1)\n    .maybeSingle();\n  if (error) return null;\n  return data?.id ?? null;\n}\n\n// Resolve a user's display name with source label for debugging\nasync function resolveUserNameWithSource(userId: string): Promise<{ name: string | null; source: 'staff' | 'profiles' | 'agents' | 'unknown' }> {\n  try {\n    // Prefer staff table for internal staff\n    const { data: staffRow, error: staffErr } = await sb\n      .from('staff' as any)\n      .select('name,email')\n      .eq('id', userId)\n      .limit(1)\n      .maybeSingle();\n    if (!staffErr && staffRow) {\n      const name = (staffRow as any)?.name || (staffRow as any)?.email || null;\n      return { name, source: 'staff' };\n    }\n  } catch {}\n\n  try {\n    // Fallback to profiles\n    const { data: profRow, error: profErr } = await sb\n      .from('profiles')\n      .select('name,username,email')\n      .eq('id', userId)\n      .limit(1)\n      .maybeSingle();\n    if (!profErr && profRow) {\n      const name = (profRow as any)?.name || (profRow as any)?.username || (profRow as any)?.email || null;\n      return { name, source: 'profiles' };\n    }\n  } catch {}\n\n  try {\n    // Fallback to agents: match by user_id then by id\n    const { data: agentByUser, error: agentUserErr } = await sb\n      .from('agents')\n      .select('name,agency_name,email,user_id,id')\n      .eq('user_id', userId)\n      .limit(1)\n      .maybeSingle();\n    if (!agentUserErr && agentByUser) {\n      const name = (agentByUser as any)?.name || (agentByUser as any)?.agency_name || (agentByUser as any)?.email || null;\n      return { name, source: 'agents' };\n    }\n\n    const { data: agentById, error: agentIdErr } = await sb\n      .from('agents')\n      .select('name,agency_name,email,user_id,id')\n      .eq('id', userId)\n      .limit(1)\n      .maybeSingle();\n    if (!agentIdErr && agentById) {\n      const name = (agentById as any)?.name || (agentById as any)?.agency_name || (agentById as any)?.email || null;\n      return { name, source: 'agents' };\n    }\n  } catch {}\n\n  return { name: null, source: 'unknown' };\n}\n\nfunction toUIEvent(row: WorkflowEventRow): WorkflowEvent {\n  return {\n    id: row.id || '',\n    type: row.event_type,\n    timestamp: row.created_at || new Date().toISOString(),\n    userId: row.user_id || 'unknown',\n    userName: row.user_name || 'Unknown',\n    userRole: (row.user_role as any) || 'staff',\n    details: row.details || '',\n    metadata: row.metadata || {},\n  };\n}\n\nexport async function createWorkflowEvent(entry: {\n  enquiryBusinessId: string;\n  eventType: WorkflowEvent['type'];\n  userId?: string | null;\n  userName?: string | null;\n  userRole?: string | null;\n  details?: string | null;\n  metadata?: any | null;\n}) {\n  const enquiryUuid = await resolveEnquiryUuid(entry.enquiryBusinessId);\n  if (!enquiryUuid) return { error: new Error('Enquiry not found for business id: ' + entry.enquiryBusinessId) };\n\n  let userName = entry.userName ?? null;\n  let userRole = entry.userRole ?? null;\n  let userNameSource: 'staff' | 'profiles' | 'agents' | 'unknown' | undefined;\n  const userIdStr = typeof entry.userId === 'string' ? String(entry.userId) : '';\n  const isSystemAuto = userIdStr && ['system', 'system-auto'].includes(userIdStr.toLowerCase());\n  if (isSystemAuto) {\n    userName = userName || 'System';\n    userRole = userRole || 'system' as any;\n  }\n  if (!userName && entry.userId) {\n    try {\n      const { name, source } = await resolveUserNameWithSource(entry.userId);\n      userName = name as any;\n      userNameSource = source;\n    } catch {}\n  }\n  if (!userRole && entry.userId) {\n    try { userRole = await resolveProfileRoleById(entry.userId) as any; } catch {}\n  }\n\n  const meta = { ...(entry.metadata || {}) };\n  if (userNameSource && !meta.userNameSource) meta.userNameSource = userNameSource;\n  // Normalize assignment rule presence on assigned events\n  if (entry.eventType === 'assigned') {\n    const ruleApplied = meta.rule_applied || meta.reason || null;\n    if (ruleApplied && !meta.assignmentRule) meta.assignmentRule = ruleApplied;\n    // Provide assignedByName for UI decoding when possible\n    const assignedByStr = typeof meta.assignedBy === 'string' ? String(meta.assignedBy) : '';\n    if (assignedByStr && !meta.assignedByName) {\n      if (['system', 'system-auto'].includes(assignedByStr.toLowerCase())) {\n        meta.assignedByName = 'System';\n      } else {\n        try { meta.assignedByName = await resolveProfileNameById(assignedByStr) as any; } catch {}\n      }\n    }\n    // Fill assignedToName if missing\n    const assignedToStr = typeof meta.assignedTo === 'string' ? String(meta.assignedTo) : '';\n    if (assignedToStr && !meta.assignedToName) {\n      try { meta.assignedToName = await resolveProfileNameById(assignedToStr) as any; } catch {}\n    }\n  }\n\n  const payload: WorkflowEventRow = {\n    enquiry_id: enquiryUuid,\n    event_type: entry.eventType,\n    user_id: entry.userId ?? null,\n    user_name: userName ?? null,\n    user_role: userRole ?? null,\n    details: entry.details ?? null,\n    metadata: meta ?? null,\n  };\n\n  const { error } = await sb.from('enquiry_workflow_events').insert(payload);\n  return { error: error || null };\n}\n\nexport async function listWorkflowEventsByEnquiryBusinessId(enquiryBusinessId: string, limit = 20) {\n  const enquiryUuid = await resolveEnquiryUuid(enquiryBusinessId);\n  if (!enquiryUuid) return { data: [], error: new Error('Enquiry not found for business id: ' + enquiryBusinessId) };\n\n  const { data, error } = await sb\n    .from('enquiry_workflow_events')\n    .select('id,enquiry_id,event_type,user_id,user_name,user_role,details,metadata,created_at')\n    .eq('enquiry_id', enquiryUuid)\n    .order('created_at', { ascending: false })\n    .limit(limit);\n\n  const rows = (data || []) as WorkflowEventRow[];\n  const uiEvents: WorkflowEvent[] = await Promise.all(rows.map(async (row) => {\n    let userName = row.user_name;\n    let userRole = row.user_role;\n    const userIdStr = typeof row.user_id === 'string' ? String(row.user_id) : '';\n    const isSystemAuto = userIdStr && ['system', 'system-auto'].includes(userIdStr.toLowerCase());\n    if (!userName && isSystemAuto) userName = 'System' as any;\n    if (!userRole && isSystemAuto) userRole = 'system' as any;\n    if (!userName && row.user_id) {\n      try { userName = await resolveProfileNameById(row.user_id) as any; } catch {}\n    }\n    if (!userRole && row.user_id) {\n      try { userRole = await resolveProfileRoleById(row.user_id) as any; } catch {}\n    }\n\n    // Enrich metadata for decoding\n    const meta = { ...(row.metadata || {}) };\n    if (row.event_type === 'assigned') {\n      const ruleApplied = meta.rule_applied || meta.reason || null;\n      if (ruleApplied && !meta.assignmentRule) meta.assignmentRule = ruleApplied;\n      const assignedByStr = typeof meta.assignedBy === 'string' ? String(meta.assignedBy) : '';\n      if (assignedByStr && !meta.assignedByName) {\n        if (['system', 'system-auto'].includes(assignedByStr.toLowerCase())) {\n          meta.assignedByName = 'System';\n        } else {\n          try { meta.assignedByName = await resolveProfileNameById(assignedByStr) as any; } catch {}\n        }\n      }\n      const assignedToStr = typeof meta.assignedTo === 'string' ? String(meta.assignedTo) : '';\n      if (assignedToStr && !meta.assignedToName) {\n        try { meta.assignedToName = await resolveProfileNameById(assignedToStr) as any; } catch {}\n      }\n    }\n\n    return toUIEvent({ ...row, user_name: userName || row.user_name, user_role: userRole || row.user_role, metadata: meta });\n  }));\n\n  return { data: uiEvents, error: error || null };\n}","\n// Country mapping service for assignment logic - integrated with Countries Management module\nimport { initialCountries } from '../pages/inventory/countries/data/countryData';\n\nexport interface Country {\n  id: string;\n  name: string;\n  code: string;\n}\n\n// Use countries from the centralized Countries Management module instead of hardcoded list\nexport const countries: Country[] = initialCountries\n  .filter(country => country.status === 'active')\n  .map(country => ({\n    id: country.id,\n    name: country.name,\n    code: country.code\n  }));\n\nexport const getCountryById = (id: string): Country | undefined => {\n  return countries.find(country => country.id === id);\n};\n\nexport const getCountryByName = (name: string): Country | undefined => {\n  return countries.find(country => \n    country.name.toLowerCase() === name.toLowerCase() ||\n    (name.toLowerCase() === 'uae' && country.name === 'United Arab Emirates') ||\n    (name.toLowerCase() === 'usa' && country.name === 'United States') ||\n    (name.toLowerCase() === 'uk' && country.name === 'United Kingdom')\n  );\n};\n\n// New: lookup by ISO country code (e.g., \"TH\", \"AE\")\nexport const getCountryByCode = (code: string): Country | undefined => {\n  return countries.find(country => country.code.toLowerCase() === code.toLowerCase());\n};\n\nexport const getCountriesByIds = (ids: string[]): Country[] => {\n  return ids.map(id => getCountryById(id)).filter(Boolean) as Country[];\n};\n\n// Robust mapping: accept IDs, codes, or names and return normalized country names\nexport const getStaffOperationalCountries = (operationalCountries: string[]): string[] => {\n  return operationalCountries\n    .map(value => {\n      // Try ID\n      const byId = getCountryById(value);\n      if (byId) return byId.name;\n      // Try code\n      const byCode = getCountryByCode(value);\n      if (byCode) return byCode.name;\n      // Try name\n      const byName = getCountryByName(value);\n      if (byName) return byName.name;\n      // Fallback: as-is\n      return value;\n    })\n    .filter(name => !!name && typeof name === 'string') as string[];\n};\n","\nimport { StaffMember } from '@/types/assignment';\nimport { Query } from '@/types/query';\nimport { getCountryByName, getStaffOperationalCountries } from './countryMappingService';\n\nexport interface StaffCountryMatch {\n  staff: StaffMember;\n  matchType: 'perfect' | 'partial' | 'none';\n  matchedCountries: string[];\n  workloadRatio: number;\n  score: number;\n}\n\nexport const findStaffByCountry = (\n  availableStaff: StaffMember[],\n  queryDestination: string\n): StaffCountryMatch[] => {\n  const destinationCountry = getCountryByName(queryDestination);\n  \n  if (!destinationCountry) {\n    return availableStaff.map(staff => ({\n      staff,\n      matchType: 'none' as const,\n      matchedCountries: [],\n      workloadRatio: staff.assigned / staff.workloadCapacity,\n      score: 0\n    }));\n  }\n\n  return availableStaff.map(staff => {\n    const staffCountries = getStaffOperationalCountries(staff.operationalCountries || []);\n    const hasCountryMatch = staffCountries.includes(destinationCountry.name);\n    const workloadRatio = staff.assigned / staff.workloadCapacity;\n    \n    let score = 0;\n    let matchType: 'perfect' | 'partial' | 'none' = 'none';\n    \n    if (hasCountryMatch) {\n      matchType = 'perfect';\n      score = 100 - (workloadRatio * 50); // Country match + workload consideration\n    } else {\n      matchType = 'none';\n      score = 20 - (workloadRatio * 10); // Only workload consideration\n    }\n    \n    return {\n      staff,\n      matchType,\n      matchedCountries: hasCountryMatch ? [destinationCountry.name] : [],\n      workloadRatio,\n      score\n    };\n  }).sort((a, b) => b.score - a.score);\n};\n\nexport const getBestCountryMatch = (\n  availableStaff: StaffMember[],\n  query: Query\n): StaffMember | null => {\n  const matches = findStaffByCountry(availableStaff, query.destination.country);\n  \n  // First priority: Staff with country match and available capacity\n  const perfectMatches = matches.filter(m => \n    m.matchType === 'perfect' && \n    m.staff.assigned < m.staff.workloadCapacity\n  );\n  \n  if (perfectMatches.length > 0) {\n    return perfectMatches[0].staff;\n  }\n  \n  // Fallback: Any available staff\n  const availableMatches = matches.filter(m => \n    m.staff.assigned < m.staff.workloadCapacity\n  );\n  \n  return availableMatches.length > 0 ? availableMatches[0].staff : null;\n};\n\nexport const getAssignmentReason = (\n  staff: StaffMember,\n  query: Query\n): string => {\n  const staffCountries = getStaffOperationalCountries(staff.operationalCountries || []);\n  const hasCountryMatch = staffCountries.includes(query.destination.country);\n  \n  if (hasCountryMatch) {\n    return 'Country Expertise';\n  }\n  \n  const hasGeneralExpertise = staff.expertise.some(exp =>\n    query.destination.country.toLowerCase().includes(exp.toLowerCase()) ||\n    exp.toLowerCase().includes(query.destination.country.toLowerCase())\n  );\n  \n  if (hasGeneralExpertise) {\n    return 'Destination Expertise';\n  }\n  \n  return 'Workload Balance';\n};\n","import { supabase } from '@/lib/supabaseClient';\nimport { StaffMember } from '@/types/assignment';\nimport { Query } from '@/types/query';\nimport { getBestCountryMatch } from '@/services/countryAssignmentService';\n\ntype StaffRow = {\n  id: string;\n  name: string;\n  email: string;\n  department: string | null;\n  role: string;\n  status: string | null;\n  avatar?: string | null;\n  operational_countries?: string[] | null;\n  position?: string | null;\n};\n\n// Use a relaxed Supabase client type to avoid type overloads\nconst sb = supabase as any;\n\n/**\n * Fetch enhanced staff members from the database, including assignment counts\n * and operational countries. Preserves the Supabase UUID via a hidden `uuid` property.\n */\nexport async function fetchEnhancedStaff(): Promise<StaffMember[]> {\n  try {\n    // Prefer public.staff table for richer fields\n    const { data: staffRows, error: staffErr } = await sb\n      .from('staff')\n      .select('id,name,email,department,role,status,avatar,operational_countries,position');\n    if (staffErr) throw staffErr;\n\n    // Fetch assignment history counts per staff\n    const { data: historyRows, error: histErr } = await sb\n      .from('assignment_history')\n      .select('staff_id');\n    if (histErr) throw histErr;\n\n    const assignedCounts: Record<string, number> = {};\n    (historyRows || []).forEach((r: any) => {\n      const sid = String(r.staff_id);\n      assignedCounts[sid] = (assignedCounts[sid] || 0) + 1;\n    });\n\n    // Map to StaffMember; preserve uuid for assignment operations\n    const mapped: StaffMember[] = [];\n    let nextId = 1;\n    (staffRows || []).forEach((row: StaffRow) => {\n      const expertise = Array.isArray(row.operational_countries) ? row.operational_countries : [];\n      const assigned = assignedCounts[row.id] || 0;\n      const staff: any = {\n        id: nextId++,\n        name: row.name || 'Staff Member',\n        role: row.role || 'staff',\n        email: row.email || '',\n        active: (row.status || 'active') === 'active',\n        assigned,\n        avatar: row.avatar || '',\n        expertise,\n        workloadCapacity: (row.department || '').toLowerCase() === 'sales' ? 12 : 10,\n        availability: [\n          { day: 'Monday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Tuesday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Wednesday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Thursday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Friday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Saturday', isAvailable: false },\n          { day: 'Sunday', isAvailable: false },\n        ],\n        autoAssignEnabled: true,\n        sequenceOrder: nextId - 1,\n        department: row.department || 'General',\n        experience: 3,\n        specializations: row.position ? [row.position] : [],\n        // Preserve Supabase UUID for assignment operations\n        uuid: row.id,\n        // Also include operationalCountries explicitly for country matching utility\n        operationalCountries: Array.isArray(row.operational_countries) ? row.operational_countries : [],\n      };\n      mapped.push(staff as StaffMember);\n    });\n\n    // Augment with managers and super admins from profiles if not present in staff table\n    const existingUuids = new Set((mapped || []).map((m: any) => String(m.uuid)));\n    const { data: managerProfiles, error: mgrErr } = await sb\n      .from('profiles')\n      .select('id,name,email,role')\n      .in('role', ['manager', 'super_admin']);\n    if (mgrErr) throw mgrErr;\n\n    (managerProfiles || []).forEach((p: any) => {\n      const uuid = String(p?.id);\n      if (existingUuids.has(uuid)) return; // avoid duplicates when profiles overlap with staff\n      const staff: any = {\n        id: nextId++,\n        name: p?.name || 'Staff Member',\n        role: p?.role || 'manager',\n        email: p?.email || '',\n        active: true,\n        assigned: 0,\n        avatar: '',\n        expertise: [],\n        workloadCapacity: 10,\n        availability: [\n          { day: 'Monday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Tuesday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Wednesday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Thursday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Friday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Saturday', isAvailable: false },\n          { day: 'Sunday', isAvailable: false },\n        ],\n        autoAssignEnabled: true,\n        sequenceOrder: nextId - 1,\n        department: 'Management',\n        experience: 3,\n        specializations: [],\n        operationalCountries: [],\n        uuid,\n      };\n      mapped.push(staff as StaffMember);\n    });\n\n    return mapped;\n    } catch (e) {\n    // Fallback: fetch minimal staff from profiles when staff table is unavailable\n    try {\n      const { data: profiles } = await sb\n        .from('profiles')\n        .select('id,name,email,role')\n        .in('role', ['staff', 'manager', 'super_admin']);\n      const minimal: StaffMember[] = (profiles || []).map((p: any, idx: number) => ({\n        id: idx + 1,\n        name: (p as any)?.name || 'Staff Member',\n        role: (p as any)?.role || 'staff',\n        email: (p as any)?.email || '',\n        active: true,\n        assigned: 0,\n        avatar: '',\n        expertise: [],\n        workloadCapacity: 10,\n        availability: [\n          { day: 'Monday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Tuesday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Wednesday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Thursday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Friday', isAvailable: true, workingHours: { start: '09:00', end: '17:00' } },\n          { day: 'Saturday', isAvailable: false },\n          { day: 'Sunday', isAvailable: false },\n        ],\n        autoAssignEnabled: true,\n        sequenceOrder: idx + 1,\n        department: 'General',\n        experience: 3,\n        specializations: [],\n        operationalCountries: [],\n        uuid: (p as any)?.id,\n      } as any));\n      return minimal;\n    } catch {\n      return [];\n    }\n  }\n}\n\n/**\n * Filter available staff: active, auto-assign enabled, and under capacity.\n */\nexport function getAvailableStaff(staff: StaffMember[]): StaffMember[] {\n  return (staff || [])\n    .filter(s => s.active && s.autoAssignEnabled && s.assigned < s.workloadCapacity);\n}\n\n/**\n * Find best staff match for a query using country expertise first,\n * then enhanced scoring (destination expertise, package specialization, workload, experience),\n * and finally fallback to lowest workload ratio.\n */\nexport function findBestStaffMatch(query: Query, staff: StaffMember[]): StaffMember | null {\n  const active = getAvailableStaff(staff);\n  if (active.length === 0) return null;\n\n  // Priority 1: Country-based matching\n  const countryMatch = getBestCountryMatch(active, query);\n  if (countryMatch) return countryMatch;\n\n  // Priority 2: Enhanced matching from existing logic\n  const destinations = [\n    typeof query?.destination?.country === 'string' ? query.destination.country : '',\n    ...((Array.isArray(query?.destination?.cities) ? query.destination.cities : []) as string[])\n  ].filter(Boolean);\n\n  const scoredStaff = active.map(s => {\n    let score = 0;\n\n    // Destination expertise match (string contains either way)\n    const destinationMatch = destinations.some(dest =>\n      (Array.isArray(s.expertise) ? s.expertise : [])\n        .some(exp => exp.toLowerCase().includes(dest.toLowerCase()) || dest.toLowerCase().includes(exp.toLowerCase()))\n    );\n    if (destinationMatch) score += 50;\n\n    // Package type specialization\n    const pkg = typeof query?.packageType === 'string' ? query.packageType : '';\n    const packageMatch = (s.specializations || [])\n      .some(spec => spec.toLowerCase().includes(pkg.toLowerCase()));\n    if (packageMatch) score += 30;\n\n    // Workload factor (lower ratio is better)\n    const workloadRatio = s.assigned / s.workloadCapacity;\n    score += (1 - workloadRatio) * 20;\n\n    // Experience bonus\n    score += (s.experience || 0) * 2;\n\n    return { staff: s, score };\n  })\n    .filter(entry => entry.staff.assigned < entry.staff.workloadCapacity)\n    .sort((a, b) => b.score - a.score);\n\n  if (scoredStaff.length > 0) {\n    return scoredStaff[0].staff;\n  }\n\n  // Final fallback: choose lowest workload\n  return active.sort((a, b) => (a.assigned / a.workloadCapacity) - (b.assigned / b.workloadCapacity))[0] || null;\n}","import { supabase } from '@/lib/supabaseClient';\n\n// Relax typing for flexibility across environments\nconst sb: any = supabase;\n\nconst TABLE = 'staff_sequence';\n\nexport type StaffSequenceRow = {\n  id?: string;\n  staff_id: string;\n  sequence_order: number;\n  auto_assign_enabled?: boolean;\n  created_at?: string;\n  updated_at?: string;\n  created_by?: string | null;\n  updated_by?: string | null;\n};\n\nexport const StaffSequenceService = {\n  fetchSequence: async (): Promise<{ data: StaffSequenceRow[]; error: any }> => {\n    const { data, error } = await sb\n      .from(TABLE)\n      .select('id, staff_id, sequence_order, auto_assign_enabled')\n      .order('sequence_order', { ascending: true });\n    return { data: data ?? [], error };\n  },\n\n  upsertSequence: async (items: StaffSequenceRow[]): Promise<{ data: any; error: any }> => {\n    // Determine the current user id to set audit fields\n    const { data: authData } = await sb.auth.getUser();\n    const currentUserId: string | null = (authData?.user?.id as string) || null;\n\n    // Fetch existing sequence rows for these staff ids to avoid overwriting created_by\n    const staffIds = items.map((it) => it.staff_id);\n    const { data: existingRows } = await sb\n      .from(TABLE)\n      .select('staff_id')\n      .in('staff_id', staffIds);\n    const existingSet = new Set<string>((existingRows || []).map((r: any) => r.staff_id));\n\n    const payload = items.map((it) => {\n      const base: any = {\n        staff_id: it.staff_id,\n        sequence_order: it.sequence_order,\n        auto_assign_enabled: it.auto_assign_enabled ?? true,\n      };\n      if (currentUserId) {\n        if (existingSet.has(it.staff_id)) {\n          base.updated_by = currentUserId;\n          base.updated_at = new Date().toISOString();\n        } else {\n          base.created_by = currentUserId;\n          base.updated_by = currentUserId;\n          base.updated_at = new Date().toISOString();\n        }\n      }\n      return base;\n    });\n\n    const { data, error } = await sb\n      .from(TABLE)\n      .upsert(payload, { onConflict: 'staff_id' });\n    return { data, error };\n  },\n\n  addStaff: async (staffId: string, sequenceOrder: number): Promise<{ data: any; error: any }> => {\n    // Get the current user id for audit fields\n    const { data: authData } = await sb.auth.getUser();\n    const currentUserId: string | null = (authData?.user?.id as string) || null;\n\n    // Check if the staff row already exists\n    const { data: existing, error: readErr } = await sb\n      .from(TABLE)\n      .select('id, staff_id')\n      .eq('staff_id', staffId)\n      .maybeSingle();\n\n    if (!readErr && existing) {\n      // Update existing row: only set updated_by\n      const { data, error } = await sb\n        .from(TABLE)\n        .update({\n          sequence_order: sequenceOrder,\n          auto_assign_enabled: true,\n          ...(currentUserId ? { updated_by: currentUserId, updated_at: new Date().toISOString() } : {}),\n        })\n        .eq('staff_id', staffId)\n        .select();\n      return { data, error };\n    }\n\n    // Insert new row: set both created_by and updated_by\n    const insertPayload: any = {\n      staff_id: staffId,\n      sequence_order: sequenceOrder,\n      auto_assign_enabled: true,\n    };\n    if (currentUserId) {\n      insertPayload.created_by = currentUserId;\n      insertPayload.updated_by = currentUserId;\n      insertPayload.updated_at = new Date().toISOString();\n    }\n\n    const { data, error } = await sb\n      .from(TABLE)\n      .insert([insertPayload])\n      .select();\n    return { data, error };\n  },\n\n  removeStaff: async (staffId: string): Promise<{ error: any }> => {\n    const { error } = await sb\n      .from(TABLE)\n      .delete()\n      .eq('staff_id', staffId);\n    return { error };\n  },\n\n  reorderSequence: async (orderedStaffIds: string[]): Promise<{ data: any; error: any }> => {\n    const { data: authData } = await sb.auth.getUser();\n    const currentUserId: string | null = (authData?.user?.id as string) || null;\n\n    // Determine which rows exist to avoid overwriting created_by\n    const { data: existingRows } = await sb\n      .from(TABLE)\n      .select('staff_id')\n      .in('staff_id', orderedStaffIds);\n    const existingSet = new Set<string>((existingRows || []).map((r: any) => r.staff_id));\n\n    const payload = orderedStaffIds.map((sid, idx) => {\n      const base: any = {\n        staff_id: sid,\n        sequence_order: idx + 1,\n        auto_assign_enabled: true,\n      };\n      if (currentUserId) {\n        if (existingSet.has(sid)) {\n          base.updated_by = currentUserId;\n          base.updated_at = new Date().toISOString();\n        } else {\n          base.created_by = currentUserId;\n          base.updated_by = currentUserId;\n          base.updated_at = new Date().toISOString();\n        }\n      }\n      return base;\n    });\n\n    const { data, error } = await sb\n      .from(TABLE)\n      .upsert(payload, { onConflict: 'staff_id' });\n    return { data, error };\n  },\n\n  updateAutoAssign: async (staffId: string, enabled: boolean): Promise<{ data: any; error: any }> => {\n    const { data: authData } = await sb.auth.getUser();\n    const currentUserId: string | null = (authData?.user?.id as string) || null;\n    const { data, error } = await sb\n      .from(TABLE)\n      .update({\n        auto_assign_enabled: enabled,\n        ...(currentUserId ? { updated_by: currentUserId, updated_at: new Date().toISOString() } : {}),\n      })\n      .eq('staff_id', staffId)\n      .select();\n    return { data, error };\n  },\n};\n\nexport default StaffSequenceService;","import { supabase } from '@/lib/supabaseClient';\n\n// Database row shape for public.assignment_rules\nexport interface DBAssignmentRule {\n  id: string; // uuid\n  name: string;\n  rule_type: string; // e.g., 'agent-staff-relationship', 'expertise-match'\n  priority: number;\n  enabled: boolean | null; // nullable in DB, default true\n  conditions: any | null; // jsonb\n  created_at?: string;\n  updated_at?: string;\n}\n\n// List rules ordered by priority\nexport async function listAssignmentRules(): Promise<{ data: DBAssignmentRule[]; error: any | null }> {\n  try {\n    const { data, error } = await (supabase as any)\n      .from('assignment_rules')\n      .select('*')\n      .order('priority', { ascending: true });\n    return { data: (data || []) as DBAssignmentRule[], error: error || null };\n  } catch (error) {\n    return { data: [], error };\n  }\n}\n\n// Update rule enabled state\nexport async function updateAssignmentRuleEnabled(id: string, enabled: boolean): Promise<{ data: DBAssignmentRule | null; error: any | null }> {\n  try {\n    const { data, error } = await (supabase as any)\n      .from('assignment_rules')\n      .update({ enabled, updated_at: new Date().toISOString() })\n      .eq('id', id)\n      .select('*')\n      .maybeSingle();\n    return { data: (data || null) as DBAssignmentRule | null, error: error || null };\n  } catch (error) {\n    return { data: null, error };\n  }\n}\n\n// Create a new rule\nexport async function createAssignmentRule(payload: Omit<DBAssignmentRule, 'id' | 'created_at' | 'updated_at'>): Promise<{ data: DBAssignmentRule | null; error: any | null }> {\n  try {\n    const now = new Date().toISOString();\n    const { data, error } = await (supabase as any)\n      .from('assignment_rules')\n      .insert({\n        name: payload.name,\n        rule_type: payload.rule_type,\n        priority: payload.priority,\n        enabled: payload.enabled ?? true,\n        conditions: payload.conditions ?? null,\n        created_at: now,\n        updated_at: now,\n      })\n      .select('*')\n      .maybeSingle();\n    return { data: (data || null) as DBAssignmentRule | null, error: error || null };\n  } catch (error) {\n    return { data: null, error };\n  }\n}\n\n// Update rule properties\nexport async function updateAssignmentRule(id: string, patch: Partial<DBAssignmentRule>): Promise<{ data: DBAssignmentRule | null; error: any | null }> {\n  try {\n    const { data, error } = await (supabase as any)\n      .from('assignment_rules')\n      .update({\n        ...(patch.name !== undefined ? { name: patch.name } : {}),\n        ...(patch.rule_type !== undefined ? { rule_type: patch.rule_type } : {}),\n        ...(patch.priority !== undefined ? { priority: patch.priority } : {}),\n        ...(patch.enabled !== undefined ? { enabled: patch.enabled } : {}),\n        ...(patch.conditions !== undefined ? { conditions: patch.conditions } : {}),\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', id)\n      .select('*')\n      .maybeSingle();\n    return { data: (data || null) as DBAssignmentRule | null, error: error || null };\n  } catch (error) {\n    return { data: null, error };\n  }\n}\n\n// Delete a rule\nexport async function deleteAssignmentRule(id: string): Promise<{ error: any | null }> {\n  try {\n    const { error } = await (supabase as any)\n      .from('assignment_rules')\n      .delete()\n      .eq('id', id);\n    return { error: error || null };\n  } catch (error) {\n    return { error };\n  }\n}\n\n// Bulk update priorities\nexport async function reorderAssignmentRules(updates: { id: string; priority: number }[]): Promise<{ error: any | null }> {\n  try {\n    // Perform updates sequentially to avoid JSON casting issues\n    for (const u of updates) {\n      const { error } = await (supabase as any)\n        .from('assignment_rules')\n        .update({ priority: u.priority, updated_at: new Date().toISOString() })\n        .eq('id', u.id);\n      if (error) return { error };\n    }\n    return { error: null };\n  } catch (error) {\n    return { error };\n  }\n}\n\n// Soft check for table accessibility\nexport async function isAssignmentRulesTableAccessible(): Promise<boolean> {\n  try {\n    const { error } = await (supabase as any)\n      .from('assignment_rules')\n      .select('id')\n      .limit(1);\n    return !error;\n  } catch {\n    return false;\n  }\n}\n\n// Get whether a specific rule type is enabled; returns null if table inaccessible\nexport async function getRuleEnabledByType(ruleType: string): Promise<boolean | null> {\n  try {\n    const { data, error } = await (supabase as any)\n      .from('assignment_rules')\n      .select('enabled,rule_type')\n      .eq('rule_type', ruleType)\n      .maybeSingle();\n    if (error) return null;\n    // Default to true if null to preserve legacy behavior unless explicitly disabled\n    return Boolean((data as any)?.enabled ?? true);\n  } catch {\n    return null;\n  }\n}\n\n// Batch fetch enabled flags for a set of rule types\nexport async function getRulesEnabledMap(ruleTypes: string[]): Promise<Record<string, boolean | null>> {\n  const result: Record<string, boolean | null> = {};\n  try {\n    const { data, error } = await (supabase as any)\n      .from('assignment_rules')\n      .select('rule_type,enabled');\n    if (error) {\n      ruleTypes.forEach(rt => { result[rt] = null; });\n      return result;\n    }\n    const rows = Array.isArray(data) ? (data as any[]) : [];\n    const map = new Map<string, boolean>();\n    rows.forEach(r => {\n      const rt = String((r as any)?.rule_type || '');\n      const en = Boolean((r as any)?.enabled ?? true);\n      map.set(rt, en);\n    });\n    ruleTypes.forEach(rt => { result[rt] = map.has(rt) ? map.get(rt)! : null; });\n    return result;\n  } catch {\n    ruleTypes.forEach(rt => { result[rt] = null; });\n    return result;\n  }\n}","import { supabase } from '@/lib/supabaseClient';\nimport { createWorkflowEvent } from '@/services/workflowEventsService';\nimport { Query } from '@/types/query';\nimport { getCountryCodeByName } from '@/utils/countryUtils';\nimport { EnquiryConfiguration, CountryEnquirySettings, DEFAULT_ENQUIRY_COUNTRIES } from '@/types/enquiry';\nimport { initialCountries } from '@/pages/inventory/countries/data/countryData';\nimport { AppSettingsService, AppSettingsHelpers, SETTING_CATEGORIES } from '@/services/appSettingsService_database';\nimport { fetchEnhancedStaff, findBestStaffMatch } from '@/services/staffAssignmentService';\nimport { getAssignmentReason } from '@/services/countryAssignmentService';\nimport { getStaffOperationalCountries } from '@/services/countryMappingService';\nimport { StaffSequenceService } from '@/services/staffSequenceService';\nimport { getRulesEnabledMap } from '@/services/assignmentRulesService';\nimport { assignQuery } from '@/services/autoAssignmentEngine';\n\n// Relax Supabase client typing for queries to reduce type overload errors\nconst sb = supabase as any;\n\n// Keep this UUID in sync with the UI toggle used in useQueryAssignment\n// It points to the specific app_settings row for auto_assign_enabled\nconst AUTO_ASSIGN_SETTING_ID = 'b57de51f-9bb0-4a1f-b89a-415c9c57ad3f';\n\n// Supabase 'public.enquiries' row shape (subset used by UI)\nexport type EnquiryRow = {\n  id?: string; // UUID\n  enquiry_id: string; // business ID (e.g., ENQ2025...)\n  agent_id?: string | null;\n  assigned_to?: string | null;\n  created_by?: string | null;\n\n  country_code: string;\n  country_name: string;\n  cities: any;\n\n  travel_from: string; // date\n  travel_to: string;   // date\n  is_date_estimated?: boolean;\n  nights: number;\n  days: number;\n\n  adults: number;\n  children: number;\n  infants: number;\n\n  budget_min?: number | null;\n  budget_max?: number | null;\n  budget_currency?: string | null;\n  package_type: string;\n\n  hotel_rooms?: number | null;\n  hotel_category?: string | null;\n\n  sightseeing?: boolean | null;\n  transfers?: string | null;\n  meal_plan?: string | null;\n\n  special_requests?: any;\n  notes?: string | null;\n\n  status: string;\n  priority?: string | null;\n  communication_preference?: string | null;\n  city_allocations?: any;\n\n  created_at?: string;\n  updated_at?: string;\n};\n\nexport type UseEnquiriesFilters = {\n  status?: string;\n  createdFrom?: string; // YYYY-MM-DD\n  createdTo?: string;   // YYYY-MM-DD\n};\n\nexport type UseEnquiriesParams = {\n  page: number;\n  pageSize: number;\n  search?: string;\n  filters?: UseEnquiriesFilters;\n  sort?: { field?: 'created_at' | 'enquiry_id' | 'destination' | 'status'; direction?: 'asc' | 'desc' };\n};\n \n\nfunction toQuery(row: EnquiryRow): Query {\n  const fallbackDate = new Date().toISOString();\n  const cities = Array.isArray(row.cities) ? row.cities : [];\n  const specialRequests = Array.isArray(row.special_requests) ? row.special_requests : [];\n\n  // Preserve agent_id whether numeric or UUID string, normalize invalid values\n  const rawAgentId = row.agent_id;\n  let agentId: string | number = '';\n  let agentUuid: string | undefined = undefined;\n  if (typeof rawAgentId === 'number') {\n    agentId = rawAgentId;\n  } else if (typeof rawAgentId === 'string') {\n    const norm = rawAgentId.trim();\n    const invalid = norm === '' || norm.toLowerCase() === 'null' || norm.toLowerCase() === 'undefined' || norm.toLowerCase() === 'nan';\n    if (invalid) {\n      agentId = '';\n    } else {\n      const maybeNum = Number(norm);\n      agentId = Number.isFinite(maybeNum) ? maybeNum : norm;\n      // If it's not a finite number, treat it as the actual Supabase UUID\n      if (!Number.isFinite(maybeNum)) agentUuid = norm;\n    }\n  }\n\n  return {\n    id: row.enquiry_id,\n    agentId,\n    agentUuid,\n    // Leave empty to allow UI to resolve from agentId; do not use assigned_to\n    agentName: '',\n    destination: { country: row.country_name, cities },\n    paxDetails: { adults: row.adults ?? 1, children: row.children ?? 0, infants: row.infants ?? 0 },\n    travelDates: { from: row.travel_from ?? fallbackDate, to: row.travel_to ?? fallbackDate, isEstimated: !!row.is_date_estimated },\n    tripDuration: { days: row.days ?? 0, nights: row.nights ?? 0 },\n    packageType: row.package_type ?? 'full-package',\n    specialRequests,\n    budget: { min: Number(row.budget_min ?? 0), max: Number(row.budget_max ?? 0), currency: row.budget_currency ?? 'USD' },\n    status: row.status ?? 'new',\n    assignedTo: row.assigned_to ?? null,\n    createdAt: row.created_at ?? fallbackDate,\n    updatedAt: row.updated_at ?? fallbackDate,\n    priority: row.priority ?? 'normal',\n    notes: row.notes ?? '',\n    communicationPreference: row.communication_preference ?? 'email',\n    hotelDetails: { rooms: Number(row.hotel_rooms ?? 1), category: row.hotel_category ?? 'standard' },\n    inclusions: { sightseeing: !!row.sightseeing, transfers: row.transfers ?? 'private', mealPlan: row.meal_plan ?? 'breakfast' },\n    cityAllocations: row.city_allocations ?? undefined,\n  } as Query;\n}\n\nfunction toDateOnly(iso?: string | null): string | null {\n  if (!iso) return null;\n  try {\n    const d = new Date(iso);\n    const yyyy = d.getFullYear();\n    const mm = String(d.getMonth() + 1).padStart(2, '0');\n    const dd = String(d.getDate()).padStart(2, '0');\n    return `${yyyy}-${mm}-${dd}`;\n  } catch {\n    return null;\n  }\n}\n\nfunction fromQuery(q: Query, userId?: string | null): EnquiryRow {\n  const countryName = q.destination?.country ?? 'Unknown';\n  const countryCode = getCountryCodeByName(countryName) || (countryName || '').slice(0, 2).toUpperCase();\n  return {\n    enquiry_id: q.id,\n    // Prefer Supabase UUID; avoid inserting numeric IDs into uuid column\n    agent_id: (q.agentUuid && q.agentUuid.trim().length > 0) ? q.agentUuid : null,\n    country_code: countryCode,\n    country_name: countryName,\n    cities: q.destination?.cities ?? [],\n    travel_from: toDateOnly(q.travelDates?.from) || new Date().toISOString().slice(0, 10),\n    travel_to: toDateOnly(q.travelDates?.to) || new Date().toISOString().slice(0, 10),\n    is_date_estimated: !!q.travelDates?.isEstimated,\n    nights: q.tripDuration?.nights ?? 0,\n    days: q.tripDuration?.days ?? 0,\n    adults: q.paxDetails?.adults ?? 1,\n    children: q.paxDetails?.children ?? 0,\n    infants: q.paxDetails?.infants ?? 0,\n    budget_min: q.budget?.min ?? 0,\n    budget_max: q.budget?.max ?? 0,\n    budget_currency: q.budget?.currency ?? 'USD',\n    package_type: q.packageType ?? 'full-package',\n    hotel_rooms: q.hotelDetails?.rooms ?? 1,\n    hotel_category: q.hotelDetails?.category ?? 'standard',\n    sightseeing: q.inclusions?.sightseeing ?? true,\n    transfers: q.inclusions?.transfers ?? 'private',\n    meal_plan: q.inclusions?.mealPlan ?? 'breakfast',\n    special_requests: Array.isArray(q.specialRequests) ? q.specialRequests : [],\n    notes: q.notes ?? '',\n    status: q.status ?? 'new',\n    priority: q.priority ?? 'normal',\n    communication_preference: q.communicationPreference ?? 'email',\n    city_allocations: q.cityAllocations ?? [],\n\n    created_by: userId ?? null,\n  };\n}\n\n// No offline/localStorage fallback  queries module uses Supabase exclusively\n\nexport async function listEnquiries(params: UseEnquiriesParams) {\n  const { page, pageSize, search = '', filters = {}, sort = { field: 'created_at', direction: 'desc' } } = params;\n  const offset = (page - 1) * pageSize;\n\n  // Avoid typed joins; select * and cast to reduce type complexity\n  let query = sb\n    .from('enquiries')\n    .select('*', { count: 'exact' });\n\n  // Search across multiple fields\n  if (search && search.trim().length > 0) {\n    const s = `%${search}%`;\n    // Search across known columns to avoid type errors\n    query = query.or(\n      `country_name.ilike.${s},notes.ilike.${s},enquiry_id.ilike.${s}`\n    );\n  }\n\n  // Filters\n  if (filters.status && filters.status !== 'all') {\n    query = query.eq('status', filters.status);\n  }\n  if (filters.createdFrom) {\n    query = query.gte('created_at', filters.createdFrom);\n  }\n  if (filters.createdTo) {\n    query = query.lte('created_at', filters.createdTo);\n  }\n\n  // Sorting\n  const sortField = sort?.field === 'destination' ? 'country_name' : (sort?.field || 'created_at');\n  query = query.order(sortField, { ascending: sort?.direction === 'asc' });\n\n  // Pagination\n  query = query.range(offset, offset + pageSize - 1);\n\n  const { data, error, count } = await query;\n  if (error) throw error;\n\n  const rows = (data || []) as any[];\n  // Collect unique agent IDs from rows to fetch agent names/company in one query\n  const agentIds = Array.from(\n    new Set(\n      rows\n        .map((r: any) => (r?.agent_id ? String(r.agent_id) : null))\n        .filter((id: string | null): id is string => !!id)\n    )\n  );\n\n  let agentsMap = new Map<string, { name?: string; agency_name?: string; email?: string }>();\n  if (agentIds.length > 0) {\n    try {\n      const { data: agentsData, error: agentsErr } = await sb\n        .from('agents' as any)\n        .select('id,name,agency_name,email')\n        .in('id', agentIds);\n      if (!agentsErr && Array.isArray(agentsData)) {\n        (agentsData as any[]).forEach((a: any) => {\n          agentsMap.set(String(a.id), {\n            name: (a as any)?.name,\n            agency_name: (a as any)?.agency_name,\n            email: (a as any)?.email,\n          });\n        });\n      }\n    } catch {}\n  }\n\n  const queries = rows.map((row: any) => {\n    const q = toQuery(row as EnquiryRow);\n    const a = agentsMap.get(String(row?.agent_id));\n    const agentName = a?.name || a?.agency_name || a?.email || q.agentName || '';\n    const agentCompany = a?.agency_name || q.agentCompany || '';\n    return { ...q, agentName, agentCompany } as Query;\n  });\n\n  return { data: queries, count: count ?? queries.length };\n}\n\n// Fetch all enquiries across pages for export, honoring filters/search/sort\nexport async function fetchAllEnquiries(params: Omit<UseEnquiriesParams, 'page' | 'pageSize'> & { batchSize?: number }) {\n  const { search = '', filters = {}, sort = { field: 'created_at', direction: 'desc' }, batchSize = 1000 } = params;\n\n  // Base query builder with filters/search/sort\n  const buildBaseQuery = () => {\n    let q = sb.from('enquiries').select('*', { count: 'exact' });\n    if (search && search.trim().length > 0) {\n      const s = `%${search}%`;\n      q = q.or(`country_name.ilike.${s},notes.ilike.${s},enquiry_id.ilike.${s}`);\n    }\n    if (filters.status && filters.status !== 'all') {\n      q = q.eq('status', filters.status);\n    }\n    if (filters.createdFrom) {\n      q = q.gte('created_at', filters.createdFrom);\n    }\n    if (filters.createdTo) {\n      q = q.lte('created_at', filters.createdTo);\n    }\n    const sortField = sort?.field === 'destination' ? 'country_name' : (sort?.field || 'created_at');\n    q = q.order(sortField, { ascending: sort?.direction === 'asc' });\n    return q;\n  };\n\n  // First request to get total count\n  let { data: firstData, error: firstError, count } = await buildBaseQuery().range(0, batchSize - 1);\n  if (firstError) throw firstError;\n  const rows: any[] = Array.isArray(firstData) ? firstData.slice() : [];\n\n  const total = typeof count === 'number' ? count : rows.length;\n  if (total > rows.length) {\n    let fetched = rows.length;\n    while (fetched < total) {\n      const start = fetched;\n      const end = Math.min(fetched + batchSize - 1, total - 1);\n      const { data: batch, error } = await buildBaseQuery().range(start, end);\n      if (error) throw error;\n      rows.push(...(Array.isArray(batch) ? batch : []));\n      fetched = rows.length;\n    }\n  }\n\n  const queries = rows.map((row: any) => toQuery(row as EnquiryRow));\n  // Enrich agent details similar to listEnquiries\n  const agentIds = Array.from(\n    new Set(rows.map((r: any) => (r?.agent_id ? String(r.agent_id) : null)).filter((id: string | null): id is string => !!id))\n  );\n  if (agentIds.length > 0) {\n    try {\n      const { data: agentsData } = await sb.from('agents' as any).select('id,name,agency_name,email').in('id', agentIds);\n      const map = new Map<string, { name?: string; agency_name?: string; email?: string }>();\n      (agentsData || []).forEach((a: any) => {\n        map.set(String(a.id), { name: a?.name, agency_name: a?.agency_name, email: a?.email });\n      });\n      return {\n        data: queries.map((q, idx) => {\n          const a = map.get(String((rows[idx] as any)?.agent_id));\n          const agentName = a?.name || a?.agency_name || a?.email || q.agentName || '';\n          const agentCompany = a?.agency_name || q.agentCompany || '';\n          return { ...q, agentName, agentCompany } as Query;\n        }),\n        count: total,\n      };\n    } catch {\n      // Fall back to base queries without enrichment\n    }\n  }\n  return { data: queries, count: total };\n}\n\nexport async function createEnquiry(q: Query) {\n  const { data: { user } } = await supabase.auth.getUser();\n  // Opportunistic ensure: keep enquiry settings healthy for selected country\n  try {\n    const selectedCountryCode = getCountryCodeByName(q.destination?.country || '');\n    await ensureCountryConfig(selectedCountryCode || undefined);\n  } catch {}\n  const row = fromQuery(q, user?.id ?? null);\n\n  // Pre-compute a unique enquiry_id by looking at existing IDs with the same prefix\n  // This avoids repeated duplicate violations when many records already exist.\n  const ensureUniqueEnquiryId = async (initialId: string): Promise<string> => {\n    try {\n      const match = initialId.match(/(.*?)(\\d+)$/);\n      if (!match) {\n        // If no trailing digits, just return the initial with a safe suffix\n        const candidate = initialId + '1';\n        const { data: exists } = await sb\n          .from('enquiries')\n          .select('enquiry_id')\n          .eq('enquiry_id', candidate)\n          .limit(1)\n          .maybeSingle();\n        return exists ? initialId + '2' : candidate;\n      }\n\n      const prefix = match[1];\n      const numStr = match[2];\n\n      // Find the highest existing enquiry_id for this prefix\n      const { data: latest } = await sb\n        .from('enquiries')\n        .select('enquiry_id')\n        .like('enquiry_id', `${prefix}%`)\n        .order('enquiry_id', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n      let nextNum = parseInt(numStr, 10) || 1;\n      if (latest && (latest as any).enquiry_id) {\n        const lm = String((latest as any).enquiry_id).match(/(\\d+)$/);\n        if (lm) {\n          const maxNum = parseInt(lm[1], 10) || 0;\n          nextNum = maxNum + 1;\n        }\n      }\n\n      const padded = String(nextNum).padStart(numStr.length, '0');\n      return prefix + padded;\n    } catch {\n      // On any failure, fall back to the provided initial id\n      return initialId;\n    }\n  };\n\n  // Compute a unique ID prior to insert to minimize duplicate conflicts\n  row.enquiry_id = await ensureUniqueEnquiryId(row.enquiry_id);\n\n  // Robust insert: handle duplicate enquiry_id by incrementing suffix\n  const bumpId = (id: string): string => {\n    const match = id.match(/(\\d+)$/);\n    if (!match) return id + '1';\n    const numStr = match[1];\n    const nextNum = (parseInt(numStr, 10) || 0) + 1;\n    // Preserve padding length when possible\n    const padded = nextNum.toString().padStart(numStr.length, '0');\n    return id.slice(0, id.length - numStr.length) + padded;\n  };\n\n  let inserted: any = null;\n  let insertError: any = null;\n  let attempts = 0;\n  let currentRow: any = { ...row };\n  while (attempts < 20) {\n    const res = await sb.from('enquiries').insert(currentRow).select('*').single();\n    inserted = res.data;\n    insertError = res.error;\n    if (!insertError) break;\n    const isDup = (insertError?.code === '23505') || String(insertError?.message || '').includes('enquiries_enquiry_id_key');\n    if (isDup) {\n      currentRow.enquiry_id = bumpId(currentRow.enquiry_id);\n      attempts += 1;\n      continue;\n    }\n    // Non-dup errors: bail out\n    break;\n  }\n  if (insertError) return { data: null, error: insertError };\n\n  // Convert to Query for matching and potential auto-assignment\n  const createdQuery = toQuery(inserted as EnquiryRow);\n\n  // Auto-assign if enabled in App Settings\n  try {\n    // Ensure setting exists with a default value\n    await AppSettingsHelpers.ensureSettingValue('assignment', 'auto_assign_enabled', 'false');\n    // Prefer reading by UUID to stay aligned with the UI toggle state\n    let autoAssignEnabled = false;\n    try {\n      const byId = await AppSettingsService.getSettingById(AUTO_ASSIGN_SETTING_ID);\n      if (byId.success && byId.data) {\n        const raw = (byId.data as any).setting_value ?? (byId.data as any).setting_json;\n        autoAssignEnabled = typeof raw === 'boolean' ? raw : String(raw ?? '').toLowerCase() === 'true';\n      } else {\n        const settingVal = await AppSettingsService.getSettingValue('assignment', 'auto_assign_enabled');\n        autoAssignEnabled = typeof settingVal === 'boolean' ? settingVal : String(settingVal ?? '').toLowerCase() === 'true';\n      }\n    } catch {\n      const settingVal = await AppSettingsService.getSettingValue('assignment', 'auto_assign_enabled');\n      autoAssignEnabled = typeof settingVal === 'boolean' ? settingVal : String(settingVal ?? '').toLowerCase() === 'true';\n    }\n\n    if (autoAssignEnabled) {\n      // Read rule statuses to decide assignment strategy\n      const ruleStatus = await getRulesEnabledMap(['round-robin', 'workload-balance', 'expertise-match']);\n      // Treat null (unavailable) as enabled to preserve legacy behavior\n      const roundRobinActive = ruleStatus['round-robin'] !== false;\n      const workloadBalanceActive = ruleStatus['workload-balance'] !== false;\n      const expertiseMatchActive = ruleStatus['expertise-match'] !== false;\n\n      const staff = await fetchEnhancedStaff();\n      const activeStaff = (staff || []).filter((s: any) => s.active && s.assigned < s.workloadCapacity);\n      const destCountry = String(createdQuery?.destination?.country || '').trim();\n\n      // If Expertise Match is active, prefer country-based assignment first\n      if (expertiseMatchActive) {\n        // Build list of sequence members who have a country match\n        const candidatesWithCountry: string[] = activeStaff\n          .filter((s: any) => {\n            const ops = getStaffOperationalCountries(Array.isArray(s.operationalCountries) ? s.operationalCountries : []);\n            return destCountry && ops.includes(destCountry);\n          })\n          .map((s: any) => String(s.uuid))\n          .filter(Boolean);\n\n        // If Round Robin is also active and we have country-matching candidates, assign by sequence among them\n        if (roundRobinActive && candidatesWithCountry.length > 0) {\n          try {\n            const { data: seqRows } = await StaffSequenceService.fetchSequence();\n            const ordered = (seqRows || [])\n              .filter(r => r.auto_assign_enabled !== false)\n              .filter(r => candidatesWithCountry.includes(String(r.staff_id)))\n              .sort((a, b) => Number(a.sequence_order || 0) - Number(b.sequence_order || 0));\n            const orderedIds = ordered.map(r => String(r.staff_id));\n\n            if (orderedIds.length > 0) {\n              // Build availability among sequence members\n              const staffByUuid = new Map<string, any>();\n              (activeStaff || []).forEach((s: any) => {\n                if (s && s.uuid) staffByUuid.set(String(s.uuid), s);\n              });\n\n              const availableIds = orderedIds.filter(uuid => {\n                const s = staffByUuid.get(uuid);\n                return s && s.active && s.assigned < s.workloadCapacity;\n              });\n\n              let nextUuid: string | null = null;\n              if (availableIds.length > 0) {\n                // Find most recently assigned among candidates, then pick next by sequence\n                const { data: recent } = await sb\n                  .from('assignment_history')\n                  .select('staff_id,assigned_at')\n                  .in('staff_id', orderedIds)\n                  .order('assigned_at', { ascending: false })\n                  .limit(1);\n                const lastId = Array.isArray(recent) && recent.length > 0 ? String((recent[0] as any).staff_id) : null;\n                const startIndex = lastId ? Math.max(orderedIds.indexOf(lastId), 0) : -1;\n                const total = orderedIds.length;\n                for (let step = 1; step <= total; step++) {\n                  const idx = ((startIndex + step) % total + total) % total;\n                  const candidate = orderedIds[idx];\n                  if (availableIds.includes(candidate)) {\n                    nextUuid = candidate;\n                    break;\n                  }\n                }\n              }\n\n              // Fallbacks: if none available within matching sequence, use best country match\n              if (!nextUuid) {\n                const best = activeStaff.length > 0 ? findBestStaffMatch(createdQuery, activeStaff as any) : null;\n                if (best && (best as any).uuid) nextUuid = (best as any).uuid;\n              }\n\n              if (nextUuid) {\n                const { error: assignErr } = await assignEnquiry(createdQuery.id, nextUuid, user?.id || undefined, 'Country Expertise', true);\n                if (!assignErr) {\n                  const { data: refetched } = await sb\n                    .from('enquiries')\n                    .select('*')\n                    .eq('id', (inserted as any).id)\n                    .limit(1)\n                    .maybeSingle();\n                  if (refetched) {\n                    return { data: toQuery(refetched as EnquiryRow), error: null };\n                  }\n                }\n              }\n            }\n          } catch {\n            // If sequence fetch fails, fall back to best-match strategy below\n          }\n        }\n\n        // If Round Robin not applicable or no matching candidates, use best-match (which prioritizes country)\n        const best = findBestStaffMatch(createdQuery, staff);\n        if (best && (best as any).uuid) {\n          const reason = getAssignmentReason(best, createdQuery);\n          const { error: assignErr } = await assignEnquiry(createdQuery.id, (best as any).uuid, user?.id || undefined, reason, true);\n          if (!assignErr) {\n            const { data: refetched } = await sb\n              .from('enquiries')\n              .select('*')\n              .eq('id', (inserted as any).id)\n              .limit(1)\n              .maybeSingle();\n            if (refetched) {\n              return { data: toQuery(refetched as EnquiryRow), error: null };\n            }\n          }\n        }\n      }\n\n      // When Round Robin is active AND smart rules are inactive, assign immediately using staff sequence\n      if (roundRobinActive && !workloadBalanceActive && !expertiseMatchActive) {\n        try {\n          const { data: seqRows } = await StaffSequenceService.fetchSequence();\n          const ordered = (seqRows || [])\n            .filter(r => r.auto_assign_enabled !== false)\n            .sort((a, b) => Number(a.sequence_order || 0) - Number(b.sequence_order || 0));\n          const orderedIds = ordered.map(r => String(r.staff_id));\n\n          if (orderedIds.length > 0) {\n            // Build availability among sequence members\n            const staffByUuid = new Map<string, any>();\n            (staff || []).forEach((s: any) => {\n              if (s && s.uuid) staffByUuid.set(String(s.uuid), s);\n            });\n\n            const availableIds = orderedIds.filter(uuid => {\n              const s = staffByUuid.get(uuid);\n              return s && s.active && s.assigned < s.workloadCapacity;\n            });\n\n            let nextUuid: string | null = null;\n            if (availableIds.length > 0) {\n              // Find most recently assigned among sequence, then pick the next in order\n              const { data: recent } = await sb\n                .from('assignment_history')\n                .select('staff_id,assigned_at')\n                .in('staff_id', orderedIds)\n                .order('assigned_at', { ascending: false })\n                .limit(1);\n              const lastId = Array.isArray(recent) && recent.length > 0 ? String((recent[0] as any).staff_id) : null;\n              const startIndex = lastId ? Math.max(orderedIds.indexOf(lastId), 0) : -1;\n              // Scan forward from next position for the first available\n              const total = orderedIds.length;\n              for (let step = 1; step <= total; step++) {\n                const idx = ((startIndex + step) % total + total) % total;\n                const candidate = orderedIds[idx];\n                if (availableIds.includes(candidate)) {\n                  nextUuid = candidate;\n                  break;\n                }\n              }\n            }\n\n            // Fallbacks: if no available in sequence, use best match\n            if (!nextUuid) {\n              const best = findBestStaffMatch(createdQuery, staff);\n              if (best && (best as any).uuid) nextUuid = (best as any).uuid;\n            }\n\n            if (nextUuid) {\n              const { error: assignErr } = await assignEnquiry(createdQuery.id, nextUuid, user?.id || undefined, 'Round Robin', true);\n              if (!assignErr) {\n                const { data: refetched } = await sb\n                  .from('enquiries')\n                  .select('*')\n                  .eq('id', (inserted as any).id)\n                  .limit(1)\n                  .maybeSingle();\n                if (refetched) {\n                  return { data: toQuery(refetched as EnquiryRow), error: null };\n                }\n              }\n            }\n          }\n        } catch {\n          // If sequence fetch fails, fall back to best-match strategy below\n        }\n      }\n      // Default/legacy behavior: use best match (expertise/workload)\n      const best = findBestStaffMatch(createdQuery, staff);\n      if (best && (best as any).uuid) {\n        const reason = getAssignmentReason(best, createdQuery);\n        const { error: assignErr } = await assignEnquiry(createdQuery.id, (best as any).uuid, user?.id || undefined, reason, true);\n        if (!assignErr) {\n          // Refetch to return updated assignment state\n          const { data: refetched } = await sb\n            .from('enquiries')\n            .select('*')\n            .eq('id', (inserted as any).id)\n            .limit(1)\n            .maybeSingle();\n          if (refetched) {\n            return { data: toQuery(refetched as EnquiryRow), error: null };\n          }\n        }\n      }\n    }\n  } catch (e) {\n    // Non-blocking: ignore auto-assign failures\n  }\n\n  return { data: createdQuery, error: null };\n}\n\nexport async function updateEnquiry(id: string, patch: Partial<Query>) {\n  // If assignment is changing, resolve staff ID and record assignment history after update\n  let resolvedStaffId: string | null = null;\n  let enquiryUuid: string | null = null;\n  try {\n    if (typeof patch.assignedTo === 'string' && patch.assignedTo.length > 0) {\n      // Resolve enquiry UUID from business id\n      const { data: found, error: findError } = await sb\n        .from('enquiries')\n        .select('id,enquiry_id')\n        .eq('enquiry_id', id)\n        .limit(1)\n        .maybeSingle();\n      if (!findError && found?.id) enquiryUuid = found.id as string;\n\n      // Try to resolve staff id if not a UUID\n      const looksLikeUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(patch.assignedTo);\n      if (looksLikeUuid) {\n        resolvedStaffId = patch.assignedTo;\n      } else {\n        let res = await sb\n          .from('staff_profiles')\n          .select('id,name')\n          .ilike('name', patch.assignedTo)\n          .limit(1)\n          .maybeSingle();\n        let staffFound = res.data;\n        // No full_name column; rely on name match only\n        resolvedStaffId = staffFound?.id || null;\n      }\n    }\n  } catch {}\n\n  const payload: Partial<EnquiryRow> = {\n    status: patch.status,\n    country_name: patch.destination?.country as any,\n    cities: patch.destination?.cities as any,\n    // Budget fields\n    budget_min: patch.budget?.min,\n    budget_max: patch.budget?.max,\n    budget_currency: patch.budget?.currency,\n    // Travel date fields\n    travel_from: toDateOnly(patch.travelDates?.from) as any,\n    travel_to: toDateOnly(patch.travelDates?.to) as any,\n    is_date_estimated: patch.travelDates?.isEstimated,\n    // Agent mapping (prefer Supabase UUID)\n    agent_id: (patch.agentUuid && patch.agentUuid.trim().length > 0) ? patch.agentUuid : undefined,\n    // Trip duration\n    nights: patch.tripDuration?.nights,\n    days: patch.tripDuration?.days,\n    // Pax details\n    adults: patch.paxDetails?.adults,\n    children: patch.paxDetails?.children,\n    infants: patch.paxDetails?.infants,\n    // Package details\n    package_type: patch.packageType,\n    priority: patch.priority,\n    communication_preference: patch.communicationPreference,\n    notes: patch.notes,\n    special_requests: Array.isArray(patch.specialRequests) ? patch.specialRequests : undefined,\n    hotel_rooms: patch.hotelDetails?.rooms,\n    hotel_category: patch.hotelDetails?.category,\n    transfers: patch.inclusions?.transfers,\n    meal_plan: patch.inclusions?.mealPlan,\n    sightseeing: patch.inclusions?.sightseeing,\n    assigned_to: typeof patch.assignedTo === 'string' ? (resolvedStaffId || patch.assignedTo) : undefined,\n    city_allocations: (patch as any)?.cityAllocations as any,\n    // Timestamp\n    updated_at: new Date().toISOString(),\n  };\n\n  const { error } = await sb.from('enquiries').update(payload).eq('enquiry_id', id);\n  if (error) return { error };\n\n  // Record assignment history when assigned_to was provided\n  try {\n    if (typeof patch.assignedTo === 'string' && (resolvedStaffId || enquiryUuid)) {\n      // Ensure we have enquiry UUID\n      if (!enquiryUuid) {\n        const { data: found } = await sb\n          .from('enquiries')\n          .select('id')\n          .eq('enquiry_id', id)\n          .limit(1)\n          .maybeSingle();\n        enquiryUuid = found?.id || null;\n      }\n\n      // Get current user for assigned_by\n      let assignedBy: string | null = null;\n      try {\n        const { data: auth } = await (supabase as any).auth.getUser();\n        assignedBy = auth?.user?.id || null;\n      } catch {}\n\n      // Insert into assignment_history\n      if (enquiryUuid && (resolvedStaffId || patch.assignedTo)) {\n        await sb.from('assignment_history').insert({\n          enquiry_id: enquiryUuid,\n          staff_id: resolvedStaffId || patch.assignedTo,\n          assigned_by: assignedBy,\n          reason: patch.notes || null,\n          is_auto_assigned: false,\n        });\n      }\n    }\n  } catch {}\n\n  return { error: null };\n}\n\nexport async function deleteEnquiry(id: string) {\n  // Soft-delete via status to respect RLS rules\n  const { error } = await sb.from('enquiries').update({ status: 'deleted' }).eq('enquiry_id', id);\n  return { error };\n}\n\nexport async function uploadAttachment(enquiryId: string, file: File) {\n  const path = `${enquiryId}/${file.name}`;\n  const { data, error } = await supabase.storage\n    .from('enquiry-attachments')\n    .upload(path, file, { cacheControl: '3600', upsert: false });\n  if (error) return { error };\n  const { data: pub } = supabase.storage.from('enquiry-attachments').getPublicUrl(data.path);\n  return { url: pub.publicUrl };\n}\n\n// Realtime subscription\nexport function subscribeEnquiries(onChange: (type: 'INSERT' | 'UPDATE' | 'DELETE', row: any) => void) {\n  const channel = supabase\n    .channel('public:enquiries')\n    .on('postgres_changes', { event: '*', schema: 'public', table: 'enquiries' }, (payload) => {\n      onChange(payload.eventType as any, payload.new ?? payload.old);\n    })\n    .subscribe();\n  return channel;\n}\n\n// React hook: server-side pagination and filters, optimistic updates supported externally\nimport { useEffect, useState, useCallback } from 'react';\n\nexport function useEnquiries(params: UseEnquiriesParams) {\n  const [data, setData] = useState<Query[]>([]);\n  const [count, setCount] = useState(0);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchData = useCallback(async () => {\n    setIsLoading(true);\n    try {\n      const res = await listEnquiries(params);\n      setData(res.data);\n      setCount(res.count);\n      setError(null);\n    } catch (e: any) {\n      console.error('Failed loading enquiries', e);\n      setError(e);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [params.page, params.pageSize, params.search, params.filters?.status, params.sort?.field, params.sort?.direction]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  useEffect(() => {\n    const ch = subscribeEnquiries((_type) => {\n      // On realtime change, refetch\n      fetchData();\n    });\n    return () => {\n      try { supabase.removeChannel(ch); } catch {}\n    };\n  }, [fetchData]);\n\n  // No online/localStorage synchronization  always source from Supabase\n\n  return { data, count, isLoading, error, refetch: fetchData };\n}\n\n// Single fetch by business ID (enquiry_id) or UUID\nexport async function getEnquiryById(id: string) {\n  const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id);\n  let q = sb.from('enquiries').select('*').limit(1);\n  q = isUuid ? q.eq('id', id) : q.eq('enquiry_id', id);\n  const { data, error } = await q.maybeSingle();\n  if (error) return { data: null, error };\n  if (!data) return { data: null, error: null };\n\n  const base = toQuery(data as EnquiryRow);\n  let enriched = { ...base } as Query;\n  try {\n    const agentId = (data as any)?.agent_id ? String((data as any).agent_id) : null;\n    if (agentId) {\n      const { data: agentRow, error: agentErr } = await sb\n        .from('agents' as any)\n        .select('id,name,agency_name,email')\n        .eq('id', agentId)\n        .maybeSingle();\n      if (!agentErr && agentRow) {\n        const name = (agentRow as any)?.name || (agentRow as any)?.agency_name || (agentRow as any)?.email || enriched.agentName || '';\n        const company = (agentRow as any)?.agency_name || enriched.agentCompany || '';\n        enriched = { ...enriched, agentName: name, agentCompany: company } as Query;\n      }\n    }\n  } catch {}\n\n  return { data: enriched, error: null };\n}\n\n// Search enquiries by last digits of `enquiry_id` and enrich with agent details\nexport async function searchEnquiriesBySuffix(suffix: string, limit: number = 50) {\n  try {\n    const trimmed = String(suffix || '').trim();\n    if (!/^\\d{1,10}$/.test(trimmed)) {\n      return { data: [], error: null };\n    }\n\n    // Find enquiries where business ID ends with the provided digits\n    const { data, error } = await (sb\n      .from('enquiries')\n      .select('id,enquiry_id,country_name,cities,agent_id')\n      .like('enquiry_id', `%${trimmed}`)\n      .order('enquiry_id', { ascending: false })\n      .limit(limit)\n    );\n    if (error) return { data: [], error };\n    const rows = Array.isArray(data) ? data : [];\n\n    // Collect unique agent IDs for enrichment\n    const agentIds = Array.from(\n      new Set(\n        rows\n          .map((r: any) => (r?.agent_id ? String(r.agent_id) : null))\n          .filter((id: string | null): id is string => !!id)\n      )\n    );\n\n    let agentsMap = new Map<string, { name?: string; agency_name?: string }>();\n    if (agentIds.length > 0) {\n      try {\n        const { data: agentsData, error: agentsErr } = await sb\n          .from('agents' as any)\n          .select('id,name,agency_name')\n          .in('id', agentIds);\n        if (!agentsErr && Array.isArray(agentsData)) {\n          (agentsData as any[]).forEach((a: any) => {\n            agentsMap.set(String(a.id), {\n              name: (a as any)?.name,\n              agency_name: (a as any)?.agency_name,\n            });\n          });\n        }\n      } catch {}\n    }\n\n    const suggestions = rows.map((r: any) => {\n      const agentInfo = agentsMap.get(String(r?.agent_id));\n      return {\n        enquiry_id: String((r as any)?.enquiry_id || ''),\n        country_name: String((r as any)?.country_name || ''),\n        cities: Array.isArray((r as any)?.cities) ? (r as any)?.cities : [],\n        agent_id: (r as any)?.agent_id ? String((r as any)?.agent_id) : null,\n        agent_name: agentInfo?.name || '',\n        agency_name: agentInfo?.agency_name || ''\n      } as {\n        enquiry_id: string;\n        country_name: string;\n        cities: any[];\n        agent_id: string | null;\n        agent_name: string;\n        agency_name: string;\n      };\n    });\n\n    return { data: suggestions, error: null };\n  } catch (e: any) {\n    return { data: [], error: e };\n  }\n}\n\n// Assignment helper: updates assigned_to and records assignment history\nexport async function assignEnquiry(\n  enquiryBusinessId: string,\n  staffIdOrName: string,\n  assignedBy?: string,\n  reason?: string,\n  isAutoAssigned?: boolean\n) {\n  // First, find the enquiry UUID\n  const { data: found, error: findError } = await sb\n    .from('enquiries')\n    .select('id,enquiry_id,assigned_to,status')\n    .eq('enquiry_id', enquiryBusinessId)\n    .limit(1)\n    .maybeSingle();\n  if (findError || !found?.id) return { error: findError || new Error('Enquiry not found') };\n\n  const previousAssignedId: string | null = (found as any)?.assigned_to || null;\n  const previousStatus: string | null = (found as any)?.status || null;\n  let previousAssignedName: string | null = null;\n  let previousAssignedNameSource: 'staff' | 'profiles' | 'agents' | undefined;\n  try {\n    if (previousAssignedId) {\n      // Prefer staff table\n      const { data: prevStaffRow, error: prevStaffErr } = await sb\n        .from('staff' as any)\n        .select('name,email')\n        .eq('id', previousAssignedId)\n        .limit(1)\n        .maybeSingle();\n      if (!prevStaffErr && prevStaffRow) {\n        previousAssignedName = (prevStaffRow as any)?.name || (prevStaffRow as any)?.email || null;\n        previousAssignedNameSource = 'staff';\n      }\n      // Fallback: profiles\n      if (!previousAssignedName) {\n        const { data: prevProfile, error: prevProfErr } = await sb\n          .from('profiles')\n          .select('name,username,email')\n          .eq('id', previousAssignedId)\n          .limit(1)\n          .maybeSingle();\n        if (!prevProfErr && prevProfile) {\n          previousAssignedName = (prevProfile as any)?.name || (prevProfile as any)?.username || (prevProfile as any)?.email || null;\n          previousAssignedNameSource = 'profiles';\n        }\n      }\n      // Fallback: agents by user_id then id\n      if (!previousAssignedName) {\n        const { data: agentByUser, error: agentUserErr } = await sb\n          .from('agents')\n          .select('name,agency_name,email,user_id,id')\n          .eq('user_id', previousAssignedId)\n          .limit(1)\n          .maybeSingle();\n        if (!agentUserErr && agentByUser) {\n          previousAssignedName = (agentByUser as any)?.name || (agentByUser as any)?.agency_name || (agentByUser as any)?.email || null;\n          previousAssignedNameSource = 'agents';\n        } else {\n          const { data: agentById, error: agentIdErr } = await sb\n            .from('agents')\n            .select('name,agency_name,email,user_id,id')\n            .eq('id', previousAssignedId)\n            .limit(1)\n            .maybeSingle();\n          if (!agentIdErr && agentById) {\n            previousAssignedName = (agentById as any)?.name || (agentById as any)?.agency_name || (agentById as any)?.email || null;\n            previousAssignedNameSource = 'agents';\n          }\n        }\n      }\n    }\n  } catch {}\n\n  // Resolve staff ID if a name was provided\n  let staffProfileId = staffIdOrName;\n  let staffAssignedName: string | null = null;\n  let assignedToNameSource: 'staff' | 'profiles' | 'agents' | undefined;\n  const looksLikeUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(staffIdOrName);\n  if (!looksLikeUuid) {\n    // Resolve by name: prefer staff, then profiles\n    let res = await sb\n      .from('staff' as any)\n      .select('id,name,role')\n      .ilike('name', staffIdOrName)\n      .limit(1)\n      .maybeSingle();\n    let staffFound = res.data;\n    // Block assignment to super admins\n    if (staffFound?.role === 'super_admin') {\n      return { error: new Error('Cannot assign to super admin accounts') };\n    }\n    if (!staffFound?.id) {\n      // Try profiles by name\n      res = await sb\n        .from('profiles')\n        .select('id,name,username,role')\n        .ilike('name', staffIdOrName)\n        .limit(1)\n        .maybeSingle();\n      staffFound = res.data;\n      // Block assignment to super admins\n      if ((staffFound as any)?.role === 'super_admin') {\n        return { error: new Error('Cannot assign to super admin accounts') };\n      }\n      if (!staffFound?.id) {\n        // Fallback: match by username\n        res = await sb\n          .from('profiles')\n          .select('id,name,username,role')\n          .ilike('username', staffIdOrName)\n          .limit(1)\n          .maybeSingle();\n        staffFound = res.data;\n        if ((staffFound as any)?.role === 'super_admin') {\n          return { error: new Error('Cannot assign to super admin accounts') };\n        }\n      }\n      if (staffFound?.id) {\n        staffAssignedName = (staffFound as any)?.name || (staffFound as any)?.username || null;\n        assignedToNameSource = 'profiles';\n      }\n    }\n    if (!staffFound?.id) {\n      return { error: res.error || new Error('Staff profile not found for name: ' + staffIdOrName) };\n    }\n    staffProfileId = (staffFound as any).id as string;\n    if (!staffAssignedName) {\n      staffAssignedName = (staffFound as any)?.name || null;\n      assignedToNameSource = assignedToNameSource || 'staff';\n    }\n  } else {\n    // Resolve display name for UUID case\n    try {\n      const { data: staffRow, error: staffErr } = await sb\n        .from('staff' as any)\n        .select('name,email,role')\n        .eq('id', staffProfileId)\n        .limit(1)\n        .maybeSingle();\n      if (!staffErr && staffRow) {\n        if ((staffRow as any)?.role === 'super_admin') {\n          return { error: new Error('Cannot assign to super admin accounts') };\n        }\n        staffAssignedName = (staffRow as any)?.name || (staffRow as any)?.email || null;\n        assignedToNameSource = 'staff';\n      }\n      if (!staffAssignedName) {\n        const { data: profRow, error: profErr } = await sb\n          .from('profiles')\n          .select('name,username,email,role')\n          .eq('id', staffProfileId)\n          .limit(1)\n          .maybeSingle();\n        if (!profErr && profRow) {\n          if ((profRow as any)?.role === 'super_admin') {\n            return { error: new Error('Cannot assign to super admin accounts') };\n          }\n          staffAssignedName = (profRow as any)?.name || (profRow as any)?.username || (profRow as any)?.email || null;\n          assignedToNameSource = 'profiles';\n        }\n      }\n      if (!staffAssignedName) {\n        const { data: agentByUser, error: agentUserErr } = await sb\n          .from('agents')\n          .select('name,agency_name,email,user_id,id')\n          .eq('user_id', staffProfileId)\n          .limit(1)\n          .maybeSingle();\n        if (!agentUserErr && agentByUser) {\n          staffAssignedName = (agentByUser as any)?.name || (agentByUser as any)?.agency_name || (agentByUser as any)?.email || null;\n          assignedToNameSource = 'agents';\n        } else {\n          const { data: agentById, error: agentIdErr } = await sb\n            .from('agents')\n            .select('name,agency_name,email,user_id,id')\n            .eq('id', staffProfileId)\n            .limit(1)\n            .maybeSingle();\n          if (!agentIdErr && agentById) {\n            staffAssignedName = (agentById as any)?.name || (agentById as any)?.agency_name || (agentById as any)?.email || null;\n            assignedToNameSource = 'agents';\n          }\n        }\n      }\n    } catch {}\n  }\n\n  // Update assignment on the enquiry\n  const { error: updateError } = await sb\n    .from('enquiries')\n    .update({ assigned_to: staffProfileId, status: 'assigned' })\n    .eq('id', found.id);\n  if (updateError) return { error: updateError };\n\n  // Insert assignment history\n  const { error: historyError } = await sb\n    .from('assignment_history')\n    .insert({\n      enquiry_id: found.id,\n      staff_id: staffProfileId,\n      assigned_by: assignedBy || null,\n      reason: reason || null,\n      // Persist the specific rule label used for assignment for clearer UI feedback\n      rule_applied: reason || null,\n      is_auto_assigned: !!isAutoAssigned,\n    });\n  if (historyError) return { error: historyError };\n\n  // Record workflow event (assigned)\n  try {\n    await createWorkflowEvent({\n      enquiryBusinessId,\n      eventType: 'assigned',\n      userId: assignedBy || null,\n      userName: null,\n      userRole: isAutoAssigned ? 'system' : null,\n      details: `Assigned to ${staffAssignedName || staffProfileId}${previousAssignedId ? ` (prev: ${previousAssignedName || previousAssignedId})` : ''}`,\n      metadata: {\n        assignedTo: staffProfileId,\n        assignedToName: staffAssignedName || undefined,\n        assignedToNameSource: assignedToNameSource || undefined,\n        assignedBy,\n        isAutoAssigned: !!isAutoAssigned,\n        reason: reason || undefined,\n        previousAssignedId: previousAssignedId || undefined,\n        previousAssignedName: previousAssignedName || undefined,\n        previousAssignedNameSource: previousAssignedNameSource || undefined,\n        oldStatus: previousStatus || undefined,\n        newStatus: 'assigned'\n      },\n    });\n  } catch (e) {\n    // Non-blocking: ignore workflow event failure\n  }\n\n  return { error: null };\n}\n\n// Ensure enquiry configuration exists and includes the given country. Also sync localStorage for legacy utils.\nexport async function ensureCountryConfig(countryCode?: string): Promise<EnquiryConfiguration> {\n  try {\n    const existing = (await AppSettingsService.getSettingValue(SETTING_CATEGORIES.GENERAL, 'enquiry_configuration')) as EnquiryConfiguration | null;\n    let config: EnquiryConfiguration = existing ?? {\n      countries: DEFAULT_ENQUIRY_COUNTRIES,\n      defaultCountryCode: 'TH'\n    };\n\n    // If a target country is provided, ensure it's present and active in the config\n    if (countryCode) {\n      const hasCountry = Array.isArray(config.countries) && config.countries.some(c => c.countryCode === countryCode && c.isActive);\n      if (!hasCountry) {\n        const invCountry = initialCountries.find(c => c.code === countryCode);\n        const template = DEFAULT_ENQUIRY_COUNTRIES.find(c => c.countryCode === countryCode) || DEFAULT_ENQUIRY_COUNTRIES[0];\n        const newCountry: CountryEnquirySettings = {\n          countryCode,\n          countryName: invCountry?.name || countryCode,\n          prefix: template?.prefix || 'ENQ',\n          yearFormat: template?.yearFormat || 'YYYY',\n          yearSeparator: template?.yearSeparator || 'none',\n          numberLength: template?.numberLength || 4,\n          numberSeparator: template?.numberSeparator || 'none',\n          startingNumber: template?.startingNumber || 1,\n          isDefault: false,\n          isActive: true\n        };\n        config = {\n          ...config,\n          countries: [...(config.countries || []), newCountry]\n        };\n        if (!config.defaultCountryCode) {\n          config.defaultCountryCode = countryCode;\n        }\n      }\n    }\n\n    // Persist to unified App Settings store (DB with local fallback)\n    await AppSettingsHelpers.upsertSetting({\n      category: SETTING_CATEGORIES.GENERAL,\n      setting_key: 'enquiry_configuration',\n      setting_json: config as any,\n      data_type: 'json',\n      is_active: true\n    });\n\n    // Keep legacy localStorage in sync for EnqIdGenerator\n    try {\n      const stored = localStorage.getItem('applicationSettings');\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        const updated = { ...parsed, enquirySettings: config };\n        localStorage.setItem('applicationSettings', JSON.stringify(updated));\n      } else {\n        localStorage.setItem('applicationSettings', JSON.stringify({ enquirySettings: config }));\n      }\n    } catch {}\n\n    return config;\n  } catch (e) {\n    // On any error, fall back to defaults and ensure at least localStorage has config\n    const fallback: EnquiryConfiguration = {\n      countries: DEFAULT_ENQUIRY_COUNTRIES,\n      defaultCountryCode: 'TH'\n    };\n    try {\n      localStorage.setItem('applicationSettings', JSON.stringify({ enquirySettings: fallback }));\n    } catch {}\n    return fallback;\n  }\n}\n","// SEO and Profile Service for database operations\n// Note: This service is designed to work with the new database schema\n// For now, it includes fallback functionality for when tables don't exist\n\nexport interface SEOSettings {\n  id?: string;\n  page_route: string;\n  title: string;\n  description: string;\n  keywords: string[];\n  og_title?: string;\n  og_description?: string;\n  og_image?: string;\n  twitter_title?: string;\n  twitter_description?: string;\n  twitter_image?: string;\n  canonical_url?: string;\n  structured_data?: any;\n  meta_robots?: string;\n  is_active?: boolean;\n  created_at?: string;\n  updated_at?: string;\n}\n\nexport interface EnhancedProfile {\n  id?: string;\n  user_id: string;\n  first_name?: string;\n  last_name?: string;\n  display_name?: string;\n  bio?: string;\n  avatar_url?: string;\n  phone?: string;\n  address?: any;\n  social_links?: any;\n  preferences?: any;\n  settings?: any;\n  timezone?: string;\n  language?: string;\n  notification_preferences?: any;\n  privacy_settings?: any;\n  last_active?: string;\n  is_verified?: boolean;\n  verification_data?: any;\n  created_at?: string;\n  updated_at?: string;\n}\n\nexport interface ProfileActivityLog {\n  id?: string;\n  user_id: string;\n  action: string;\n  field_changed?: string;\n  old_value?: any;\n  new_value?: any;\n  ip_address?: string;\n  user_agent?: string;\n  created_at?: string;\n}\n\n// Default SEO settings for different routes\nconst DEFAULT_SEO_SETTINGS: Record<string, SEOSettings> = {\n  '/dashboard': {\n    page_route: '/dashboard',\n    title: 'Dashboard - Tour Management System',\n    description: 'Comprehensive dashboard for tour operators with analytics, bookings, and business intelligence.',\n    keywords: ['dashboard', 'tour management', 'analytics', 'business intelligence'],\n    og_title: 'Tour Management Dashboard',\n    og_description: 'Access your complete tour business overview with real-time analytics and insights.',\n    meta_robots: 'index,follow',\n    is_active: true\n  },\n  '/sales/dashboard': {\n    page_route: '/sales/dashboard',\n    title: 'Sales Dashboard - Tour Management System',\n    description: 'Advanced sales analytics and performance metrics for tour operators and travel agencies.',\n    keywords: ['sales dashboard', 'sales analytics', 'tour sales', 'performance metrics'],\n    og_title: 'Sales Performance Dashboard',\n    og_description: 'Track your sales performance with detailed analytics and revenue insights.',\n    meta_robots: 'index,follow',\n    is_active: true\n  },\n  '/inventory/restaurants': {\n    page_route: '/inventory/restaurants',\n    title: 'Restaurant Management - Tour Inventory System',\n    description: 'Comprehensive restaurant inventory management for tour operators with pricing, cuisine types, and booking details.',\n    keywords: ['restaurant management', 'tour inventory', 'dining options', 'restaurant booking'],\n    og_title: 'Restaurant Inventory Management',\n    og_description: 'Manage your restaurant partnerships and dining options for tour packages.',\n    meta_robots: 'index,follow',\n    is_active: true\n  },\n  '/profile': {\n    page_route: '/profile',\n    title: 'User Profile - Tour Management System',\n    description: 'Manage your profile settings, preferences, and account information in the tour management system.',\n    keywords: ['user profile', 'account settings', 'profile management', 'user preferences'],\n    og_title: 'User Profile Settings',\n    og_description: 'Update your profile information and customize your tour management experience.',\n    meta_robots: 'index,follow',\n    is_active: true\n  }\n};\n\nclass SEOService {\n  private localStorageKey = 'tour_seo_settings';\n  private profileStorageKey = 'tour_enhanced_profiles';\n  private activityLogKey = 'tour_activity_log';\n\n  // SEO Settings Methods\n  async getSEOSettings(pageRoute: string): Promise<SEOSettings | null> {\n    try {\n      // Try to get from localStorage first (fallback)\n      const stored = localStorage.getItem(this.localStorageKey);\n      const settings = stored ? JSON.parse(stored) : {};\n      \n      // Return stored setting or default\n      return settings[pageRoute] || DEFAULT_SEO_SETTINGS[pageRoute] || null;\n    } catch (error) {\n      console.error('Error in getSEOSettings:', error);\n      return DEFAULT_SEO_SETTINGS[pageRoute] || null;\n    }\n  }\n\n  async getAllSEOSettings(): Promise<SEOSettings[]> {\n    try {\n      const stored = localStorage.getItem(this.localStorageKey);\n      const settings = stored ? JSON.parse(stored) : {};\n      \n      // Merge with defaults\n      const allSettings = { ...DEFAULT_SEO_SETTINGS, ...settings };\n      return Object.values(allSettings);\n    } catch (error) {\n      console.error('Error in getAllSEOSettings:', error);\n      return Object.values(DEFAULT_SEO_SETTINGS);\n    }\n  }\n\n  async upsertSEOSettings(settings: Partial<SEOSettings>): Promise<SEOSettings | null> {\n    try {\n      if (!settings.page_route) {\n        throw new Error('page_route is required');\n      }\n\n      const stored = localStorage.getItem(this.localStorageKey);\n      const allSettings = stored ? JSON.parse(stored) : {};\n      \n      const updatedSettings = {\n        ...allSettings[settings.page_route],\n        ...settings,\n        updated_at: new Date().toISOString()\n      };\n\n      allSettings[settings.page_route] = updatedSettings;\n      localStorage.setItem(this.localStorageKey, JSON.stringify(allSettings));\n\n      return updatedSettings as SEOSettings;\n    } catch (error) {\n      console.error('Error in upsertSEOSettings:', error);\n      return null;\n    }\n  }\n\n  // Enhanced Profile Methods\n  async getEnhancedProfile(userId: string): Promise<EnhancedProfile | null> {\n    try {\n      const stored = localStorage.getItem(this.profileStorageKey);\n      const profiles = stored ? JSON.parse(stored) : {};\n      return profiles[userId] || null;\n    } catch (error) {\n      console.error('Error in getEnhancedProfile:', error);\n      return null;\n    }\n  }\n\n  async upsertEnhancedProfile(profile: Partial<EnhancedProfile>): Promise<EnhancedProfile | null> {\n    try {\n      if (!profile.user_id) {\n        throw new Error('user_id is required');\n      }\n\n      const stored = localStorage.getItem(this.profileStorageKey);\n      const profiles = stored ? JSON.parse(stored) : {};\n      \n      const existingProfile = profiles[profile.user_id] || {};\n      const updatedProfile = {\n        ...existingProfile,\n        ...profile,\n        updated_at: new Date().toISOString(),\n        last_active: new Date().toISOString()\n      };\n\n      profiles[profile.user_id] = updatedProfile;\n      localStorage.setItem(this.profileStorageKey, JSON.stringify(profiles));\n\n      // Log the activity\n      await this.logProfileActivity(\n        profile.user_id,\n        existingProfile.id ? 'update' : 'create',\n        'profile',\n        existingProfile,\n        updatedProfile\n      );\n\n      return updatedProfile as EnhancedProfile;\n    } catch (error) {\n      console.error('Error in upsertEnhancedProfile:', error);\n      return null;\n    }\n  }\n\n  async getProfileActivityLog(userId: string, limit: number = 50): Promise<ProfileActivityLog[]> {\n    try {\n      const stored = localStorage.getItem(this.activityLogKey);\n      const logs = stored ? JSON.parse(stored) : [];\n      \n      return logs\n        .filter((log: ProfileActivityLog) => log.user_id === userId)\n        .sort((a: ProfileActivityLog, b: ProfileActivityLog) => \n          new Date(b.created_at || '').getTime() - new Date(a.created_at || '').getTime()\n        )\n        .slice(0, limit);\n    } catch (error) {\n      console.error('Error in getProfileActivityLog:', error);\n      return [];\n    }\n  }\n\n  async logProfileActivity(\n    userId: string, \n    action: string, \n    fieldChanged?: string, \n    oldValue?: any, \n    newValue?: any\n  ): Promise<boolean> {\n    try {\n      const stored = localStorage.getItem(this.activityLogKey);\n      const logs = stored ? JSON.parse(stored) : [];\n      \n      const newLog: ProfileActivityLog = {\n        id: `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        user_id: userId,\n        action,\n        field_changed: fieldChanged,\n        old_value: oldValue,\n        new_value: newValue,\n        user_agent: navigator.userAgent,\n        created_at: new Date().toISOString()\n      };\n\n      logs.push(newLog);\n      \n      // Keep only last 1000 logs to prevent storage bloat\n      if (logs.length > 1000) {\n        logs.splice(0, logs.length - 1000);\n      }\n\n      localStorage.setItem(this.activityLogKey, JSON.stringify(logs));\n      return true;\n    } catch (error) {\n      console.error('Error in logProfileActivity:', error);\n      return false;\n    }\n  }\n\n  // Real-time simulation methods (for localStorage-based implementation)\n  subscribeToSEOSettings(callback: (settings: SEOSettings) => void) {\n    const handleStorageChange = (e: StorageEvent) => {\n      if (e.key === this.localStorageKey && e.newValue) {\n        try {\n          const settings = JSON.parse(e.newValue);\n          Object.values(settings).forEach(setting => {\n            callback(setting as SEOSettings);\n          });\n        } catch (error) {\n          console.error('Error parsing SEO settings from storage event:', error);\n        }\n      }\n    };\n\n    window.addEventListener('storage', handleStorageChange);\n    \n    return {\n      unsubscribe: () => {\n        window.removeEventListener('storage', handleStorageChange);\n      }\n    };\n  }\n\n  subscribeToEnhancedProfile(userId: string, callback: (profile: EnhancedProfile) => void) {\n    const handleStorageChange = (e: StorageEvent) => {\n      if (e.key === this.profileStorageKey && e.newValue) {\n        try {\n          const profiles = JSON.parse(e.newValue);\n          if (profiles[userId]) {\n            callback(profiles[userId]);\n          }\n        } catch (error) {\n          console.error('Error parsing profile from storage event:', error);\n        }\n      }\n    };\n\n    window.addEventListener('storage', handleStorageChange);\n    \n    return {\n      unsubscribe: () => {\n        window.removeEventListener('storage', handleStorageChange);\n      }\n    };\n  }\n\n  // Utility methods\n  async getCurrentUser() {\n    // Fallback user simulation\n    return {\n      id: 'user_' + Math.random().toString(36).substr(2, 9),\n      email: 'user@example.com'\n    };\n  }\n\n  // Auto-save functionality\n  createAutoSave<T>(\n    key: string,\n    saveFunction: (data: T) => Promise<T | null>,\n    debounceMs: number = 1000\n  ) {\n    let timeoutId: NodeJS.Timeout;\n    \n    return (data: T) => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(async () => {\n        try {\n          await saveFunction(data);\n        } catch (error) {\n          console.error('Auto-save error:', error);\n        }\n      }, debounceMs);\n    };\n  }\n}\n\nexport const seoService = new SEOService();\nexport default seoService;","\nimport { Agent } from '@/types/agent';\n\nconst AGENTS_STORAGE_KEY = 'travel_agents';\n\nexport class AgentStorageService {\n  static getAgents(): Agent[] {\n    try {\n      const storedAgents = localStorage.getItem(AGENTS_STORAGE_KEY);\n      return storedAgents ? JSON.parse(storedAgents) : [];\n    } catch (error) {\n      console.error('Error loading agents from localStorage:', error);\n      return [];\n    }\n  }\n\n  static saveAgent(agent: Omit<Agent, 'id'>): Agent {\n    try {\n      const agents = this.getAgents();\n      const newId = Math.max(0, ...agents.map(a => a.id)) + 1;\n      \n      const newAgent: Agent = {\n        ...agent,\n        id: newId,\n        createdAt: new Date().toISOString(),\n        stats: {\n          totalQueries: 0,\n          totalBookings: 0,\n          conversionRate: 0,\n          revenueGenerated: 0,\n          averageBookingValue: 0,\n          activeCustomers: 0\n        },\n        recentActivity: []\n      };\n\n      const updatedAgents = [...agents, newAgent];\n      localStorage.setItem(AGENTS_STORAGE_KEY, JSON.stringify(updatedAgents));\n      \n      return newAgent;\n    } catch (error) {\n      console.error('Error saving agent to localStorage:', error);\n      throw new Error('Failed to save agent');\n    }\n  }\n\n  static updateAgent(id: number, updates: Partial<Agent>): Agent | null {\n    try {\n      const agents = this.getAgents();\n      const agentIndex = agents.findIndex(a => a.id === id);\n      \n      if (agentIndex === -1) {\n        return null;\n      }\n\n      const updatedAgent = { ...agents[agentIndex], ...updates };\n      agents[agentIndex] = updatedAgent;\n      \n      localStorage.setItem(AGENTS_STORAGE_KEY, JSON.stringify(agents));\n      return updatedAgent;\n    } catch (error) {\n      console.error('Error updating agent:', error);\n      return null;\n    }\n  }\n\n  static deleteAgent(id: number): boolean {\n    try {\n      const agents = this.getAgents();\n      const filteredAgents = agents.filter(a => a.id !== id);\n      \n      localStorage.setItem(AGENTS_STORAGE_KEY, JSON.stringify(filteredAgents));\n      return true;\n    } catch (error) {\n      console.error('Error deleting agent:', error);\n      return false;\n    }\n  }\n}\n","import { StaffNotification } from '@/types/query';\nimport { staffNotificationService } from './staffNotificationService';\n\nexport interface RealTimeNotificationConfig {\n  enableWebSocket: boolean;\n  enablePushNotifications: boolean;\n  enableSoundNotifications: boolean;\n  reconnectInterval: number;\n  maxReconnectAttempts: number;\n}\n\nexport interface NotificationSubscriber {\n  id: string;\n  callback: (notification: StaffNotification) => void;\n  filters?: {\n    types?: StaffNotification['type'][];\n    priorities?: StaffNotification['priority'][];\n    staffIds?: string[];\n  };\n}\n\nclass RealTimeNotificationService {\n  private ws: WebSocket | null = null;\n  private subscribers: Map<string, NotificationSubscriber> = new Map();\n  private config: RealTimeNotificationConfig;\n  private reconnectAttempts = 0;\n  private reconnectTimer: NodeJS.Timeout | null = null;\n  private isConnected = false;\n  private audioContext: AudioContext | null = null;\n  private notificationSound: AudioBuffer | null = null;\n\n  constructor() {\n    this.config = {\n      enableWebSocket: false, // Disabled by default since no WebSocket server is running\n      enablePushNotifications: true,\n      enableSoundNotifications: true,\n      reconnectInterval: 5000,\n      maxReconnectAttempts: 10\n    };\n\n    this.initializeAudioContext();\n    this.setupServiceWorker();\n  }\n\n  // Initialize audio context for notification sounds\n  private async initializeAudioContext() {\n    try {\n      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n      \n      // Create a simple notification sound\n      const buffer = this.audioContext.createBuffer(1, 44100 * 0.1, 44100);\n      const data = buffer.getChannelData(0);\n      \n      for (let i = 0; i < data.length; i++) {\n        data[i] = Math.sin(2 * Math.PI * 800 * i / 44100) * 0.1;\n      }\n      \n      this.notificationSound = buffer;\n    } catch (error) {\n      console.warn('Audio context initialization failed:', error);\n    }\n  }\n\n  // Setup service worker for push notifications\n  private async setupServiceWorker() {\n    // Only register service worker in production when explicitly enabled\n    const enableSw = (import.meta as any).env?.VITE_ENABLE_SW === 'true';\n    const isProd = (import.meta as any).env?.PROD;\n    if (!enableSw || !isProd) {\n      return;\n    }\n\n    if ('serviceWorker' in navigator && 'PushManager' in window) {\n      try {\n        const registration = await navigator.serviceWorker.register('/sw.js');\n        console.log('Service Worker registered:', registration);\n      } catch (error) {\n        console.warn('Service Worker registration failed:', error);\n      }\n    }\n  }\n\n  // Connect to WebSocket server\n  connect(userId: string, wsUrl?: string) {\n    if (!this.config.enableWebSocket) return;\n\n    const url = wsUrl || `ws://localhost:8080/notifications/${userId}`;\n    \n    try {\n      this.ws = new WebSocket(url);\n      \n      this.ws.onopen = () => {\n        console.log('WebSocket connected');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n        \n        // Send authentication message\n        this.ws?.send(JSON.stringify({\n          type: 'auth',\n          userId: userId,\n          timestamp: new Date().toISOString()\n        }));\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          this.handleIncomingNotification(data);\n        } catch (error) {\n          console.error('Failed to parse WebSocket message:', error);\n        }\n      };\n\n      this.ws.onclose = () => {\n        console.log('WebSocket disconnected');\n        this.isConnected = false;\n        this.attemptReconnect(userId, wsUrl);\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n      };\n\n    } catch (error) {\n      console.error('Failed to connect to WebSocket:', error);\n      this.attemptReconnect(userId, wsUrl);\n    }\n  }\n\n  // Attempt to reconnect to WebSocket\n  private attemptReconnect(userId: string, wsUrl?: string) {\n    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      return;\n    }\n\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.config.maxReconnectAttempts})`);\n\n    this.reconnectTimer = setTimeout(() => {\n      this.connect(userId, wsUrl);\n    }, this.config.reconnectInterval);\n  }\n\n  // Disconnect from WebSocket\n  disconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n\n    this.isConnected = false;\n  }\n\n  // Handle incoming notification from WebSocket\n  private handleIncomingNotification(data: any) {\n    if (data.type === 'notification') {\n      const notification: StaffNotification = data.notification;\n      \n      // Add to local notification service\n      staffNotificationService.createNotification(notification);\n      \n      // Notify subscribers\n      this.notifySubscribers(notification);\n      \n      // Play sound if enabled\n      if (this.config.enableSoundNotifications) {\n        this.playNotificationSound();\n      }\n      \n      // Show browser notification\n      this.showBrowserNotification(notification);\n    }\n  }\n\n  // Subscribe to real-time notifications\n  subscribe(subscriber: NotificationSubscriber): () => void {\n    this.subscribers.set(subscriber.id, subscriber);\n    \n    // Return unsubscribe function\n    return () => {\n      this.subscribers.delete(subscriber.id);\n    };\n  }\n\n  // Notify all subscribers\n  private notifySubscribers(notification: StaffNotification) {\n    this.subscribers.forEach((subscriber) => {\n      if (this.shouldNotifySubscriber(subscriber, notification)) {\n        try {\n          subscriber.callback(notification);\n        } catch (error) {\n          console.error('Error in notification subscriber callback:', error);\n        }\n      }\n    });\n  }\n\n  // Check if subscriber should be notified based on filters\n  private shouldNotifySubscriber(subscriber: NotificationSubscriber, notification: StaffNotification): boolean {\n    const { filters } = subscriber;\n    \n    if (!filters) return true;\n    \n    if (filters.types && !filters.types.includes(notification.type)) {\n      return false;\n    }\n    \n    if (filters.priorities && !filters.priorities.includes(notification.priority)) {\n      return false;\n    }\n    \n    if (filters.staffIds && !filters.staffIds.includes(notification.staffId)) {\n      return false;\n    }\n    \n    return true;\n  }\n\n  // Play notification sound\n  private playNotificationSound() {\n    if (!this.audioContext || !this.notificationSound) return;\n    \n    try {\n      const source = this.audioContext.createBufferSource();\n      source.buffer = this.notificationSound;\n      source.connect(this.audioContext.destination);\n      source.start();\n    } catch (error) {\n      console.warn('Failed to play notification sound:', error);\n    }\n  }\n\n  // Show browser notification\n  private showBrowserNotification(notification: StaffNotification) {\n    if (!this.config.enablePushNotifications) return;\n    \n    if ('Notification' in window && Notification.permission === 'granted') {\n      const browserNotification = new Notification(notification.title, {\n        body: notification.message,\n        icon: '/placeholder.svg',\n        badge: '/placeholder.svg',\n        tag: notification.id,\n        requireInteraction: notification.priority === 'urgent',\n        silent: notification.priority === 'low',\n        data: {\n          notificationId: notification.id,\n          actionUrl: notification.actionUrl\n        }\n      });\n\n      // Auto-close after 5 seconds for non-urgent notifications\n      if (notification.priority !== 'urgent') {\n        setTimeout(() => {\n          browserNotification.close();\n        }, 5000);\n      }\n\n      // Handle click to navigate\n      browserNotification.onclick = () => {\n        window.focus();\n        if (notification.actionUrl) {\n          window.location.href = notification.actionUrl;\n        }\n        browserNotification.close();\n      };\n    }\n  }\n\n  // Request notification permission\n  async requestNotificationPermission(): Promise<boolean> {\n    if (!('Notification' in window)) {\n      console.warn('This browser does not support notifications');\n      return false;\n    }\n\n    if (Notification.permission === 'granted') {\n      return true;\n    }\n\n    if (Notification.permission !== 'denied') {\n      const permission = await Notification.requestPermission();\n      return permission === 'granted';\n    }\n\n    return false;\n  }\n\n  // Subscribe to push notifications\n  async subscribeToPushNotifications(userId: string): Promise<PushSubscription | null> {\n    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {\n      console.warn('Push notifications not supported');\n      return null;\n    }\n\n    try {\n      const registration = await navigator.serviceWorker.ready;\n      \n      const subscription = await registration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: this.urlBase64ToUint8Array(\n          'BEl62iUYgUivxIkv69yViEuiBIa40HI80NqIHSUHVInYiGAaFwxlQwD8NUhmuLLyBSt1-NjpJI5bDNrxUo5oOjw' // Replace with your VAPID public key\n        )\n      });\n\n      // Send subscription to server\n      await this.sendSubscriptionToServer(subscription, userId);\n      \n      return subscription;\n    } catch (error) {\n      console.error('Failed to subscribe to push notifications:', error);\n      return null;\n    }\n  }\n\n  // Convert VAPID key\n  private urlBase64ToUint8Array(base64String: string): Uint8Array {\n    const padding = '='.repeat((4 - base64String.length % 4) % 4);\n    const base64 = (base64String + padding)\n      .replace(/-/g, '+')\n      .replace(/_/g, '/');\n\n    const rawData = window.atob(base64);\n    const outputArray = new Uint8Array(rawData.length);\n\n    for (let i = 0; i < rawData.length; ++i) {\n      outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray;\n  }\n\n  // Send subscription to server\n  private async sendSubscriptionToServer(subscription: PushSubscription, userId: string) {\n    // In a real implementation, send this to your backend\n    console.log('Push subscription for user', userId, ':', subscription);\n    \n    // Store locally for demo purposes\n    localStorage.setItem(`pushSubscription_${userId}`, JSON.stringify(subscription));\n  }\n\n  // Send notification through WebSocket\n  sendNotification(notification: Omit<StaffNotification, 'id' | 'timestamp'>) {\n    if (this.ws && this.isConnected) {\n      this.ws.send(JSON.stringify({\n        type: 'send_notification',\n        notification,\n        timestamp: new Date().toISOString()\n      }));\n    }\n  }\n\n  // Update configuration\n  updateConfig(newConfig: Partial<RealTimeNotificationConfig>) {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  // Get connection status\n  getConnectionStatus() {\n    return {\n      isConnected: this.isConnected,\n      reconnectAttempts: this.reconnectAttempts,\n      hasWebSocketSupport: 'WebSocket' in window,\n      hasPushSupport: 'serviceWorker' in navigator && 'PushManager' in window,\n      hasNotificationSupport: 'Notification' in window,\n      notificationPermission: 'Notification' in window ? Notification.permission : 'unsupported'\n    };\n  }\n\n  // Simulate real-time notifications for demo\n  startSimulation(userId: string) {\n    const simulationTypes: StaffNotification['type'][] = [\n      'assignment', 'status_change', 'follow_up_due', 'proposal_request', 'urgent_query'\n    ];\n    \n    const priorities: StaffNotification['priority'][] = ['low', 'normal', 'high', 'urgent'];\n    \n    const messages = [\n      'New enquiry assigned to you',\n      'Client has responded to proposal',\n      'Follow-up reminder for pending enquiry',\n      'Urgent: Client requesting immediate response',\n      'Booking confirmation received',\n      'Payment reminder due',\n      'New message from client'\n    ];\n\n    setInterval(() => {\n      if (Math.random() > 0.7) { // 30% chance every 10 seconds\n        const notification: Omit<StaffNotification, 'id' | 'timestamp'> = {\n          staffId: userId,\n          queryId: `query_${Math.random().toString(36).substr(2, 9)}`,\n          type: simulationTypes[Math.floor(Math.random() * simulationTypes.length)],\n          title: 'New Activity',\n          message: messages[Math.floor(Math.random() * messages.length)],\n          read: false,\n          actionRequired: Math.random() > 0.5,\n          priority: priorities[Math.floor(Math.random() * priorities.length)],\n          actionUrl: `/queries/demo-${Date.now()}`\n        };\n\n        this.handleIncomingNotification({\n          type: 'notification',\n          notification: {\n            ...notification,\n            id: `sim_${Date.now()}`,\n            timestamp: new Date().toISOString()\n          }\n        });\n      }\n    }, 10000);\n  }\n}\n\nexport const realTimeNotificationService = new RealTimeNotificationService();","import { supabase } from '@/lib/supabaseClient';\nimport { getEnquiryById, assignEnquiry } from '@/services/enquiriesService';\nimport { StaffSequenceService } from '@/services/staffSequenceService';\nimport { getCountryByName, getStaffOperationalCountries } from '@/services/countryMappingService';\nimport { getRulesEnabledMap } from '@/services/assignmentRulesService';\n\n// Use a relaxed Supabase client type to avoid type overloads\nconst sb = supabase as any;\n\nexport type EligibleStaff = {\n  id: string; // Supabase UUID\n  name: string;\n  active: boolean;\n  sequenceOrder: number | null;\n  autoAssignEnabled: boolean;\n  operationalCountries: string[]; // country names\n  workloadCount: number; // active enquiries count for target country\n};\n\n// Utility: determine if staff operational countries include the enquiry's country name\nfunction hasCountryMatch(rawOperationalCountries: string[] | null | undefined, countryName: string): boolean {\n  const safe = Array.isArray(rawOperationalCountries) ? rawOperationalCountries : [];\n  if (safe.length === 0) return false;\n\n  // Try treating raw values as IDs and map to names\n  const mappedNamesFromIds = getStaffOperationalCountries(safe);\n  const target = getCountryByName(countryName)?.name || countryName;\n\n  if (mappedNamesFromIds.length > 0) {\n    return mappedNamesFromIds.some(n => n.toLowerCase() === target.toLowerCase());\n  }\n\n  // Fallback: treat raw values as names\n  return safe.some(n => n && n.toLowerCase() === target.toLowerCase());\n}\n\n// Count workload per staff for the given country (active enquiries)\nexport async function calculateWorkload(staffId: string, countryName?: string): Promise<number> {\n  try {\n    let q = sb\n      .from('enquiries')\n      .select('id,assigned_to,country_name,status', { count: 'exact', head: true })\n      .eq('assigned_to', staffId)\n      .eq('status', 'assigned');\n    if (countryName) q = q.eq('country_name', countryName);\n    const { count, error } = await q;\n    if (error) return 0;\n    return Number(count || 0);\n  } catch {\n    return 0;\n  }\n}\n\n// Fetch staff eligible by status + sequence + country match\nexport async function getEligibleStaff(countryName: string, enforceCountryFilter: boolean = true): Promise<EligibleStaff[]> {\n  try {\n    const { data: seqRows } = await StaffSequenceService.fetchSequence();\n    const sequenceActive = (seqRows || [])\n      .filter(r => r.auto_assign_enabled !== false)\n      .sort((a, b) => Number(a.sequence_order || 0) - Number(b.sequence_order || 0));\n    const seqById = new Map<string, { order: number | null; autoAssignEnabled: boolean }>();\n    (sequenceActive || []).forEach(r => {\n      seqById.set(String(r.staff_id), { order: Number(r.sequence_order || 0), autoAssignEnabled: r.auto_assign_enabled !== false });\n    });\n\n    const ids = Array.from(seqById.keys());\n    if (ids.length === 0) return [];\n\n    // Prefer public.staff for operational_countries\n    const { data: staffRows, error: staffErr } = await sb\n      .from('staff')\n      .select('id,name,status,operational_countries')\n      .in('id', ids);\n    if (staffErr) throw staffErr;\n\n    // Fallback to profiles when staff table is unavailable or incomplete\n    let rows = staffRows || [];\n    if (!rows || rows.length === 0) {\n      const { data: profilesRows } = await sb\n        .from('profiles')\n        .select('id,name,status,operational_countries')\n        .in('id', ids);\n      rows = profilesRows || [];\n    }\n\n    const eligible: EligibleStaff[] = [];\n    for (const r of rows) {\n      const uuid = String((r as any)?.id);\n      const name = String((r as any)?.name || 'Staff Member');\n      const active = String((r as any)?.status || 'active').toLowerCase() === 'active';\n      const rawOperational = Array.isArray((r as any)?.operational_countries) ? (r as any)?.operational_countries : [];\n\n      const seq = seqById.get(uuid);\n      const inSequence = !!seq && seq.autoAssignEnabled;\n      const countryOk = enforceCountryFilter ? hasCountryMatch(rawOperational, countryName) : true;\n      if (!active || !inSequence || !countryOk) continue;\n\n      const workloadCount = await calculateWorkload(uuid, enforceCountryFilter ? countryName : undefined);\n      const mappedOps = getStaffOperationalCountries(rawOperational);\n\n      eligible.push({\n        id: uuid,\n        name,\n        active,\n        sequenceOrder: seq?.order ?? null,\n        autoAssignEnabled: inSequence,\n        operationalCountries: mappedOps.length > 0 ? mappedOps : rawOperational,\n        workloadCount\n      });\n    }\n\n    // Order by sequence for deterministic behavior in nextRoundRobin\n    return eligible.sort((a, b) => (Number(a.sequenceOrder || 0) - Number(b.sequenceOrder || 0)));\n  } catch {\n    return [];\n  }\n}\n\n// AgentStaff Relationship check with eligibility\nasync function getAgentStaffRelation(agentId: string | null, countryName: string, eligibleIds: string[]): Promise<string | null> {\n  if (!agentId || eligibleIds.length === 0) return null;\n  try {\n    const { data, error } = await sb\n      .from('agent_staff_assignments')\n      .select('agent_id,staff_id')\n      .eq('agent_id', agentId)\n      .in('staff_id', eligibleIds)\n      .limit(1);\n    if (error) return null;\n    if (Array.isArray(data) && data.length > 0) {\n      const staffId = String((data[0] as any)?.staff_id);\n      return staffId || null;\n    }\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n// Sequence-only helpers (strict: only Staff Sequence with auto_assign_enabled = TRUE)\nasync function getStrictSequenceOrderedIds(): Promise<string[]> {\n  try {\n    const { data: seqRows } = await StaffSequenceService.fetchSequence();\n    const ordered = (seqRows || [])\n      .filter(r => r.auto_assign_enabled !== false)\n      .sort((a, b) => Number(a.sequence_order || 0) - Number(b.sequence_order || 0));\n    return ordered.map(r => String(r.staff_id));\n  } catch {\n    return [];\n  }\n}\n\n// Round Robin across strict sequence (ignores country/availability; respects sequence_order)\nasync function nextSequenceRoundRobin(allowedIds?: string[]): Promise<string | null> {\n  try {\n    const orderedIds = Array.isArray(allowedIds) && allowedIds.length > 0\n      ? allowedIds.map(String)\n      : await getStrictSequenceOrderedIds();\n    if (orderedIds.length === 0) return null;\n\n    const { data: recent } = await sb\n      .from('assignment_history')\n      .select('staff_id,assigned_at')\n      .in('staff_id', orderedIds)\n      .order('assigned_at', { ascending: false })\n      .limit(1);\n    const lastId = Array.isArray(recent) && recent.length > 0 ? String((recent[0] as any).staff_id) : null;\n\n    const total = orderedIds.length;\n    const startIndex = lastId ? Math.max(orderedIds.indexOf(lastId), 0) : -1;\n    for (let step = 1; step <= total; step++) {\n      const idx = ((startIndex + step) % total + total) % total;\n      const candidateId = orderedIds[idx];\n      if (candidateId) return candidateId;\n    }\n    return orderedIds[0] || null;\n  } catch {\n    return null;\n  }\n}\n\n// Round Robin: find next eligible by sequence after last used for this country\nexport async function nextRoundRobinStaff(countryName: string, allowedIds?: string[]): Promise<EligibleStaff | null> {\n  try {\n    let eligible = await getEligibleStaff(countryName);\n    if (Array.isArray(allowedIds) && allowedIds.length > 0) {\n      const allowSet = new Set(allowedIds.map(String));\n      eligible = eligible.filter(e => allowSet.has(e.id));\n    }\n    if (eligible.length === 0) return null;\n    const orderedIds = eligible.map(s => s.id);\n\n    // Find most recently assigned for these eligible ids\n    const { data: recent } = await sb\n      .from('assignment_history')\n      .select('staff_id,assigned_at')\n      .in('staff_id', orderedIds)\n      .order('assigned_at', { ascending: false })\n      .limit(1);\n    const lastId = Array.isArray(recent) && recent.length > 0 ? String((recent[0] as any).staff_id) : null;\n\n    const total = orderedIds.length;\n    const startIndex = lastId ? Math.max(orderedIds.indexOf(lastId), 0) : -1;\n    for (let step = 1; step <= total; step++) {\n      const idx = ((startIndex + step) % total + total) % total;\n      const candidateId = orderedIds[idx];\n      const candidate = eligible.find(e => e.id === candidateId);\n      if (candidate) return candidate;\n    }\n    // Fallback: first by sequence\n    return eligible[0] || null;\n  } catch {\n    return null;\n  }\n}\n\n// Main assignment function applying rule hierarchy\nexport async function assignQuery(enquiryBusinessId: string): Promise<void> {\n  // Fetch enquiry details (normalized Query)\n  const { data: enquiry } = await getEnquiryById(enquiryBusinessId);\n  if (!enquiry) return;\n\n  const countryName = String(enquiry.destination?.country || enquiry.country_name || '').trim();\n  // Read assignment rule toggles (default to enabled when unavailable)\n  const ruleStatus = await getRulesEnabledMap(['expertise-match', 'agent-staff-relationship', 'workload-balance', 'round-robin']);\n  const expertiseMatchEnabled = ruleStatus['expertise-match'] !== false;\n  const relationEnabled = ruleStatus['agent-staff-relationship'] !== false;\n  const workloadBalanceEnabled = ruleStatus['workload-balance'] !== false;\n  const roundRobinEnabled = ruleStatus['round-robin'] !== false;\n  // If no country provided OR expertise-match disabled, use strict sequence eligible pool\n  if (!countryName || !expertiseMatchEnabled) {\n    // With no country or expertise disabled, we rely on Staff Sequence and optional tie-breakers\n    // Try AgentStaff Relationship within sequence if enabled\n    const seqIds = await getStrictSequenceOrderedIds();\n    if (seqIds.length === 0) return;\n\n    const rawAgentId = enquiry.agentUuid ? String(enquiry.agentUuid) : (typeof enquiry.agentId === 'number' ? String(enquiry.agentId) : String(enquiry.agentId || ''));\n    const agentId = rawAgentId && rawAgentId.trim().length > 0 ? rawAgentId.trim() : null;\n\n    if (relationEnabled) {\n      const relStaffId = await getAgentStaffRelation(agentId, countryName, seqIds);\n      if (relStaffId) {\n        await assignEnquiry(enquiryBusinessId, relStaffId, 'system-auto', 'AgentStaff Relationship', true);\n        return;\n      }\n    }\n\n    // Workload Balance across all assignments (no country filter) if enabled\n    if (workloadBalanceEnabled) {\n      // Build eligible staff objects from sequence ids, preserving order\n      const eligibleNoCountry = await getEligibleStaff(countryName, false);\n      const byWorkload = [...eligibleNoCountry].sort((a, b) => a.workloadCount - b.workloadCount);\n      const minCount = byWorkload.length > 0 ? byWorkload[0].workloadCount : null;\n      const lowest = minCount !== null ? byWorkload.filter(s => s.workloadCount === minCount) : [];\n      if (lowest.length === 1) {\n        await assignEnquiry(enquiryBusinessId, lowest[0].id, 'system-auto', 'Workload Balance', true);\n        return;\n      }\n      if (lowest.length > 1) {\n        if (roundRobinEnabled) {\n          const rrTieId = await nextSequenceRoundRobin(lowest.map(s => s.id));\n          if (rrTieId) {\n            await assignEnquiry(enquiryBusinessId, rrTieId, 'system-auto', 'Round Robin (Tie-break)', true);\n            return;\n          }\n        } else {\n          // Sequence order tie-break when round-robin disabled\n          const nextSeqId = await nextSequenceRoundRobin(lowest.map(s => s.id));\n          if (nextSeqId) {\n            await assignEnquiry(enquiryBusinessId, nextSeqId, 'system-auto', 'Sequence Order (Tie-break)', true);\n            return;\n          }\n        }\n      }\n    }\n\n    // Final fallback: sequence round robin if enabled, else sequence order\n    if (roundRobinEnabled) {\n      const seqNext = await nextSequenceRoundRobin();\n      if (seqNext) {\n        await assignEnquiry(enquiryBusinessId, seqNext, 'system-auto', 'Round Robin (Sequence Only)', true);\n      }\n    } else {\n      const seqNext = await nextSequenceRoundRobin();\n      if (seqNext) {\n        await assignEnquiry(enquiryBusinessId, seqNext, 'system-auto', 'Sequence Order', true);\n      }\n    }\n    return;\n  }\n\n  // 1) Country Expertise (only when enabled)\n  const eligible = expertiseMatchEnabled ? await getEligibleStaff(countryName) : await getEligibleStaff(countryName, false);\n  // If no eligible by country, fall back to sequence-only round robin or sequence order based on RR toggle\n  if (eligible.length === 0) {\n    const seqNext = await nextSequenceRoundRobin();\n    if (seqNext) {\n      await assignEnquiry(enquiryBusinessId, seqNext, 'system-auto', roundRobinEnabled ? 'Round Robin (Sequence Only)' : 'Sequence Order', true);\n    }\n    return;\n  }\n\n  // Resolve agent id (prefer UUID string when present)\n  const rawAgentId = enquiry.agentUuid ? String(enquiry.agentUuid) : (typeof enquiry.agentId === 'number' ? String(enquiry.agentId) : String(enquiry.agentId || ''));\n  const agentId = rawAgentId && rawAgentId.trim().length > 0 ? rawAgentId.trim() : null;\n\n  // 2) AgentStaff Relationship (only when enabled)\n  if (relationEnabled) {\n    const relationStaffId = await getAgentStaffRelation(agentId, countryName, eligible.map(e => e.id));\n    if (relationStaffId) {\n      await assignEnquiry(enquiryBusinessId, relationStaffId, 'system-auto', 'AgentStaff Relationship', true);\n      return;\n    }\n  }\n\n  // 3) Workload Balance with Round Robin tie-breaker (only when enabled)\n  if (workloadBalanceEnabled) {\n    const byWorkload = [...eligible].sort((a, b) => a.workloadCount - b.workloadCount);\n    const minCount = byWorkload.length > 0 ? byWorkload[0].workloadCount : null;\n    const lowest = minCount !== null ? byWorkload.filter(s => s.workloadCount === minCount) : [];\n    if (lowest.length === 1) {\n      await assignEnquiry(enquiryBusinessId, lowest[0].id, 'system-auto', 'Workload Balance', true);\n      return;\n    }\n    if (lowest.length > 1) {\n      if (roundRobinEnabled) {\n        const rrTie = await nextRoundRobinStaff(countryName, lowest.map(s => s.id));\n        if (rrTie) {\n          await assignEnquiry(enquiryBusinessId, rrTie.id, 'system-auto', 'Round Robin (Tie-break)', true);\n          return;\n        }\n      } else {\n        const seqTieId = await nextSequenceRoundRobin(lowest.map(s => s.id));\n        if (seqTieId) {\n          await assignEnquiry(enquiryBusinessId, seqTieId, 'system-auto', 'Sequence Order (Tie-break)', true);\n          return;\n        }\n      }\n    }\n  }\n\n  // 4) Final fallback  Round Robin or strict sequence order\n  if (roundRobinEnabled) {\n    const rr = await nextRoundRobinStaff(countryName);\n    if (rr) {\n      await assignEnquiry(enquiryBusinessId, rr.id, 'system-auto', 'Round Robin', true);\n    }\n  } else {\n    const seqNext = await nextSequenceRoundRobin();\n    if (seqNext) {\n      await assignEnquiry(enquiryBusinessId, seqNext, 'system-auto', 'Sequence Order', true);\n    }\n  }\n}","import { supabase } from '@/lib/supabaseClient';\nimport { adminSupabase as supabaseAdmin } from '@/lib/supabaseClient';\nimport { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types';\n\nexport type CountryRow = Tables<'countries'>;\nexport type CountryInsert = TablesInsert<'countries'>;\nexport type CountryUpdate = TablesUpdate<'countries'>;\n\n// Reduce complex type inference by using a simple alias for augmented rows\nexport type CountryWithCityCount = CountryRow & { city_count: number };\n\n// Helper to avoid deep type instantiation when spreading complex Supabase row types\nconst toCountryWithCityCount = (country: CountryRow, cityCount: number): CountryWithCityCount => {\n  const base = country as unknown as {};\n  return { ...base, city_count: cityCount } as CountryWithCityCount;\n};\n\nexport interface CountryServiceResponse<T = any> {\n  data: T | null;\n  error: string | null;\n  success: boolean;\n}\n\nexport class CountriesService {\n  // Helper to perform a lightweight head count query without triggering deep generic instantiation\n  private static async fetchCitiesHeadCount(countryName: string): Promise<number> {\n    const res = await (supabase.from('cities') as any)\n      .select('*', { count: 'exact', head: true })\n      .eq('country', countryName) as { count: number | null };\n    return res.count ?? 0;\n  }\n  /**\n   * Fetch all countries from the database (User-facing version)\n   */\n  static async getAllCountries(): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabase\n        .from('countries')\n        .select('*')\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error('Error fetching countries:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error fetching countries:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Fetch all countries from the database (Admin version)\n   */\n  static async getAllCountriesAdmin(): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .select('*')\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error('Error fetching countries:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error fetching countries:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get a specific country by ID (User-facing version)\n   */\n  static async getCountryById(id: string): Promise<CountryServiceResponse<CountryRow>> {\n    try {\n      const { data, error } = await supabase\n        .from('countries')\n        .select('*')\n        .eq('id', id)\n        .single();\n\n      if (error) {\n        console.error('Error fetching country:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data,\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error fetching country:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Create a new country (User-facing version)\n   */\n  static async createCountry(country: CountryInsert): Promise<CountryServiceResponse<CountryRow>> {\n    try {\n      const { data, error } = await supabase\n        .from('countries')\n        .insert(country)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error creating country:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data,\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error creating country:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update a country (User-facing version)\n   */\n  static async updateCountry(id: string, updates: CountryUpdate): Promise<CountryServiceResponse<CountryRow>> {\n    try {\n      const { data, error } = await supabase\n        .from('countries')\n        .update(updates)\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error updating country:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data,\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error updating country:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Delete a country (User-facing version)\n   */\n  // CountriesService.deleteCountry ID\n  static async deleteCountry(id: string): Promise<CountryServiceResponse<void>> {\n    // ... existing code ...\n    //  ID \n    const { data: citiesUsingCountry, error: citiesError } = await supabase\n      .from('cities')\n      .select('id, name, countries!inner(id)')\n      .eq('countries.id', id)\n      .limit(1);\n  \n    if (citiesError) {\n      return { data: null, error: citiesError.message, success: false };\n    }\n  \n    if (citiesUsingCountry && citiesUsingCountry.length > 0) {\n      return {\n        data: null,\n        error: 'Cannot delete country as it is being used by one or more cities',\n        success: false,\n      };\n    }\n\n    const { error } = await supabase\n      .from('countries')\n      .delete()\n      .eq('id', id);\n\n    if (error) {\n      console.error('Error deleting country:', error);\n      return {\n        data: null,\n        error: error.message,\n        success: false\n      };\n    }\n\n    return {\n      data: null,\n      error: null,\n      success: true\n    };\n  }\n\n  /**\n   * Get countries by status\n   */\n  static async getCountriesByStatus(status: string): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .select('*')\n        .eq('status', status)\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error('Error fetching countries by status:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error fetching countries by status:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Search countries by name or code\n   */\n  static async searchCountries(query: string): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .select('*')\n        .or(`name.ilike.%${query}%,code.ilike.%${query}%`)\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error('Error searching countries:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error searching countries:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Bulk insert multiple countries\n   */\n  static async bulkInsertCountries(countries: CountryInsert[]): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .insert(countries)\n        .select();\n\n      if (error) {\n        console.error('Error bulk inserting countries:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error bulk inserting countries:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get countries by continent\n   */\n  static async getCountriesByContinent(continent: string): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .select('*')\n        .eq('continent', continent)\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error('Error fetching countries by continent:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error fetching countries by continent:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get countries by currency\n   */\n  static async getCountriesByCurrency(currency: string): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .select('*')\n        .eq('currency', currency)\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error('Error fetching countries by currency:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error fetching countries by currency:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Override pricing currency for a country\n   */\n  static async overridePricingCurrency(\n    countryId: string, \n    pricingCurrency: string, \n    pricingCurrencySymbol: string\n  ): Promise<CountryServiceResponse<CountryRow>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .update({\n          pricing_currency: pricingCurrency,\n          pricing_currency_symbol: pricingCurrencySymbol,\n          pricing_currency_override: true,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', countryId)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error overriding pricing currency:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data,\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error overriding pricing currency:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Remove pricing currency override for a country\n   */\n  static async removePricingCurrencyOverride(countryId: string): Promise<CountryServiceResponse<CountryRow>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .update({\n          pricing_currency: null,\n          pricing_currency_symbol: null,\n          pricing_currency_override: false,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', countryId)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error removing pricing currency override:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data,\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error removing pricing currency override:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Bulk override pricing currency for multiple countries\n   */\n  static async bulkOverridePricingCurrency(\n    countryIds: string[], \n    pricingCurrency: string, \n    pricingCurrencySymbol: string\n  ): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .update({\n          pricing_currency: pricingCurrency,\n          pricing_currency_symbol: pricingCurrencySymbol,\n          pricing_currency_override: true,\n          updated_at: new Date().toISOString()\n        })\n        .in('id', countryIds)\n        .select();\n\n      if (error) {\n        console.error('Error bulk overriding pricing currency:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error bulk overriding pricing currency:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get countries with pricing currency overrides\n   */\n  static async getCountriesWithPricingOverrides(): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .select('*')\n        .eq('pricing_currency_override', true)\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error('Error fetching countries with pricing overrides:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error fetching countries with pricing overrides:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Bulk delete multiple countries\n   */\n  static async bulkDeleteCountries(countryIds: string[]): Promise<CountryServiceResponse<void>> {\n    try {\n      if (!countryIds || countryIds.length === 0) {\n        return {\n          data: null,\n          error: 'No country IDs provided for deletion',\n          success: false\n        };\n      }\n\n      const { error } = await supabaseAdmin\n        .from('countries')\n        .delete()\n        .in('id', countryIds);\n\n      if (error) {\n        console.error('Error bulk deleting countries:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: null,\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error bulk deleting countries:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Bulk toggle status for multiple countries\n   */\n  static async bulkToggleStatus(countryIds: string[], newStatus: 'active' | 'inactive'): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      if (!countryIds || countryIds.length === 0) {\n        return {\n          data: null,\n          error: 'No country IDs provided for status toggle',\n          success: false\n        };\n      }\n\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .update({\n          status: newStatus,\n          updated_at: new Date().toISOString()\n        })\n        .in('id', countryIds)\n        .select();\n\n      if (error) {\n        console.error('Error bulk toggling country status:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error bulk toggling country status:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Bulk update multiple countries with the same data\n   */\n  static async bulkUpdateCountries(countryIds: string[], updates: Partial<CountryUpdate>): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      if (!countryIds || countryIds.length === 0) {\n        return {\n          data: null,\n          error: 'No country IDs provided for bulk update',\n          success: false\n        };\n      }\n\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .in('id', countryIds)\n        .select();\n\n      if (error) {\n        console.error('Error bulk updating countries:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error bulk updating countries:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Bulk upsert countries (insert new, update existing based on country code)\n   */\n  static async bulkUpsertCountries(countries: CountryInsert[]): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .upsert(countries, { \n          onConflict: 'code',\n          ignoreDuplicates: false \n        })\n        .select();\n\n      if (error) {\n        console.error('Error bulk upserting countries:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data: data || [],\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error bulk upserting countries:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update country by code (for import operations)\n   */\n  static async updateCountryByCode(code: string, updates: CountryUpdate): Promise<CountryServiceResponse<CountryRow>> {\n    try {\n      const { data, error } = await supabaseAdmin\n        .from('countries')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('code', code)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error updating country by code:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      return {\n        data,\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error updating country by code:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Bulk update countries by their codes\n   */\n  static async bulkUpdateCountriesByCode(updates: Array<{ code: string; data: CountryUpdate }>): Promise<CountryServiceResponse<CountryRow[]>> {\n    try {\n      const results: CountryRow[] = [];\n      const errors: string[] = [];\n\n      // Process updates in batches\n      for (const update of updates) {\n        try {\n          const result = await this.updateCountryByCode(update.code, update.data);\n          if (result.success && result.data) {\n            results.push(result.data);\n          } else {\n            errors.push(`Failed to update ${update.code}: ${result.error}`);\n          }\n        } catch (err) {\n          errors.push(`Error updating ${update.code}: ${err instanceof Error ? err.message : 'Unknown error'}`);\n        }\n      }\n\n      if (errors.length > 0 && results.length === 0) {\n        return {\n          data: null,\n          error: errors.join('; '),\n          success: false\n        };\n      }\n\n      return {\n        data: results,\n        error: errors.length > 0 ? `Partial success: ${errors.join('; ')}` : null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error bulk updating countries by code:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get countries with city count for better integration\n   */\n  static async getCountriesWithCityCount(): Promise<CountryServiceResponse<CountryWithCityCount[]>> {\n    try {\n      const { data, error } = await supabase\n        .from('countries')\n        .select('*')\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error('Error fetching countries with city count:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false\n        };\n      }\n\n      // Manually count cities for each country\n      const countriesData = (data || []) as CountryRow[];\n      const transformedData: CountryWithCityCount[] = await Promise.all(\n        countriesData.map(async (country) => {\n          // Extract name with light typing to avoid deep instantiation on CountryRow\n          const countryName: string = (country as any).name as string;\n          const count = await CountriesService.fetchCitiesHeadCount(countryName);\n          return toCountryWithCityCount(country, count);\n        })\n      );\n\n      return {\n        data: transformedData,\n        error: null,\n        success: true\n      };\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';\n      console.error('Unexpected error in getCountriesWithCityCount:', err);\n      return {\n        data: null,\n        error: errorMessage,\n        success: false\n      };\n    }\n  }\n}","import { CountryRow, CountryInsert } from './countriesService';\nimport { Country } from '@/pages/inventory/countries/types/country';\n\n/**\n * Maps a database country row to the frontend Country type\n */\nexport function mapDbCountryToFrontend(dbCountry: any): Country {\n  return {\n    id: String(dbCountry.id),\n    name: dbCountry.name,\n    code: dbCountry.code,\n    continent: dbCountry.continent || '',\n    region: dbCountry.region || '',\n    currency: dbCountry.currency,\n    currency_symbol: dbCountry.currency_symbol || '',\n    status: dbCountry.status as \"active\" | \"inactive\",\n    flag_url: dbCountry.flag_url || null,\n    is_popular: dbCountry.is_popular || false,\n    visa_required: dbCountry.visa_required || false,\n    languages: dbCountry.languages || [],\n    pricing_currency_override: dbCountry.pricing_currency_override || false,\n    pricing_currency: dbCountry.pricing_currency || null,\n    pricing_currency_symbol: dbCountry.pricing_currency_symbol || null,\n    created_at: dbCountry.created_at,\n    updated_at: dbCountry.updated_at,\n  };\n}\n\n/**\n * Maps a frontend Country to database insert format\n */\nexport function mapFrontendCountryToDbInsert(country: Omit<Country, 'id' | 'created_at' | 'updated_at'>): any {\n  return {\n    name: country.name,\n    code: country.code,\n    continent: country.continent,\n    region: country.region,\n    currency: country.currency,\n    currency_symbol: country.currency_symbol,\n    status: country.status,\n    flag_url: country.flag_url || null,\n    is_popular: country.is_popular,\n    visa_required: country.visa_required,\n    languages: country.languages,\n    pricing_currency_override: country.pricing_currency_override || false,\n    pricing_currency: country.pricing_currency || null,\n    pricing_currency_symbol: country.pricing_currency_symbol || null,\n  };\n}\n\n/**\n * Maps a frontend Country to database update format\n */\nexport function mapFrontendCountryToDbUpdate(country: Partial<Country>) {\n  const update: any = {};\n  \n  if (country.name !== undefined) update.name = country.name;\n  if (country.code !== undefined) update.code = country.code;\n  if (country.continent !== undefined) update.continent = country.continent;\n  if (country.region !== undefined) update.region = country.region;\n  if (country.currency !== undefined) update.currency = country.currency;\n  if (country.currency_symbol !== undefined) update.currency_symbol = country.currency_symbol;\n  if (country.status !== undefined) update.status = country.status;\n  if (country.flag_url !== undefined) update.flag_url = country.flag_url || null;\n  if (country.is_popular !== undefined) update.is_popular = country.is_popular;\n  if (country.visa_required !== undefined) update.visa_required = country.visa_required;\n  if (country.languages !== undefined) update.languages = country.languages;\n  if (country.pricing_currency_override !== undefined) update.pricing_currency_override = country.pricing_currency_override;\n  if (country.pricing_currency !== undefined) update.pricing_currency = country.pricing_currency || null;\n  if (country.pricing_currency_symbol !== undefined) update.pricing_currency_symbol = country.pricing_currency_symbol || null;\n  \n  return update;\n}\n\n/**\n * Maps multiple database countries to frontend format\n */\nexport function mapDbCountriesToFrontend(dbCountries: CountryRow[]): Country[] {\n  return dbCountries.map(mapDbCountryToFrontend);\n}","import { supabase, adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\nimport { StaffSequenceService } from '@/services/staffSequenceService';\nimport { createEnquiry, assignEnquiry } from '@/services/enquiriesService';\nimport { assignQuery } from '@/services/autoAssignmentEngine';\nimport { getCountryByName, getCountryByCode } from '@/services/countryMappingService';\nimport type { Query } from '@/types/query';\n\nconst sb: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\nfunction uuid(): string {\n  try {\n    const u = (globalThis as any)?.crypto?.randomUUID?.();\n    if (u) return u;\n  } catch {}\n  // Fallback UUID v4 generator\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function ensureStaff(name: string, operationalCountries: string[]): Promise<{ id: string; name: string }> {\n  // Profiles -> Staff sync is enforced by a DB trigger. Create/ensure a profile row for this staff.\n  const email = `${name.toLowerCase().replace(/\\s+/g, '.')}` + '@example.com';\n\n  // Try to find existing profile by email (stable unique key) or name\n  let profile: any = null;\n  {\n    const { data } = await sb\n      .from('profiles')\n      .select('id,name,email,role,status')\n      .eq('email', email)\n      .maybeSingle();\n    profile = data || null;\n  }\n  if (!profile) {\n    const { data } = await sb\n      .from('profiles')\n      .select('id,name,email,role,status')\n      .ilike('name', name)\n      .in('role', ['staff','manager','hr_manager'])\n      .limit(1)\n      .maybeSingle();\n    profile = data || null;\n  }\n\n  let id = profile?.id ? String(profile.id) : uuid();\n\n  if (!profile) {\n    const insertPayload = {\n      id,\n      name,\n      email,\n      role: 'staff',\n      status: 'active',\n      department: 'General'\n    } as any;\n    const { error: profErr } = await sb\n      .from('profiles')\n      .insert([insertPayload]);\n    if (profErr) throw profErr;\n  } else {\n    // Ensure role/status are correct for sync\n    const updates: any = {};\n    if (!profile.role || !['staff','manager','hr_manager'].includes(String(profile.role))) updates.role = 'staff';\n    if (profile.status !== 'active') updates.status = 'active';\n    if (Object.keys(updates).length > 0) {\n      await sb\n        .from('profiles')\n        .update(updates)\n        .eq('id', id);\n    }\n  }\n\n  // At this point, the DB trigger should have created/updated the staff row. Set operational countries.\n  await sb\n    .from('staff')\n    .update({ status: 'active', operational_countries: operationalCountries })\n    .eq('id', id);\n\n  // Read back staff name for return (fallback to provided name)\n  const { data: staffRow } = await sb\n    .from('staff')\n    .select('id,name')\n    .eq('id', id)\n    .maybeSingle();\n\n  return { id, name: String(staffRow?.name || name) };\n}\n\nasync function ensureAgent(name: string): Promise<{ id: string; name: string }> {\n  const { data: existing } = await sb\n    .from('agents')\n    .select('id,name,email')\n    .ilike('name', name)\n    .limit(1)\n    .maybeSingle();\n  if (existing?.id) return { id: String(existing.id), name: String(existing.name || name) };\n  const id = uuid();\n  const { data, error } = await sb\n    .from('agents')\n    .insert([{ id, name, email: `${name.toLowerCase().replace(/\\s+/g, '.')}@example.com` }])\n    .select()\n    .maybeSingle();\n  if (error) throw error;\n  return { id: String(data.id), name };\n}\n\nasync function ensureAgentStaffRelation(agentId: string, staffId: string): Promise<void> {\n  const { data: existing } = await sb\n    .from('agent_staff_assignments')\n    .select('agent_id,staff_id')\n    .eq('agent_id', agentId)\n    .eq('staff_id', staffId)\n    .limit(1);\n  if (Array.isArray(existing) && existing.length > 0) return;\n  await sb\n    .from('agent_staff_assignments')\n    .insert([{ agent_id: agentId, staff_id: staffId }]);\n}\n\nfunction buildQuery(id: string, countryName: string, agentUuid?: string): Query {\n  const country = getCountryByName(countryName);\n  const code = country?.code || getCountryByCode(countryName)?.code || (countryName.slice(0, 2).toUpperCase());\n  return {\n    id,\n    agentId: 0,\n    agentName: agentUuid ? 'Seed Agent' : '',\n    agentUuid,\n    agentCompany: '',\n    destination: { country: country?.name || countryName, cities: [] },\n    paxDetails: { adults: 2, children: 0, infants: 0 },\n    travelDates: { from: new Date().toISOString().slice(0, 10), to: new Date().toISOString().slice(0, 10), isEstimated: true },\n    tripDuration: { nights: 5, days: 6 },\n    packageType: 'full-package',\n    specialRequests: [],\n    budget: { min: 1000, max: 2000, currency: 'USD' },\n    status: 'new',\n    assignedTo: null,\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    priority: 'normal',\n    notes: '',\n    communicationPreference: 'email',\n    hotelDetails: { rooms: 1, category: 'standard' },\n    inclusions: { sightseeing: true, transfers: 'private', mealPlan: 'breakfast' },\n    cityAllocations: [],\n  };\n}\n\nexport async function seedAssignmentTestData(): Promise<{ logs: string[]; data: any }> {\n  const logs: string[] = [];\n  try {\n    // Prepare staff (operational countries use codes to validate robust mapping)\n    const alice = await ensureStaff('Alice', ['TH', 'AE']);\n    const bob = await ensureStaff('Bob', ['AE']);\n    const charlie = await ensureStaff('Charlie', ['TH']);\n    logs.push(`Staff ready: Alice=${alice.id}, Bob=${bob.id}, Charlie=${charlie.id}`);\n\n    // Ensure sequence order\n    await StaffSequenceService.upsertSequence([\n      { staff_id: alice.id, sequence_order: 1, auto_assign_enabled: true },\n      { staff_id: bob.id, sequence_order: 2, auto_assign_enabled: true },\n      { staff_id: charlie.id, sequence_order: 3, auto_assign_enabled: true },\n    ]);\n    logs.push('Staff sequence set: [Alice(1), Bob(2), Charlie(3)]');\n\n    // Prepare agent and link to Bob for AgentStaff relationship\n    const agent = await ensureAgent('Agent Zoe');\n    await ensureAgentStaffRelation(agent.id, bob.id);\n    logs.push(`Agent ready: Zoe=${agent.id}, linked to Bob`);\n\n    // Preload workload for Alice in Thailand to enable workload-balanced assignment to Charlie\n    const pre1Id = 'ENQ_TH_PRE_A';\n    await createEnquiry(buildQuery(pre1Id, 'Thailand'));\n    await assignEnquiry(pre1Id, alice.id, 'system-seed', 'Seed Preload', true);\n    logs.push('Preloaded Thailand workload: Alice +1');\n\n    // 1) AgentStaff Relationship: UAE enquiry from Agent Zoe -> expect Bob\n    const relId = 'ENQ_REL_UAE';\n    await createEnquiry(buildQuery(relId, 'United Arab Emirates', agent.id));\n    await assignQuery(relId);\n    logs.push('AgentStaff test created and auto-assigned');\n\n    // 2) Workload Balance: Thailand enquiry (Alice=1, Charlie=0) -> expect Charlie\n    const balanceId = 'ENQ_BALANCE_TH';\n    await createEnquiry(buildQuery(balanceId, 'Thailand'));\n    await assignQuery(balanceId);\n    logs.push('Workload-balance test created and auto-assigned');\n\n    // 3) Round Robin tie-break: Another Thailand enquiry (Alice=1, Charlie=1) -> next in RR\n    const rrId = 'ENQ_RR_TH_1';\n    await createEnquiry(buildQuery(rrId, 'Thailand'));\n    await assignQuery(rrId);\n    logs.push('Round-robin tie-break test created and auto-assigned');\n\n    // Optional: one more RR to show alternation\n    const rr2Id = 'ENQ_RR_TH_2';\n    await createEnquiry(buildQuery(rr2Id, 'Thailand'));\n    await assignQuery(rr2Id);\n    logs.push('Round-robin follow-up test created and auto-assigned');\n\n    return { logs, data: { staff: { alice, bob, charlie }, agent, enquiries: { relId, balanceId, rrId, rr2Id, pre1Id } } };\n  } catch (e: any) {\n    logs.push(`Seed error: ${e?.message || e}`);\n    return { logs, data: null };\n  }\n}","import { supabase } from '@/lib/supabaseClient';\n\ntype AIProvider = {\n  id: string;\n  provider_name: string;\n  api_key: string;\n  base_url: string;\n  status: 'active' | 'inactive' | string;\n  model_name?: string;\n  temperature?: number;\n  max_tokens?: number;\n  priority?: number;\n  usage_count?: number;\n  daily_limit?: number;\n};\n\nconst sb = supabase as any;\n\nfunction isGemini(api: AIProvider) {\n  const url = String(api?.base_url || '').toLowerCase();\n  const name = String(api?.provider_name || '').toLowerCase();\n  return url.includes('generativelanguage.googleapis.com') || name.includes('gemini');\n}\n\nfunction sortByDefaultPriority(providers: AIProvider[]): AIProvider[] {\n  const order = ['gemini', 'google gemini', 'openai', 'groq'];\n  return providers.slice().sort((a, b) => {\n    const ai = a.provider_name.toLowerCase();\n    const bi = b.provider_name.toLowerCase();\n    const aiIdx = order.findIndex(o => ai.includes(o));\n    const biIdx = order.findIndex(o => bi.includes(o));\n    const aScore = aiIdx === -1 ? Number.POSITIVE_INFINITY : aiIdx;\n    const bScore = biIdx === -1 ? Number.POSITIVE_INFINITY : biIdx;\n    return aScore - bScore;\n  });\n}\n\nexport async function getActiveProviders(): Promise<AIProvider[]> {\n  const { data, error } = await sb\n    .from('api_integrations')\n    .select('*')\n    .eq('status', 'active');\n  if (error) throw error;\n  const list = (data || []) as AIProvider[];\n  // Sort by explicit priority if present, otherwise fallback to default order\n  const byPriority = list.slice().sort((a, b) => (a.priority ?? 0) - (b.priority ?? 0));\n  return sortByDefaultPriority(byPriority);\n}\n\nexport type SmartPromptResult = {\n  provider: string;\n  model: string;\n  text?: string;\n  response_time_ms: number;\n};\n\n// Track per-session usage to optionally enforce a session limit per provider\nconst sessionUsageCounts: Record<string, number> = {};\n\nfunction timeoutSignal(timeoutMs: number): AbortSignal {\n  const controller = new AbortController();\n  setTimeout(() => controller.abort('timeout'), timeoutMs);\n  return controller.signal;\n}\n\nasync function tryProvider(prompt: string, api: AIProvider, timeoutMs = 8000): Promise<SmartPromptResult | null> {\n  const base = String(api.base_url || '').replace(/\\/$/, '');\n  const model = api.model_name || (isGemini(api) ? 'gemini-1.5-flash' : 'gpt-4o-mini');\n  const start = performance.now();\n  try {\n    let statusCode = 0;\n    let text: string | undefined;\n    if (isGemini(api)) {\n      const url = `${base}/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(api.api_key)}`;\n      const res = await fetch(url, {\n        method: 'POST',\n        signal: timeoutSignal(timeoutMs),\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          contents: [\n            {\n              role: 'user',\n              parts: [{ text: prompt }],\n            },\n          ],\n        }),\n      });\n      statusCode = res.status;\n      const json = await res.json().catch(() => ({}));\n      // Extract best-effort text from Gemini response\n      text = json?.candidates?.[0]?.content?.parts?.[0]?.text || json?.candidates?.[0]?.content?.parts?.[0]?.inline_data?.data;\n      const duration = Math.round(performance.now() - start);\n      await sb.from('api_usage_logs').insert({\n        provider_name: api.provider_name,\n        endpoint: 'generateContent',\n        status_code: statusCode,\n        response_time: duration,\n        response_time_ms: duration,\n        model_name: model,\n        prompt,\n        answer: text || '',\n      });\n      if (res.ok && typeof text === 'string') {\n        return { provider: api.provider_name, model, text, response_time_ms: duration };\n      }\n      return null;\n    } else {\n      const url = `${base}/v1/chat/completions`;\n      const res = await fetch(url, {\n        method: 'POST',\n        signal: timeoutSignal(timeoutMs),\n        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${api.api_key}` },\n        body: JSON.stringify({\n          model,\n          temperature: typeof api.temperature === 'number' ? api.temperature : 0.7,\n          messages: [\n            { role: 'system', content: 'You are an AI assistant integrated into our platform.' },\n            { role: 'user', content: prompt },\n          ],\n        }),\n      });\n      statusCode = res.status;\n      const json = await res.json().catch(() => ({}));\n      text = json?.choices?.[0]?.message?.content || json?.choices?.[0]?.text;\n      const duration = Math.round(performance.now() - start);\n      await sb.from('api_usage_logs').insert({\n        provider_name: api.provider_name,\n        endpoint: 'chat-completions',\n        status_code: statusCode,\n        response_time: duration,\n        response_time_ms: duration,\n        model_name: model,\n        prompt,\n        answer: text || '',\n      });\n      if (res.ok && typeof text === 'string') {\n        return { provider: api.provider_name, model, text, response_time_ms: duration };\n      }\n      return null;\n    }\n  } catch (err: any) {\n    const duration = Math.round(performance.now() - start);\n    // Log network/timeout error minimally\n    try {\n      await sb.from('api_usage_logs').insert({\n        provider_name: api.provider_name,\n        endpoint: 'smart-router',\n        status_code: err?.name === 'AbortError' || err?.message === 'timeout' ? 408 : 500,\n        response_time: duration,\n        response_time_ms: duration,\n        model_name: api.model_name || '',\n        prompt,\n        answer: '',\n      });\n    } catch {}\n    return null;\n  }\n}\n\nexport async function runSmartPrompt(\n  prompt: string,\n  options?: { timeoutMs?: number; maxRetriesPerProvider?: number; sessionProviderLimit?: number }\n): Promise<SmartPromptResult> {\n  const timeoutMs = options?.timeoutMs ?? 8000;\n  const maxRetries = Math.max(1, options?.maxRetriesPerProvider ?? 1);\n  const sessionLimit = options?.sessionProviderLimit;\n\n  const providers = await getActiveProviders();\n  if (!providers.length) {\n    throw new Error('No active AI providers configured.');\n  }\n\n  for (let i = 0; i < providers.length; i++) {\n    const p = providers[i];\n\n    const currentUsage = typeof p.usage_count === 'number' ? p.usage_count : 0;\n    const dailyLimit = typeof p.daily_limit === 'number' ? p.daily_limit : 50;\n    if (currentUsage >= dailyLimit) {\n      console.warn(` ${p.provider_name} daily limit reached, skipping...`);\n      try {\n        await sb.from('api_usage_logs').insert({\n          provider_name: p.provider_name,\n          endpoint: 'smart-router-skip',\n          status_code: 0,\n          response_time: 0,\n          response_time_ms: 0,\n          model_name: p.model_name || '',\n          prompt,\n          answer: '',\n          fallback_reason: 'daily_limit_reached',\n        });\n      } catch {}\n      continue;\n    }\n\n    if (typeof sessionLimit === 'number') {\n      const sessCount = sessionUsageCounts[p.id] || 0;\n      if (sessCount >= sessionLimit) {\n        console.warn(` ${p.provider_name} session limit reached, skipping...`);\n        try {\n          await sb.from('api_usage_logs').insert({\n            provider_name: p.provider_name,\n            endpoint: 'smart-router-skip',\n            status_code: 0,\n            response_time: 0,\n            response_time_ms: 0,\n            model_name: p.model_name || '',\n            prompt,\n            answer: '',\n            fallback_reason: 'session_limit_reached',\n          });\n        } catch {}\n        continue;\n      }\n    }\n\n    let attempt = 0;\n    while (attempt < maxRetries) {\n      const result = await tryProvider(prompt, p, timeoutMs);\n      if (result) {\n        // Increment usage_count only after successful call\n        try {\n          await sb\n            .from('api_integrations')\n            .update({ usage_count: currentUsage + 1, last_tested: new Date().toISOString() })\n            .eq('id', p.id);\n        } catch {}\n        if (typeof sessionLimit === 'number') {\n          sessionUsageCounts[p.id] = (sessionUsageCounts[p.id] || 0) + 1;\n        }\n        return result;\n      }\n      attempt++;\n      if (attempt < maxRetries) {\n        console.warn(`Retry ${attempt}/${maxRetries} failed for ${p.provider_name}`);\n      }\n    }\n\n    const next = providers[i + 1];\n    if (next) {\n      // Log fallback transition to next provider\n      try {\n        await sb.from('api_usage_logs').insert({\n          provider_name: p.provider_name,\n          endpoint: 'smart-router-fallback',\n          status_code: 0,\n          response_time: 0,\n          response_time_ms: 0,\n          model_name: p.model_name || '',\n          prompt,\n          answer: '',\n          fallback_reason: `${p.provider_name} failure  ${next.provider_name}`,\n        });\n      } catch {}\n    }\n  }\n  throw new Error('All AI providers failed. Please try again later.');\n}","import { CentralItinerary, ItineraryGenerationRequest, ItineraryDay, ItineraryActivity, ItineraryAccommodation, ItineraryTransport, ItineraryMeal, ItineraryLocation } from '@/types/itinerary';\nimport { Hotel } from '@/components/inventory/hotels/types/hotel';\nimport { Sightseeing } from '@/types/sightseeing';\nimport { Restaurant } from '@/pages/inventory/restaurants/types/restaurantTypes';\nimport { TransportRoute } from '@/pages/queries/types/proposalTypes';\nimport { v4 as uuidv4 } from 'uuid';\nimport { addDays, format } from 'date-fns';\n\nexport class ItineraryService {\n  private static hotels: Hotel[] = [];\n  private static sightseeing: Sightseeing[] = [];\n  private static restaurants: Restaurant[] = [];\n  private static transportRoutes: TransportRoute[] = [];\n\n  static setInventoryData(data: {\n    hotels: Hotel[];\n    sightseeing: Sightseeing[];\n    restaurants: Restaurant[];\n    transportRoutes: TransportRoute[];\n  }) {\n    this.hotels = data.hotels;\n    this.sightseeing = data.sightseeing;\n    this.restaurants = data.restaurants;\n    this.transportRoutes = data.transportRoutes;\n  }\n\n  static async generateItinerary(request: ItineraryGenerationRequest): Promise<CentralItinerary> {\n    const itinerary: CentralItinerary = {\n      id: uuidv4(),\n      title: `${request.destinations.join(', ')} Adventure`,\n      description: `AI-generated itinerary for ${request.travelers.adults} adults${request.travelers.children > 0 ? ` and ${request.travelers.children} children` : ''}`,\n      startDate: request.startDate,\n      endDate: request.endDate,\n      duration: this.calculateDuration(request.startDate, request.endDate),\n      destinations: this.generateDestinations(request.destinations),\n      preferences: {\n        budget: request.budget,\n        travelers: request.travelers,\n        interests: request.preferences.interests,\n        accommodationType: request.preferences.accommodationType,\n        transportPreference: request.preferences.transportPreference,\n        dietaryRestrictions: request.preferences.dietaryRestrictions,\n      },\n      days: [],\n      pricing: {\n        baseCost: 0,\n        markup: 0,\n        markupType: 'percentage',\n        finalPrice: 0,\n        currency: request.budget.currency,\n      },\n      status: 'generated',\n      context: request.context,\n      contextId: request.contextId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      createdBy: 'system',\n    };\n\n    // Generate daily itinerary\n    itinerary.days = await this.generateDailyItinerary(itinerary);\n    \n    // Calculate pricing\n    itinerary.pricing = this.calculatePricing(itinerary);\n\n    return itinerary;\n  }\n\n  private static calculateDuration(startDate: string, endDate: string) {\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    const days = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));\n    return {\n      days: days,\n      nights: days - 1,\n    };\n  }\n\n  private static generateDestinations(destinationNames: string[]): ItineraryLocation[] {\n    return destinationNames.map(name => ({\n      id: uuidv4(),\n      name,\n      country: name.includes(',') ? name.split(',')[1].trim() : 'Unknown',\n      city: name.includes(',') ? name.split(',')[0].trim() : name,\n    }));\n  }\n\n  private static async generateDailyItinerary(itinerary: CentralItinerary): Promise<ItineraryDay[]> {\n    const days: ItineraryDay[] = [];\n    const totalDays = itinerary.duration.days;\n    \n    for (let dayNum = 1; dayNum <= totalDays; dayNum++) {\n      const currentDate = addDays(new Date(itinerary.startDate), dayNum - 1);\n      const location = itinerary.destinations[Math.floor((dayNum - 1) / Math.max(1, totalDays / itinerary.destinations.length))];\n      \n      const day: ItineraryDay = {\n        id: uuidv4(),\n        day: dayNum,\n        date: format(currentDate, 'yyyy-MM-dd'),\n        location,\n        activities: this.generateActivities(location, dayNum, itinerary.preferences.interests),\n        meals: this.generateMeals(location),\n        totalCost: 0,\n      };\n\n      // Add accommodation (except last day)\n      if (dayNum < totalDays) {\n        day.accommodation = this.generateAccommodation(location, day.date, itinerary.preferences.accommodationType);\n      }\n\n      // Add transport (except first day)\n      if (dayNum > 1) {\n        const previousLocation = days[dayNum - 2].location;\n        if (previousLocation.city !== location.city) {\n          day.transport = [this.generateTransport(previousLocation, location)];\n        }\n      }\n\n      day.totalCost = this.calculateDayCost(day);\n      days.push(day);\n    }\n\n    return days;\n  }\n\n  private static generateActivities(location: ItineraryLocation, dayNum: number, interests: string[]): ItineraryActivity[] {\n    const activities: ItineraryActivity[] = [];\n    \n    // Filter sightseeing by location\n    const localSightseeing = this.sightseeing.filter(s => \n      s.city === location.city || s.country === location.country\n    );\n\n    // Generate 2-3 activities per day\n    const numActivities = Math.min(3, Math.max(2, localSightseeing.length));\n    \n    for (let i = 0; i < numActivities && i < localSightseeing.length; i++) {\n      const sight = localSightseeing[i];\n      const startHour = 9 + (i * 3); // Space activities 3 hours apart\n      \n      activities.push({\n        id: uuidv4(),\n        name: sight.name,\n        type: 'sightseeing',\n        location: {\n          id: uuidv4(),\n          name: sight.name,\n          country: sight.country,\n          city: sight.city,\n        },\n        startTime: `${startHour.toString().padStart(2, '0')}:00`,\n        endTime: `${(startHour + 2).toString().padStart(2, '0')}:00`,\n        duration: '2 hours',\n        price: this.getPrice(sight.price || 0),\n        description: sight.description,\n        inclusions: sight.policies?.inclusions || (sight.description ? [sight.description] : []),\n      });\n    }\n\n    return activities;\n  }\n\n  private static generateMeals(location: ItineraryLocation): ItineraryMeal[] {\n    const meals: ItineraryMeal[] = [];\n    \n    // Filter restaurants by location\n    const localRestaurants = this.restaurants.filter(r => \n      r.city === location.city || r.country === location.country\n    );\n\n    if (localRestaurants.length > 0) {\n      // Add lunch and dinner\n      const lunchRestaurant = localRestaurants[0];\n      const dinnerRestaurant = localRestaurants[Math.min(1, localRestaurants.length - 1)];\n\n      meals.push({\n        id: uuidv4(),\n        type: 'lunch',\n        restaurant: lunchRestaurant.name,\n        location: {\n          id: uuidv4(),\n          name: lunchRestaurant.name,\n          country: lunchRestaurant.country,\n          city: lunchRestaurant.city,\n        },\n        cuisine: lunchRestaurant.cuisine,\n        price: lunchRestaurant.averageCost || 30,\n        time: '12:30',\n      });\n\n      meals.push({\n        id: uuidv4(),\n        type: 'dinner',\n        restaurant: dinnerRestaurant.name,\n        location: {\n          id: uuidv4(),\n          name: dinnerRestaurant.name,\n          country: dinnerRestaurant.country,\n          city: dinnerRestaurant.city,\n        },\n        cuisine: dinnerRestaurant.cuisine,\n        price: dinnerRestaurant.averageCost || 50,\n        time: '19:00',\n      });\n    }\n\n    return meals;\n  }\n\n  private static generateAccommodation(location: ItineraryLocation, date: string, type: 'budget' | 'mid-range' | 'luxury'): ItineraryAccommodation {\n    // Filter hotels by location and type\n    const localHotels = this.hotels.filter(h => \n      h.city === location.city || h.country === location.country\n    );\n\n    let selectedHotel = localHotels[0];\n    if (selectedHotel) {\n      // Filter by accommodation type\n      if (type === 'luxury' && selectedHotel.starRating && selectedHotel.starRating >= 4) {\n        selectedHotel = localHotels.find(h => h.starRating && h.starRating >= 4) || selectedHotel;\n      } else if (type === 'mid-range' && selectedHotel.starRating && selectedHotel.starRating >= 3) {\n        selectedHotel = localHotels.find(h => h.starRating && h.starRating >= 3 && h.starRating < 4) || selectedHotel;\n      }\n    }\n\n    const defaultHotel = {\n      name: `${location.city} Hotel`,\n      starRating: type === 'luxury' ? 5 : type === 'mid-range' ? 3 : 2,\n      price: type === 'luxury' ? 300 : type === 'mid-range' ? 150 : 80,\n      amenities: ['WiFi', 'Breakfast', 'AC'],\n    };\n\n    const hotel = selectedHotel || defaultHotel;\n\n    return {\n      id: uuidv4(),\n      name: hotel.name,\n      type: 'hotel',\n      location,\n      checkIn: date,\n      checkOut: format(addDays(new Date(date), 1), 'yyyy-MM-dd'),\n      nights: 1,\n      roomType: 'Deluxe Room',\n      price: hotel.price || defaultHotel.price,\n      starRating: hotel.starRating,\n      amenities: (selectedHotel && 'amenities' in selectedHotel) ? selectedHotel.amenities : defaultHotel.amenities,\n    };\n  }\n\n  private static generateTransport(from: ItineraryLocation, to: ItineraryLocation): ItineraryTransport {\n    // Find transport route\n    const route = this.transportRoutes.find(r => \n      (r.from === from.city && r.to === to.city) ||\n      (r.from === from.country && r.to === to.country)\n    );\n\n    return {\n      id: uuidv4(),\n      type: route?.transportType === 'flight' ? 'flight' : 'car',\n      from,\n      to,\n      duration: route?.duration || '2 hours',\n      price: route?.price || 100,\n      details: route?.name || `${from.city} to ${to.city}`,\n    };\n  }\n\n  private static calculateDayCost(day: ItineraryDay): number {\n    let total = 0;\n    \n    // Activities cost\n    total += day.activities.reduce((sum, activity) => sum + activity.price, 0);\n    \n    // Meals cost\n    total += day.meals.reduce((sum, meal) => sum + meal.price, 0);\n    \n    // Accommodation cost\n    if (day.accommodation) {\n      total += day.accommodation.price;\n    }\n    \n    // Transport cost\n    if (day.transport) {\n      total += day.transport.reduce((sum, transport) => sum + transport.price, 0);\n    }\n    \n    return total;\n  }\n\n  private static calculatePricing(itinerary: CentralItinerary) {\n    const baseCost = itinerary.days.reduce((sum, day) => sum + day.totalCost, 0);\n    const markup = baseCost * 0.15; // 15% default markup\n    \n    return {\n      baseCost,\n      markup,\n      markupType: 'percentage' as const,\n      finalPrice: baseCost + markup,\n      currency: itinerary.preferences.budget.currency,\n    };\n  }\n\n  private static getPrice(price: number | { adult: number; child: number; }): number {\n    if (typeof price === 'number') {\n      return price;\n    } else if (price && typeof price === 'object' && 'adult' in price) {\n      return price.adult;\n    }\n    return 0;\n  }\n}\n","import { supabase } from '@/lib/supabaseClient';\nimport { adminSupabase as supabaseAdmin } from '@/lib/supabaseClient';\nimport { CountriesService } from './countriesService';\n\n// Type definitions for our custom RPC functions\ninterface DeleteCityRpcResult {\n  success: boolean;\n  warning?: string;\n  error?: string;\n}\n\ninterface DeleteCitiesBulkRpcResult {\n  success: boolean;\n  message?: string;\n  error?: string;\n}\n\n// City types based on the actual public.cities table structure\nexport interface CityRow {\n  id: string;\n  name: string;\n  region: string;\n  has_airport: boolean;\n  is_popular: boolean;\n  status: 'active' | 'disabled';\n  created_at: string;\n  updated_at: string;\n  country: string; // Foreign key to countries table\n}\n\nexport interface CityInsert {\n  name: string;\n  region: string;\n  has_airport?: boolean;\n  is_popular?: boolean;\n  status?: 'active' | 'disabled';\n  country: string; // Foreign key to countries table\n}\n\nexport interface CityUpdate {\n  name?: string;\n  region?: string;\n  has_airport?: boolean;\n  is_popular?: boolean;\n  status?: 'active' | 'disabled';\n  country?: string; // Foreign key to countries table\n}\n\nexport interface CityServiceResponse<T = any> {\n  data: T | null;\n  error: string | null;\n  success: boolean;\n}\n\nexport class CitiesService {\n  /**\n   * Get all cities with optional filtering and pagination\n   * Connects to remote Supabase public.cities table\n   */\n  static async getAllCities(\n    page: number = 1,\n    limit: number = 50,\n    search?: string,\n    status?: string,\n    country?: string\n  ): Promise<CityServiceResponse<{ cities: CityRow[]; total: number }>> {\n    try {\n      console.log(' Fetching cities from remote Supabase...', { page, limit, search, status, country });\n\n      let query = supabase\n        .from('cities')\n        .select(`\n          *,\n          countries!inner(name, status)\n        `, { count: 'exact' });\n\n      // Apply filters\n      if (search) {\n        query = query.or(`name.ilike.%${search}%,region.ilike.%${search}%,continent.ilike.%${search}%`);\n      }\n\n      if (status) {\n        query = query.eq('status', status);\n      }\n\n      if (country) {\n        query = query.eq('countries.name', country);\n      }\n\n      // Apply pagination\n      const from = (page - 1) * limit;\n      const to = from + limit - 1;\n      query = query.range(from, to);\n\n      // Order by name\n      query = query.order('name', { ascending: true });\n\n      const { data, error, count } = await query;\n\n      if (error) {\n        console.error(' Error fetching cities:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Transform data to include country name and derive effective status from parent country\n      const transformedData = data?.map(city => ({\n        ...city,\n        country: city.countries?.name || 'Unknown',\n        status: (city.status === 'active' && (city.countries?.status === 'active')) ? 'active' : 'disabled'\n      })) || [];\n\n      console.log(' Successfully fetched cities:', transformedData.length);\n\n      return {\n        data: {\n          cities: transformedData,\n          total: count || 0,\n        },\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in getAllCities:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Get all cities for admin (no filtering by status)\n   */\n  static async getAllCitiesAdmin(): Promise<CityServiceResponse<CityRow[]>> {\n    try {\n      console.log(' Fetching all cities for admin...');\n\n      const { data, error } = await supabase\n        .from('cities')\n        .select(`\n          *,\n          countries!inner(name, status)\n        `)\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error(' Error fetching cities for admin:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Transform data to include country name and derive effective status from parent country\n      const transformedData = data?.map(city => ({\n        ...city,\n        country: city.countries?.name || 'Unknown',\n        status: (city.status === 'active' && (city.countries?.status === 'active')) ? 'active' : 'disabled'\n      })) || [];\n\n      console.log(' Successfully fetched admin cities:', transformedData.length);\n\n      return {\n        data: transformedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in getAllCitiesAdmin:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Get a city by ID\n   */\n  static async getCityById(id: string): Promise<CityServiceResponse<CityRow>> {\n    try {\n      console.log(' Fetching city by ID:', id);\n\n      const { data, error } = await supabase\n        .from('cities')\n        .select(`\n          *,\n          countries!inner(name)\n        `)\n        .eq('id', id)\n        .single();\n\n      if (error) {\n        console.error(' Error fetching city by ID:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Transform data to include country name and fix types\n      const transformedData = {\n        ...data,\n        country: data.countries?.name || 'Unknown',\n        status: data.status as 'active' | 'disabled'\n      };\n\n      console.log(' Successfully fetched city:', transformedData.name);\n\n      return {\n        data: transformedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in getCityById:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Create a new city\n   */\n  static async createCity(cityData: CityInsert): Promise<CityServiceResponse<CityRow>> {\n    try {\n      console.log(' Creating new city:', cityData);\n\n      // Validate required fields\n      if (!cityData.name || !cityData.country) {\n        return {\n          data: null,\n          error: 'Name and country are required fields',\n          success: false,\n        };\n      }\n\n      // Resolve country_id from provided country name\n      const { data: countryMatch, error: countryLookupError } = await supabase\n        .from('countries')\n        .select('id, name')\n        .eq('name', cityData.country)\n        .limit(1)\n        .single();\n\n      if (countryLookupError || !countryMatch?.id) {\n        console.error(' Invalid country provided for city creation:', countryLookupError?.message);\n        return {\n          data: null,\n          error: 'Invalid country. Please select a valid active country',\n          success: false,\n        };\n      }\n\n      const countryId = countryMatch.id;\n\n      const { data, error } = await supabase\n        .from('cities')\n        .insert([{\n          name: cityData.name,\n          region: cityData.region || '',\n          has_airport: cityData.has_airport || false,\n          is_popular: cityData.is_popular || false,\n          status: cityData.status || 'active',\n          country_id: countryId,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        }])\n        .select()\n        .single();\n\n      if (error) {\n        console.error(' Error creating city:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      console.log(' Successfully created city:', data);\n\n      // Type cast the status field to match CityRow interface\n      const typedData = {\n        ...data,\n        status: data.status as 'active' | 'disabled'\n      };\n\n      return {\n        data: typedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in createCity:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Update an existing city\n   * Uses admin client to bypass replica identity issues\n   */\n  static async updateCity(id: string, cityData: CityUpdate): Promise<CityServiceResponse<CityRow>> {\n    try {\n      console.log(' Updating city:', id, cityData);\n\n      // First, get the current city data to ensure it exists\n      const { data: existingCity, error: fetchError } = await supabase\n        .from('cities')\n        .select('*')\n        .eq('id', id)\n        .single();\n\n      if (fetchError || !existingCity) {\n        console.error(' City not found:', fetchError?.message);\n        return {\n          data: null,\n          error: 'City not found',\n          success: false,\n        };\n      }\n\n      // Build update object with only provided fields\n      const updateData: any = {\n        updated_at: new Date().toISOString()\n      };\n\n      if (cityData.name !== undefined) updateData.name = cityData.name;\n      if (cityData.region !== undefined) updateData.region = cityData.region;\n      if (cityData.has_airport !== undefined) updateData.has_airport = cityData.has_airport;\n      if (cityData.is_popular !== undefined) updateData.is_popular = cityData.is_popular;\n      if (cityData.status !== undefined) updateData.status = cityData.status;\n      if (cityData.country !== undefined) {\n        // Map provided country name to country_id\n        const { data: countryMatch, error: countryLookupError } = await supabase\n          .from('countries')\n          .select('id, name')\n          .eq('name', cityData.country)\n          .limit(1)\n          .single();\n\n        if (countryLookupError || !countryMatch?.id) {\n          console.error(' Invalid country provided for city update:', countryLookupError?.message);\n          return {\n            data: null,\n            error: 'Invalid country. Please select a valid active country',\n            success: false,\n          };\n        }\n        updateData.country_id = countryMatch.id;\n      }\n\n      // Use admin client to bypass replica identity issues\n      const { data, error } = await supabaseAdmin\n        .from('cities')\n        .update(updateData)\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (error) {\n        console.error(' Error updating city with admin client:', error);\n        \n        // Fallback: Try using upsert approach\n        try {\n          console.log(' Trying upsert fallback...');\n          const mergedData = { ...existingCity, ...updateData, id };\n          \n          const { data: upsertData, error: upsertError } = await supabaseAdmin\n            .from('cities')\n            .upsert(mergedData, { onConflict: 'id' })\n            .select()\n            .single();\n\n          if (upsertError) {\n            console.error(' Upsert fallback failed:', upsertError);\n            return {\n              data: null,\n              error: `Update failed: ${error.message}. Upsert fallback also failed: ${upsertError.message}`,\n              success: false,\n            };\n          }\n\n          console.log(' Successfully updated city via upsert fallback:', upsertData.name);\n          \n          // Type cast the status field to match CityRow interface\n          const typedData = {\n            ...upsertData,\n            status: upsertData.status as 'active' | 'disabled'\n          };\n\n          return {\n            data: typedData,\n            error: null,\n            success: true,\n          };\n        } catch (fallbackError) {\n          console.error(' Fallback upsert error:', fallbackError);\n          return {\n            data: null,\n            error: `Update failed: ${error.message}`,\n            success: false,\n          };\n        }\n      }\n\n      console.log(' Successfully updated city:', data.name);\n\n      // Type cast the status field to match CityRow interface\n      const typedData = {\n        ...data,\n        status: data.status as 'active' | 'disabled'\n      };\n\n      return {\n        data: typedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in updateCity:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Delete a city\n   * Uses multiple approaches to handle replica identity issues\n   */\n  static async deleteCity(id: string): Promise<CityServiceResponse<void>> {\n    try {\n      console.log(' Deleting city:', id);\n\n      // First check if city exists and get its details\n      const { data: existingCity, error: checkError } = await supabase\n        .from('cities')\n        .select('id, name')\n        .eq('id', id)\n        .single();\n\n      if (checkError || !existingCity) {\n        console.error(' City not found:', checkError?.message);\n        return {\n          data: null,\n          error: 'City not found',\n          success: false,\n        };\n      }\n\n      console.log(` Found city to delete: ${existingCity.name} (ID: ${id})`);\n\n      // Method 1: Try direct delete with admin client\n      const { error: deleteError } = await supabaseAdmin\n        .from('cities')\n        .delete()\n        .eq('id', id);\n\n      if (!deleteError) {\n        console.log(' Successfully deleted city via direct delete:', existingCity.name);\n        return {\n          data: null,\n          error: null,\n          success: true,\n        };\n      }\n\n      console.error(' Direct delete failed:', deleteError.message);\n\n      // Method 2: Try soft delete by updating status to 'deleted'\n      console.log(' Trying soft delete approach...');\n      const { data: softDeleteData, error: softDeleteError } = await supabaseAdmin\n        .from('cities')\n        .update({ \n          status: 'disabled',\n          name: `[DELETED] ${existingCity.name}`,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (!softDeleteError) {\n        console.log(' Successfully soft-deleted city:', existingCity.name);\n        return {\n          data: null,\n          error: null,\n          success: true,\n        };\n      }\n\n      console.error(' Soft delete failed:', softDeleteError.message);\n\n      // Method 3: Try using RPC function if available\n      console.log(' Trying RPC delete approach...');\n      try {\n        const { data: rpcResult, error: rpcError } = await (supabaseAdmin as any).rpc('delete_city_by_id', { \n          city_id: id \n        }) as { data: DeleteCityRpcResult | null; error: any };\n\n        if (!rpcError && rpcResult) {\n          if (rpcResult.success) {\n            console.log(' Successfully deleted city via RPC:', existingCity.name);\n            if (rpcResult.warning) {\n              console.log(' RPC Warning:', rpcResult.warning);\n            }\n            return {\n              data: null,\n              error: null,\n              success: true,\n            };\n          } else {\n            console.error(' RPC delete failed:', rpcResult.error);\n          }\n        } else if (rpcError) {\n          console.error(' RPC call failed:', rpcError.message);\n        }\n      } catch (rpcError) {\n        console.log(' RPC function not available, skipping...');\n      }\n\n      // Method 4: Final fallback - mark as deleted in a way that hides it from queries\n      console.log(' Trying final fallback - marking as hidden...');\n      const { error: hideError } = await supabaseAdmin\n        .from('cities')\n        .update({ \n          status: 'disabled',\n          name: `[HIDDEN-${Date.now()}] ${existingCity.name}`,\n          region: '[DELETED]',\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n\n      if (!hideError) {\n        console.log(' Successfully marked city as hidden (fallback delete):', existingCity.name);\n        return {\n          data: null,\n          error: null,\n          success: true,\n        };\n      }\n\n      // If all methods fail, return the original error\n      console.error(' All delete methods failed');\n      return {\n        data: null,\n        error: `Delete failed: ${deleteError.message}. This may be due to database replica identity settings. The city has been marked as disabled instead.`,\n        success: false,\n      };\n\n    } catch (error) {\n      console.error(' Unexpected error in deleteCity:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Search cities by name, region, or continent\n   */\n  static async searchCities(searchTerm: string): Promise<CityServiceResponse<CityRow[]>> {\n    try {\n      console.log(' Searching cities:', searchTerm);\n\n      const { data, error } = await supabase\n        .from('cities')\n        .select(`\n          *,\n          countries!inner(name, status)\n        `)\n        .or(`name.ilike.%${searchTerm}%,region.ilike.%${searchTerm}%,continent.ilike.%${searchTerm}%`)\n        .eq('status', 'active')\n        .eq('countries.status', 'active')\n        .order('name', { ascending: true })\n        .limit(50);\n\n      if (error) {\n        console.error(' Error searching cities:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Transform data to include country name and derive effective status from parent country\n      const transformedData = data?.map(city => ({\n        ...city,\n        country: city.countries?.name || 'Unknown',\n        status: (city.status === 'active' && (city.countries?.status === 'active')) ? 'active' : 'disabled'\n      })) || [];\n\n      console.log(' Successfully searched cities:', transformedData.length);\n\n      return {\n        data: transformedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in searchCities:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Get cities by country ID\n   */\n  static async getCitiesByCountryId(countryId: string): Promise<CityServiceResponse<CityRow[]>> {\n    try {\n      console.log(' Fetching cities by country ID:', countryId);\n\n      const { data, error } = await supabase\n        .from('cities')\n        .select('id, name, region, has_airport, is_popular, status, created_at, updated_at, countries!inner(id, name, status)')\n        .eq('countries.id', countryId)\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error(' Error fetching cities by country ID:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Transform data to include country name and derive effective status from parent country\n      const transformedData = data?.map(city => ({\n        ...city,\n        country: city.countries?.name || 'Unknown',\n        status: (city.status === 'active' && (city.countries?.status === 'active')) ? 'active' : 'disabled'\n      })) || [];\n\n      console.log(' Successfully fetched cities by country ID:', transformedData.length);\n\n      return {\n        data: transformedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in getCitiesByCountryId:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Bulk delete cities\n   * Uses multiple approaches to handle replica identity issues\n   */\n  static async bulkDeleteCities(ids: string[]): Promise<CityServiceResponse<void>> {\n    try {\n      console.log(' Bulk deleting cities:', ids.length);\n\n      if (ids.length === 0) {\n        return {\n          data: null,\n          error: 'No cities to delete',\n          success: false,\n        };\n      }\n\n      // First, get the cities to be deleted for logging\n      const { data: citiesToDelete, error: fetchError } = await supabase\n        .from('cities')\n        .select('id, name')\n        .in('id', ids);\n\n      if (fetchError) {\n        console.error(' Error fetching cities to delete:', fetchError.message);\n      }\n\n      // Method 1: Try direct bulk delete with admin client\n      const { error: deleteError } = await supabaseAdmin\n        .from('cities')\n        .delete()\n        .in('id', ids);\n\n      if (!deleteError) {\n        console.log(' Successfully bulk deleted cities via direct delete');\n        return {\n          data: null,\n          error: null,\n          success: true,\n        };\n      }\n\n      console.error(' Bulk direct delete failed:', deleteError.message);\n\n      // Method 2: Try bulk soft delete by updating status\n      console.log(' Trying bulk soft delete approach...');\n      const { error: softDeleteError } = await supabaseAdmin\n        .from('cities')\n        .update({ \n          status: 'disabled',\n          updated_at: new Date().toISOString()\n        })\n        .in('id', ids);\n\n      if (!softDeleteError) {\n        console.log(' Successfully bulk soft-deleted cities');\n        return {\n          data: null,\n          error: null,\n          success: true,\n        };\n      }\n\n      console.error(' Bulk soft delete failed:', softDeleteError.message);\n\n      // Method 3: Try RPC bulk delete function if available\n      console.log(' Trying RPC bulk delete approach...');\n      try {\n        const { data: rpcResult, error: rpcError } = await (supabaseAdmin as any).rpc('delete_cities_bulk', { \n          city_ids: ids \n        }) as { data: DeleteCitiesBulkRpcResult | null; error: any };\n\n        if (!rpcError && rpcResult) {\n          if (rpcResult.success) {\n            console.log(' Successfully bulk deleted cities via RPC:', rpcResult.message);\n            return {\n              data: null,\n              error: null,\n              success: true,\n            };\n          } else {\n            console.error(' RPC bulk delete failed:', rpcResult.message);\n          }\n        } else if (rpcError) {\n          console.error(' RPC bulk call failed:', rpcError.message);\n        }\n      } catch (rpcError) {\n        console.log(' RPC bulk function not available, skipping...');\n      }\n\n      // Method 4: Fallback to individual deletes\n      console.log(' Trying individual delete fallback...');\n      let successCount = 0;\n      let failureCount = 0;\n      const errors: string[] = [];\n\n      for (const id of ids) {\n        const result = await this.deleteCity(id);\n        if (result.success) {\n          successCount++;\n        } else {\n          failureCount++;\n          if (result.error) {\n            errors.push(`ID ${id}: ${result.error}`);\n          }\n        }\n      }\n\n      if (successCount > 0) {\n        const message = failureCount > 0 \n          ? `Partially successful: ${successCount} deleted, ${failureCount} failed`\n          : `Successfully deleted all ${successCount} cities`;\n        \n        console.log(` ${message}`);\n        \n        return {\n          data: null,\n          error: failureCount > 0 ? `Some deletions failed: ${errors.join('; ')}` : null,\n          success: true,\n        };\n      }\n\n      // If all methods fail\n      console.error(' All bulk delete methods failed');\n      return {\n        data: null,\n        error: `Bulk delete failed: ${deleteError.message}. Individual deletes also failed.`,\n        success: false,\n      };\n\n    } catch (error) {\n      console.error(' Unexpected error in bulkDeleteCities:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Bulk update cities\n   */\n  static async bulkUpdateCities(updates: Array<{ id: string; data: CityUpdate }>): Promise<CityServiceResponse<CityRow[]>> {\n    try {\n      console.log(' Bulk updating cities:', updates.length);\n\n      const results: CityRow[] = [];\n      const errors: string[] = [];\n\n      // Process updates sequentially to handle potential errors\n      for (const update of updates) {\n        const result = await this.updateCity(update.id, update.data);\n        if (result.success && result.data) {\n          results.push(result.data);\n        } else if (result.error) {\n          errors.push(`City ${update.id}: ${result.error}`);\n        }\n      }\n\n      if (errors.length > 0) {\n        console.error(' Some bulk updates failed:', errors);\n        return {\n          data: null,\n          error: `Some updates failed: ${errors.join(', ')}`,\n          success: false,\n        };\n      }\n\n      console.log(' Successfully bulk updated cities:', results.length);\n\n      return {\n        data: results,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in bulkUpdateCities:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Bulk toggle status of cities\n   */\n  static async bulkToggleStatus(cityIds: string[], newStatus: 'active' | 'disabled'): Promise<CityServiceResponse<CityRow[]>> {\n    try {\n      console.log(' Bulk toggling city status:', cityIds.length, 'to', newStatus);\n\n      const { data, error } = await supabase\n        .from('cities')\n        .update({ \n          status: newStatus,\n          updated_at: new Date().toISOString(),\n        })\n        .in('id', cityIds)\n        .select(`\n          *,\n          countries!inner(name)\n        `);\n\n      if (error) {\n        console.error(' Error bulk toggling status:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Transform data to include country name and fix types\n      const transformedData = data?.map(city => ({\n        ...city,\n        country: city.countries?.name || 'Unknown',\n        status: city.status as 'active' | 'disabled'\n      })) || [];\n\n      console.log(' Successfully bulk toggled status:', transformedData.length);\n\n      return {\n        data: transformedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in bulkToggleStatus:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Bulk upsert cities (insert or update)\n   */\n  static async bulkUpsertCities(cities: CityInsert[]): Promise<CityServiceResponse<CityRow[]>> {\n    try {\n      console.log(' Bulk upserting cities:', cities.length);\n\n      const { data, error } = await supabase\n        .from('cities')\n        .upsert(cities.map(city => ({\n          ...city,\n          status: city.status || 'active',\n          is_popular: city.is_popular || false,\n          has_airport: city.has_airport || false,\n        })))\n        .select(`\n          *,\n          countries!inner(name)\n        `);\n\n      if (error) {\n        console.error(' Error bulk upserting cities:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Transform data to include country name and fix types\n      const transformedData = data?.map(city => ({\n        ...city,\n        country: city.countries?.name || 'Unknown',\n        status: city.status as 'active' | 'disabled'\n      })) || [];\n\n      console.log(' Successfully bulk upserted cities:', transformedData.length);\n\n      return {\n        data: transformedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in bulkUpsertCities:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Get active cities only\n   */\n  static async getActiveCities(): Promise<CityServiceResponse<CityRow[]>> {\n    try {\n      console.log(' Fetching active cities...');\n\n      const { data, error } = await supabase\n        .from('cities')\n        .select(`\n          *,\n          countries!inner(name, status)\n        `)\n        .eq('status', 'active')\n        .eq('countries.status', 'active')\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error(' Error fetching active cities:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Transform data to include country name and derive effective status from parent country\n      const transformedData = data?.map(city => ({\n        ...city,\n        country: city.countries?.name || 'Unknown',\n        status: (city.status === 'active' && (city.countries?.status === 'active')) ? 'active' : 'disabled'\n      })) || [];\n\n      console.log(' Successfully fetched active cities:', transformedData.length);\n\n      return {\n        data: transformedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in getActiveCities:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Get popular cities\n   */\n  static async getPopularCities(): Promise<CityServiceResponse<CityRow[]>> {\n    try {\n      console.log(' Fetching popular cities...');\n\n      const { data, error } = await supabase\n        .from('cities')\n        .select(`\n          *,\n          countries!inner(name, status)\n        `)\n        .eq('status', 'active')\n        .eq('countries.status', 'active')\n        .eq('is_popular', true)\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error(' Error fetching popular cities:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Transform data to include country name and derive effective status from parent country\n      const transformedData = data?.map(city => ({\n        ...city,\n        country: city.countries?.name || 'Unknown',\n        status: (city.status === 'active' && (city.countries?.status === 'active')) ? 'active' : 'disabled'\n      })) || [];\n\n      console.log(' Successfully fetched popular cities:', transformedData.length);\n\n      return {\n        data: transformedData,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in getPopularCities:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Get active countries for city management\n   */\n  static async getActiveCountries(): Promise<CityServiceResponse<any[]>> {\n    try {\n      console.log(' Fetching active countries for cities...');\n\n      const response = await CountriesService.getCountriesByStatus('active');\n      \n      if (!response.success || !response.data) {\n        return {\n          data: null,\n          error: response.error || 'Failed to fetch active countries',\n          success: false,\n        };\n      }\n\n      console.log(' Successfully fetched active countries:', response.data.length);\n\n      return {\n        data: response.data,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error in getActiveCountries:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n}\n\nexport default CitiesService;","import { adminSupabase as supabaseAdmin } from '@/lib/supabaseClient';\nimport type { Tables, TablesInsert, TablesUpdate, Json } from '@/integrations/supabase/types';\nimport { userTrackingService } from './userTrackingService';\nimport { locationResolutionService, resolveTransportRouteLocations } from './locationResolutionService';\n\n// Transport Routes service using admin client to bypass RLS\nexport const listTransportRoutes = async (filters?: {\n  country?: string;\n  transferType?: string;\n}) => {\n  let query = supabaseAdmin\n    .from('transport_routes')\n    .select('*')\n    // Prefer ordering by start_location to support live schema\n    .order('start_location', { ascending: true });\n\n  if (filters?.country) {\n    query = query.eq('country', filters.country);\n  }\n  if (filters?.transferType) {\n    query = query.ilike('transfer_type', filters.transferType);\n  }\n\n  const { data, error } = await query;\n  if (error) throw error;\n  \n  // Resolve location codes to full names for all routes\n  const routes = (data || []) as Tables<'transport_routes'>[];\n  const resolvedRoutes = await Promise.all(\n    routes.map(route => resolveTransportRouteLocations(route))\n  );\n  \n  return resolvedRoutes;\n};\n\nexport const createTransportRoute = async (\n  // Accept a flexible payload to support differing live schemas\n  payload: Partial<TablesInsert<'transport_routes'>> & {\n    start_location?: string;\n    end_location?: string;\n    isActive?: boolean;\n  }\n) => {\n  // Build a minimal insert payload compatible with live `transport_routes`\n  const startLoc = (payload as any).start_location;\n  const endLoc = (payload as any).end_location;\n  const routeName = (payload as any).name ??\n    (startLoc && endLoc ? `${startLoc} to ${endLoc}` : 'Route');\n  // Ensure route_code is always non-null to satisfy NOT NULL constraint\n  // Prefer meaningful code from start/end, otherwise generate a safe fallback\n  const routeCode = (payload as any).route_code ??\n    (startLoc && endLoc\n      ? `${String(startLoc).toUpperCase()}-${String(endLoc).toUpperCase()}`\n      : `RT-${Date.now().toString().slice(-6)}`);\n  const transportEntries = (payload as any).transport_entries;\n\n  // Get user tracking data for creation\n  const trackingData = userTrackingService.getCreateTrackingData();\n\n  // Handle status conversion: boolean isActive -> text status and boolean is_active\n  const isActive = (payload as any).isActive ?? ((payload as any).status === 'active' || (payload as any).status !== 'inactive');\n  const textStatus = isActive ? 'active' : 'inactive';\n\n  // Resolve location codes to full names\n  const startLocationCode = (payload as any).start_location_code ?? startLoc;\n  const endLocationCode = (payload as any).end_location_code ?? endLoc;\n  \n  // Ensure we always have a non-null value for full names to satisfy NOT NULL constraint\n  let startLocationFullName = (payload as any).start_location_full_name;\n  let endLocationFullName = (payload as any).end_location_full_name;\n  \n  // If full names are not provided in payload, try to resolve them\n  if (!startLocationFullName && startLocationCode) {\n    startLocationFullName = await locationResolutionService.getLocationFullName(startLocationCode);\n  }\n  \n  if (!endLocationFullName && endLocationCode) {\n    endLocationFullName = await locationResolutionService.getLocationFullName(endLocationCode);\n  }\n  \n  // If full names couldn't be resolved, use the location codes as fallback\n  if (!startLocationFullName && startLocationCode) {\n    startLocationFullName = startLocationCode;\n  } else if (!startLocationFullName) {\n    // Last resort fallback - use a placeholder that satisfies NOT NULL constraint\n    startLocationFullName = \"Unknown Start Location\";\n  }\n  \n  if (!endLocationFullName && endLocationCode) {\n    endLocationFullName = endLocationCode;\n  } else if (!endLocationFullName) {\n    // Last resort fallback - use a placeholder that satisfies NOT NULL constraint\n    endLocationFullName = \"Unknown End Location\";\n  }\n\n  // Extract coordinates from payload if available\n  const startCoordinates = (payload as any).start_coordinates || null;\n  const endCoordinates = (payload as any).end_coordinates || null;\n  \n  // Extract vehicle types from payload\n  const vehicleTypes = (payload as any).vehicle_types || transportEntries || null;\n  \n  // Process intermediate stops to ensure they have full_name values\n  const intermediateStops = (payload as any).intermediate_stops || [];\n  if (intermediateStops.length > 0) {\n    for (let i = 0; i < intermediateStops.length; i++) {\n      const stop = intermediateStops[i];\n      if (stop.location_code && !stop.full_name) {\n        const fullName = await locationResolutionService.getLocationFullName(stop.location_code);\n        intermediateStops[i].full_name = fullName || stop.location_code;\n      }\n      // Ensure stop_order is set\n      if (intermediateStops[i].stop_order === undefined) {\n        intermediateStops[i].stop_order = i + 1;\n      }\n    }\n  }\n  \n  // Process sightseeing options\n  const sightseeingOptions = (payload as any).sightseeing_options || (payload as any).sightseeingOptions || [];\n  \n  const insertPayload: any = {\n    // Basic route information\n    country: (payload as any).country,\n    route_name: (payload as any).route_name || routeName,\n    notes: (payload as any).notes,\n    route_code: (payload as any).route_code || routeCode,\n    transfer_type: (payload as any).transfer_type,\n    vehicle_types: vehicleTypes,\n    \n    // Location information\n    start_location: startLoc,\n    end_location: endLoc,\n    start_location_code: startLocationCode,\n    end_location_code: endLocationCode,\n    start_location_full_name: startLocationFullName,\n    end_location_full_name: endLocationFullName,\n    start_coordinates: startCoordinates,\n    end_coordinates: endCoordinates,\n    \n    // Additional route details\n    distance: (payload as any).distance,\n    duration: (payload as any).duration,\n    enable_sightseeing: (payload as any).enable_sightseeing,\n    \n    // Status information\n    status: textStatus,\n    is_active: isActive,\n    \n    // Related data\n    transport_entries: transportEntries,\n    sightseeing_options: sightseeingOptions,\n    transfer_method_notes: (payload as any).transfer_method_notes || (payload as any).transferMethodNotes,\n    description: (payload as any).description,\n    route_segments: (payload as any).route_segments,\n    intermediate_stops: intermediateStops,\n    sightseeing_locations: (payload as any).sightseeing_locations,\n    \n    // User tracking fields\n    created_by_user: trackingData.createdByUser,\n    updated_by_user: trackingData.updatedByUser,\n    created_by: trackingData.createdBy,\n    updated_by: trackingData.updatedBy,\n  };\n  \n  // Attempt insert; if PostgREST complains about unknown columns, drop them and retry\n  let attemptPayload = { ...insertPayload };\n  for (let attempt = 0; attempt < 3; attempt++) {\n    const { data, error } = await supabaseAdmin\n      .from('transport_routes')\n      .insert(attemptPayload)\n      .select('*')\n      .single();\n    if (!error) {\n      const routeId = data.id;\n      \n      // Insert intermediate stops if they exist\n      if (intermediateStops && intermediateStops.length > 0) {\n        const stopsToInsert = intermediateStops.map((stop: any, index: number) => ({\n          transport_route_id: routeId,\n          stop_order: stop.stop_order ?? index + 1,\n          location_code: stop.location_code,\n          full_name: stop.full_name,\n          ...userTrackingService.getCreateTrackingData(),\n        }));\n\n        const { error: stopsError } = await supabaseAdmin\n          .from('intermediate_stops')\n          .insert(stopsToInsert);\n\n        if (stopsError) {\n          console.error('Error inserting intermediate stops:', stopsError);\n          // Optionally, you might want to roll back the route creation or handle the error appropriately\n        }\n      }\n      \n      // Insert sightseeing options if they exist\n      if (sightseeingOptions && sightseeingOptions.length > 0) {\n        const optionsToInsert = sightseeingOptions.map((option: any) => ({\n          transport_route_id: routeId,\n          location: option.location,\n          adult_price: option.adultPrice,\n          child_price: option.childPrice,\n          description: option.description,\n          additional_charges: option.additionalCharges,\n          ...userTrackingService.getCreateTrackingData(),\n        }));\n\n        const { error: optionsError } = await supabaseAdmin\n          .from('sightseeing_options')\n          .insert(optionsToInsert);\n\n        if (optionsError) {\n          console.error('Error inserting sightseeing options:', optionsError);\n          // Optionally, you might want to roll back the route creation or handle the error appropriately\n        }\n      }\n      \n      // Insert transport types if they exist\n      const transportTypes = (payload as any).transport_types || [];\n      if (transportTypes && transportTypes.length > 0) {\n        const transportRouteTypes = transportTypes.map((tt: any) => ({\n          transport_route_id: routeId,\n          transport_type_id: tt.id,\n          price: tt.price,\n          duration: tt.duration,\n          ...userTrackingService.getCreateTrackingData(),\n        }));\n\n        const { error: ttError } = await supabaseAdmin\n          .from('transport_route_transport_type')\n          .insert(transportRouteTypes);\n\n        if (ttError) {\n          console.error('Error inserting transport route types:', ttError);\n        }\n      }\n      \n      // Resolve location codes in the returned data\n      const resolvedData = await resolveTransportRouteLocations(data);\n      return resolvedData as Tables<'transport_routes'>;\n    }\n    const msg = String(error.message || '');\n    const m1 = msg.match(/Could not find the '([a-zA-Z0-9_]+)' column of 'transport_routes'/);\n    const m2 = msg.match(/column\\s+transport_routes\\.([a-zA-Z0-9_]+)\\s+does\\s+not\\s+exist/i);\n    const unknownCol = (m1 && m1[1]) || (m2 && m2[1]);\n    if (unknownCol && unknownCol in attemptPayload) {\n      delete (attemptPayload as any)[unknownCol];\n      continue;\n    }\n    // If we cannot identify an unknown column, surface the error\n    throw error;\n  }\n  // Fallback: perform one last minimal insert\n  const { data, error } = await supabaseAdmin\n    .from('transport_routes')\n    .insert({\n      country: (payload as any).country,\n      transfer_type: (payload as any).transfer_type,\n      start_location: startLoc,\n      end_location: endLoc,\n      route_code: routeCode,\n      route_name: routeName,\n      status: (payload as any).status ?? 'active',\n    })\n    .select('*')\n    .single();\n  if (error) throw error;\n  \n  // Resolve location codes in the returned data\n  const resolvedData = await resolveTransportRouteLocations(data);\n  return resolvedData as Tables<'transport_routes'>;\n};\n\nexport const updateTransportRoute = async (\n  id: string,\n  // Accept a flexible payload to support differing live schemas\n  payload: Partial<TablesUpdate<'transport_routes'>> & {\n    start_location?: string;\n    end_location?: string;\n    isActive?: boolean;\n  }\n) => {\n  // Build a minimal update payload compatible with live `transport_routes`\n  const updatePayload: any = {};\n\n  // Get user tracking data for updates\n  const trackingData = userTrackingService.getUpdateTrackingData();\n\n  // Handle status conversion: boolean isActive -> text status and boolean is_active\n  if ((payload as any).isActive !== undefined) {\n    const isActive = (payload as any).isActive;\n    updatePayload.is_active = isActive;\n    updatePayload.status = isActive ? 'active' : 'inactive'; // Keep legacy status in sync\n  } else if ((payload as any).status !== undefined) {\n    const textStatus = (payload as any).status;\n    updatePayload.status = textStatus;\n    updatePayload.is_active = textStatus === 'active'; // Convert text status to boolean\n  }\n\n  // Only include fields that are provided in the payload\n  if ((payload as any).country !== undefined) updatePayload.country = (payload as any).country;\n  if ((payload as any).transfer_type !== undefined) updatePayload.transfer_type = (payload as any).transfer_type;\n  if ((payload as any).start_location !== undefined) updatePayload.start_location = (payload as any).start_location;\n  if ((payload as any).end_location !== undefined) updatePayload.end_location = (payload as any).end_location;\n  \n  // Handle location code updates with automatic resolution\n  if ((payload as any).start_location_code !== undefined) {\n    updatePayload.start_location_code = (payload as any).start_location_code;\n    const startLocationFullName = await locationResolutionService.getLocationFullName((payload as any).start_location_code);\n    if (startLocationFullName) {\n      updatePayload.start_location_full_name = startLocationFullName;\n    }\n  }\n  if ((payload as any).end_location_code !== undefined) {\n    updatePayload.end_location_code = (payload as any).end_location_code;\n    const endLocationFullName = await locationResolutionService.getLocationFullName((payload as any).end_location_code);\n    if (endLocationFullName) {\n      updatePayload.end_location_full_name = endLocationFullName;\n    }\n  }\n  \n  if ((payload as any).route_code !== undefined) updatePayload.route_code = (payload as any).route_code;\n  if ((payload as any).name !== undefined) updatePayload.name = (payload as any).name;\n  if ((payload as any).route_name !== undefined) updatePayload.route_name = (payload as any).route_name;\n  if ((payload as any).transport_entries !== undefined) updatePayload.transport_entries = (payload as any).transport_entries;\n  // Handle sightseeing options and transfer method notes\n  if ((payload as any).sightseeing_options !== undefined) updatePayload.sightseeing_options = (payload as any).sightseeing_options;\n  if ((payload as any).sightseeingOptions !== undefined) updatePayload.sightseeing_options = (payload as any).sightseeingOptions;\n  if ((payload as any).transfer_method_notes !== undefined) updatePayload.transfer_method_notes = (payload as any).transfer_method_notes;\n  if ((payload as any).transferMethodNotes !== undefined) updatePayload.transfer_method_notes = (payload as any).transferMethodNotes;\n  if ((payload as any).notes !== undefined) updatePayload.notes = (payload as any).notes;\n  if ((payload as any).description !== undefined) updatePayload.description = (payload as any).description;\n  if ((payload as any).distance !== undefined) updatePayload.distance = (payload as any).distance;\n  if ((payload as any).duration !== undefined) updatePayload.duration = (payload as any).duration;\n  if ((payload as any).enable_sightseeing !== undefined) updatePayload.enable_sightseeing = (payload as any).enable_sightseeing;\n  if ((payload as any).route_segments !== undefined) updatePayload.route_segments = (payload as any).route_segments;\n  if ((payload as any).intermediate_stops !== undefined) updatePayload.intermediate_stops = (payload as any).intermediate_stops;\n  if ((payload as any).sightseeing_locations !== undefined) updatePayload.sightseeing_locations = (payload as any).sightseeing_locations;\n\n  // Add user tracking fields for updates\n  updatePayload.updated_by_user = trackingData.updatedByUser;\n  updatePayload.updated_by = trackingData.updatedBy;\n  \n  // Attempt update with fallback removal of unknown columns\n  let attemptPayload = { ...updatePayload };\n  for (let attempt = 0; attempt < 3; attempt++) {\n    const { data, error } = await supabaseAdmin\n      .from('transport_routes')\n      .update(attemptPayload)\n      .eq('id', id)\n      .select('*')\n      .single();\n    if (!error) {\n      const routeId = data.id;\n\n      // If the payload includes intermediate stops, update them (delete and re-insert)\n      if ((payload as any).intermediate_stops !== undefined) {\n        const intermediateStops = (payload as any).intermediate_stops || [];\n\n        // Process stops to ensure they have full_name and stop_order values\n        for (let i = 0; i < intermediateStops.length; i++) {\n          const stop = intermediateStops[i];\n          if (stop.location_code && !stop.full_name) {\n            const fullName = await locationResolutionService.getLocationFullName(stop.location_code);\n            intermediateStops[i].full_name = fullName || stop.location_code;\n          }\n          if (intermediateStops[i].stop_order === undefined) {\n            intermediateStops[i].stop_order = i + 1;\n          }\n        }\n\n        // Delete existing stops and insert the new ones\n        await supabaseAdmin.from('intermediate_stops').delete().eq('transport_route_id', routeId);\n        if (intermediateStops.length > 0) {\n          const stopsToInsert = intermediateStops.map((stop: any) => ({\n            transport_route_id: routeId,\n            stop_order: stop.stop_order,\n            location_code: stop.location_code,\n            full_name: stop.full_name,\n            ...userTrackingService.getCreateTrackingData(),\n          }));\n          const { error: stopsError } = await supabaseAdmin.from('intermediate_stops').insert(stopsToInsert);\n          if (stopsError) console.error('Error updating intermediate stops:', stopsError);\n        }\n      }\n\n      // If the payload includes sightseeing options, update them (delete and re-insert)\n      if ((payload as any).sightseeing_options !== undefined || (payload as any).sightseeingOptions !== undefined) {\n        const sightseeingOptions = (payload as any).sightseeing_options || (payload as any).sightseeingOptions || [];\n\n        // Delete existing options and insert the new ones\n        await supabaseAdmin.from('sightseeing_options').delete().eq('transport_route_id', routeId);\n        if (sightseeingOptions.length > 0) {\n          const optionsToInsert = sightseeingOptions.map((option: any) => ({\n            transport_route_id: routeId,\n            location: option.location,\n            adult_price: option.adultPrice,\n            child_price: option.childPrice,\n            description: option.description,\n            additional_charges: option.additionalCharges,\n            ...userTrackingService.getCreateTrackingData(),\n          }));\n          const { error: optionsError } = await supabaseAdmin.from('sightseeing_options').insert(optionsToInsert);\n          if (optionsError) console.error('Error updating sightseeing options:', optionsError);\n        }\n      }\n      \n      // If the payload includes transport types, update them (delete and re-insert)\n      if ((payload as any).transport_types !== undefined) {\n        const transportTypes = (payload as any).transport_types || [];\n\n        // Delete existing types and insert the new ones\n        await supabaseAdmin.from('transport_route_transport_type').delete().eq('transport_route_id', routeId);\n        if (transportTypes.length > 0) {\n          const ttToInsert = transportTypes.map((tt: any) => ({\n            transport_route_id: routeId,\n            transport_type_id: tt.id,\n            price: tt.price,\n            duration: tt.duration,\n            ...userTrackingService.getCreateTrackingData(),\n          }));\n          const { error: ttError } = await supabaseAdmin.from('transport_route_transport_type').insert(ttToInsert);\n          if (ttError) console.error('Error updating transport route types:', ttError);\n        }\n      }\n      \n      // Resolve location codes in the returned data\n      const resolvedData = await resolveTransportRouteLocations(data);\n      return resolvedData as Tables<'transport_routes'>;\n    }\n    const msg = String(error.message || '');\n    const m1 = msg.match(/Could not find the '([a-zA-Z0-9_]+)' column of 'transport_routes'/);\n    const m2 = msg.match(/column\\s+transport_routes\\.([a-zA-Z0-9_]+)\\s+does\\s+not\\s+exist/i);\n    const unknownCol = (m1 && m1[1]) || (m2 && m2[1]);\n    if (unknownCol && unknownCol in attemptPayload) {\n      delete (attemptPayload as any)[unknownCol];\n      continue;\n    }\n    throw error;\n  }\n  // Last resort: minimal update\n  const { data, error } = await supabaseAdmin\n    .from('transport_routes')\n    .update({\n      country: (payload as any).country,\n      transfer_type: (payload as any).transfer_type,\n      start_location: (payload as any).start_location,\n      end_location: (payload as any).end_location,\n      name: (payload as any).name,\n      status: (payload as any).status,\n    })\n    .eq('id', id)\n    .select('*')\n    .single();\n  if (error) throw error;\n  \n  // Resolve location codes in the returned data\n  const resolvedData = await resolveTransportRouteLocations(data);\n  return resolvedData as Tables<'transport_routes'>;\n};\n\nexport const deleteTransportRoute = async (id: string) => {\n  const { error } = await supabaseAdmin\n    .from('transport_routes')\n    .delete()\n    .eq('id', id);\n  if (error) throw error;\n  return true;\n};\n\n// Basic mapping to proposal TransportRoute type\nexport function mapRouteRowToProposalRoute(row: Tables<'transport_routes'>) {\n  let price = 0;\n  let duration = 'N/A';\n  const vt = (row as any).vehicle_types as Json | null;\n  const te = (row as any).transport_entries as Json | null;\n  const source = Array.isArray(vt) && vt.length > 0 ? vt : Array.isArray(te) ? te : [];\n  if (Array.isArray(source) && source.length > 0) {\n    const first: any = source[0];\n    const p = typeof first?.price === 'number' ? first.price : Number(first?.price);\n    price = isNaN(p) ? 0 : p;\n    duration = typeof first?.duration === 'string' ? first.duration : duration;\n  }\n\n  return {\n    id: row.id,\n    from: (row as any).start_location_code || (row as any).start_location,\n    to: (row as any).end_location_code || (row as any).end_location,\n    distance: 0,\n    duration,\n    transportType: row.transfer_type,\n    price,\n    // Prefer `name` but fall back to legacy `route_name`\n    name: (row as any).name || (row as any).route_name,\n    country: row.country,\n    code: (row as any).route_code || `${(row as any).start_location}-${(row as any).end_location}`,\n    transferType: row.transfer_type,\n  };\n}","\nimport { Query, Proposal } from '@/types/query';\nimport { ProposalData } from '@/services/proposalService';\nimport { ProposalIdGenerator } from '@/utils/proposalIdGenerator';\n\ninterface ProposalChange {\n  id: string;\n  proposalId: string;\n  timestamp: string;\n  userId: string;\n  changeType: 'create' | 'update' | 'duplicate' | 'status_change';\n  field?: string;\n  oldValue?: any;\n  newValue?: any;\n  description: string;\n}\n\ninterface ProposalVersion {\n  versionId: string;\n  proposalId: string;\n  timestamp: string;\n  data: ProposalData;\n  changeDescription: string;\n}\n\ninterface BulkOperationRequest {\n  type: 'assign' | 'status-update' | 'export' | 'template-apply';\n  queryIds: string[];\n  data: any;\n}\n\ninterface BulkOperationResult {\n  success: number;\n  failed: number;\n  errors: string[];\n}\n\nexport class EnhancedProposalService {\n  private static instance: EnhancedProposalService;\n  private proposalStorageKey = 'travel_proposals_v3';\n  private changesStorageKey = 'proposal_changes_v1';\n  private versionsStorageKey = 'proposal_versions_v1';\n\n  public static getInstance(): EnhancedProposalService {\n    if (!EnhancedProposalService.instance) {\n      EnhancedProposalService.instance = new EnhancedProposalService();\n    }\n    return EnhancedProposalService.instance;\n  }\n\n  // Create new proposal with ENQ-based ID\n  public createProposal(queryId: string, proposalData: Partial<ProposalData>): string {\n    try {\n      const proposalId = ProposalIdGenerator.generateProposalId(queryId);\n      \n      const newProposal: ProposalData = {\n        id: proposalId,\n        queryId,\n        query: proposalData.query!,\n        modules: proposalData.modules || [],\n        totals: proposalData.totals || {\n          subtotal: 0,\n          discountAmount: 0,\n          total: 0,\n          moduleCount: 0\n        },\n        metadata: {\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          status: 'draft',\n          version: 1\n        }\n      };\n\n      this.saveProposal(newProposal);\n      this.logChange(proposalId, 'create', 'Proposal created');\n      this.saveVersion(newProposal, 'Initial proposal creation');\n\n      return proposalId;\n    } catch (error) {\n      console.error('Error creating proposal:', error);\n      throw new Error('Failed to create proposal');\n    }\n  }\n\n  // Duplicate existing proposal\n  public duplicateProposal(originalId: string, newQueryId?: string): string | null {\n    try {\n      const original = this.getProposal(originalId);\n      if (!original) return null;\n\n      const targetQueryId = newQueryId || original.queryId;\n      const newProposalId = ProposalIdGenerator.generateProposalId(targetQueryId);\n\n      const duplicated: ProposalData = {\n        ...original,\n        id: newProposalId,\n        queryId: targetQueryId,\n        metadata: {\n          ...original.metadata,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          status: 'draft',\n          version: 1\n        }\n      };\n\n      this.saveProposal(duplicated);\n      this.logChange(newProposalId, 'duplicate', `Duplicated from ${originalId}`);\n      this.saveVersion(duplicated, `Duplicated from proposal ${originalId}`);\n\n      return newProposalId;\n    } catch (error) {\n      console.error('Error duplicating proposal:', error);\n      return null;\n    }\n  }\n\n  // Get all proposals for a query\n  public getProposalsByQuery(queryId: string): ProposalData[] {\n    try {\n      const allProposals = this.getAllProposals();\n      return allProposals.filter(p => p.queryId === queryId)\n        .sort((a, b) => new Date(b.metadata.createdAt).getTime() - new Date(a.metadata.createdAt).getTime());\n    } catch (error) {\n      console.error('Error getting proposals by query:', error);\n      return [];\n    }\n  }\n\n  // Update proposal with change tracking\n  public updateProposal(proposalId: string, updates: Partial<ProposalData>, changeDescription?: string): boolean {\n    try {\n      const existing = this.getProposal(proposalId);\n      if (!existing) return false;\n\n      const updated: ProposalData = {\n        ...existing,\n        ...updates,\n        metadata: {\n          ...existing.metadata,\n          ...updates.metadata,\n          updatedAt: new Date().toISOString(),\n          version: existing.metadata.version + 1\n        }\n      };\n\n      this.saveProposal(updated);\n      this.logChange(proposalId, 'update', changeDescription || 'Proposal updated');\n      this.saveVersion(updated, changeDescription || 'Proposal updated');\n\n      return true;\n    } catch (error) {\n      console.error('Error updating proposal:', error);\n      return false;\n    }\n  }\n\n  // Process bulk operations\n  public async processBulkOperation(request: BulkOperationRequest): Promise<BulkOperationResult> {\n    const result: BulkOperationResult = {\n      success: 0,\n      failed: 0,\n      errors: []\n    };\n\n    try {\n      for (const queryId of request.queryIds) {\n        try {\n          switch (request.type) {\n            case 'assign':\n              // Handle bulk assignment logic\n              console.log(`Assigning query ${queryId} to staff ${request.data.staffId}`);\n              result.success++;\n              break;\n            \n            case 'status-update':\n              // Handle bulk status update\n              console.log(`Updating query ${queryId} status to ${request.data.status}`);\n              result.success++;\n              break;\n            \n            case 'export':\n              // Handle bulk export\n              console.log(`Exporting query ${queryId}`);\n              result.success++;\n              break;\n            \n            case 'template-apply':\n              // Handle bulk template application\n              console.log(`Applying template ${request.data.templateId} to query ${queryId}`);\n              result.success++;\n              break;\n            \n            default:\n              throw new Error(`Unknown operation type: ${request.type}`);\n          }\n        } catch (error) {\n          result.failed++;\n          result.errors.push(`Failed to process ${queryId}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n      }\n    } catch (error) {\n      console.error('Bulk operation error:', error);\n      throw new Error('Bulk operation failed');\n    }\n\n    return result;\n  }\n\n  // Get proposal change history\n  public getProposalChanges(proposalId: string): ProposalChange[] {\n    try {\n      const changes = this.getAllChanges();\n      return changes.filter(c => c.proposalId === proposalId)\n        .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n    } catch (error) {\n      console.error('Error getting proposal changes:', error);\n      return [];\n    }\n  }\n\n  // Get proposal versions\n  public getProposalVersions(proposalId: string): ProposalVersion[] {\n    try {\n      const versions = this.getAllVersions();\n      return versions.filter(v => v.proposalId === proposalId)\n        .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n    } catch (error) {\n      console.error('Error getting proposal versions:', error);\n      return [];\n    }\n  }\n\n  private saveProposal(proposal: ProposalData): void {\n    const proposals = this.getAllProposals();\n    const existingIndex = proposals.findIndex(p => p.id === proposal.id);\n    \n    if (existingIndex >= 0) {\n      proposals[existingIndex] = proposal;\n    } else {\n      proposals.push(proposal);\n    }\n\n    localStorage.setItem(this.proposalStorageKey, JSON.stringify(proposals));\n  }\n\n  private getProposal(id: string): ProposalData | null {\n    const proposals = this.getAllProposals();\n    return proposals.find(p => p.id === id) || null;\n  }\n\n  private getAllProposals(): ProposalData[] {\n    try {\n      const saved = localStorage.getItem(this.proposalStorageKey) || '[]';\n      return JSON.parse(saved);\n    } catch (error) {\n      console.error('Error loading proposals:', error);\n      return [];\n    }\n  }\n\n  private logChange(proposalId: string, changeType: ProposalChange['changeType'], description: string): void {\n    const change: ProposalChange = {\n      id: `change_${Date.now()}`,\n      proposalId,\n      timestamp: new Date().toISOString(),\n      userId: 'current_user', // Replace with actual user ID\n      changeType,\n      description\n    };\n\n    const changes = this.getAllChanges();\n    changes.push(change);\n    localStorage.setItem(this.changesStorageKey, JSON.stringify(changes));\n  }\n\n  private getAllChanges(): ProposalChange[] {\n    try {\n      const saved = localStorage.getItem(this.changesStorageKey) || '[]';\n      return JSON.parse(saved);\n    } catch (error) {\n      console.error('Error loading changes:', error);\n      return [];\n    }\n  }\n\n  private saveVersion(proposal: ProposalData, changeDescription: string): void {\n    const version: ProposalVersion = {\n      versionId: `v${proposal.metadata.version}_${Date.now()}`,\n      proposalId: proposal.id,\n      timestamp: new Date().toISOString(),\n      data: { ...proposal },\n      changeDescription\n    };\n\n    const versions = this.getAllVersions();\n    versions.push(version);\n    localStorage.setItem(this.versionsStorageKey, JSON.stringify(versions));\n  }\n\n  private getAllVersions(): ProposalVersion[] {\n    try {\n      const saved = localStorage.getItem(this.versionsStorageKey) || '[]';\n      return JSON.parse(saved);\n    } catch (error) {\n      console.error('Error loading versions:', error);\n      return [];\n    }\n  }\n\n  // Clean up old versions (keep last 10 per proposal)\n  public cleanupOldVersions(proposalId: string): void {\n    try {\n      const allVersions = this.getAllVersions();\n      const proposalVersions = allVersions.filter(v => v.proposalId === proposalId)\n        .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n      \n      const versionsToKeep = proposalVersions.slice(0, 10);\n      const otherVersions = allVersions.filter(v => v.proposalId !== proposalId);\n      \n      localStorage.setItem(this.versionsStorageKey, JSON.stringify([...otherVersions, ...versionsToKeep]));\n    } catch (error) {\n      console.error('Error cleaning up versions:', error);\n    }\n  }\n}\n\nexport default EnhancedProposalService.getInstance();\n","import { Query, Proposal } from '@/types/query';\nimport { AdvancedProposalModule } from '@/types/advancedProposal';\nimport { mockQueries } from '@/data/queryData';\nimport { EnqIdGenerator } from '@/utils/enqIdGenerator';\nimport { initialCountries } from '@/pages/inventory/countries/data/countryData';\nimport { getCountryByName } from '@/services/countryMappingService';\nimport { getEnquiryById } from '@/services/enquiriesService';\nimport EnhancedService from './enhancedProposalService';\n\nexport interface ProposalData {\n  id: string;\n  queryId: string;\n  query: Query;\n  modules: AdvancedProposalModule[];\n  totals: {\n    subtotal: number;\n    discountAmount: number;\n    total: number;\n    moduleCount: number;\n    bundleDiscounts?: any[];\n  };\n  metadata: {\n    createdAt: string;\n    updatedAt: string;\n    status: 'draft' | 'ready' | 'sent' | 'viewed' | 'feedback-received' | 'modification-requested' | 'modified' | 'approved' | 'rejected';\n    version: number;\n    sentDate?: string;\n    viewedDate?: string;\n    agentFeedback?: {\n      message: string;\n      requestedChanges: string[];\n      priority: 'low' | 'normal' | 'high' | 'urgent';\n      receivedAt: string;\n    };\n    modifications?: {\n      version: number;\n      changes: string;\n      modifiedAt: string;\n      modifiedBy: string;\n    }[];\n  };\n}\n\nclass ProposalService {\n  private static instance: ProposalService;\n  private storageKey = 'travel_proposals_v2';\n  private queryStorageKey = 'travel_queries';\n\n  public static getInstance(): ProposalService {\n    if (!ProposalService.instance) {\n      ProposalService.instance = new ProposalService();\n    }\n    return ProposalService.instance;\n  }\n\n  public async createQuery(queryData: Omit<Query, 'id' | 'createdAt' | 'updatedAt'>): Promise<Query> {\n    try {\n      const queries = this.getAllQueries();\n      \n      // Generate ID with fallback to simple format if enquiry system fails\n      let enquiryId: string;\n      try {\n        // Map country name to country code for ID generation\n        let selectedCountryCode: string | undefined;\n        if (queryData.destination?.country) {\n          // Use robust mapping that supports common aliases (UAE, USA, UK)\n          const mapped = getCountryByName(queryData.destination.country);\n          if (mapped) {\n            selectedCountryCode = mapped.code;\n          } else {\n            const foundCountry = initialCountries.find(c => c.name === queryData.destination.country);\n            selectedCountryCode = foundCountry?.code;\n          }\n          console.log('Creating query for country:', queryData.destination.country, 'mapped to code:', selectedCountryCode);\n        }\n\n        // Ensure Supabase-backed enquiry configuration and active countries are prepared\n        await EnqIdGenerator.prepareConfig(selectedCountryCode);\n\n        enquiryId = EnqIdGenerator.generateEnqId(selectedCountryCode);\n        console.log('Generated enquiry ID:', enquiryId);\n      } catch (enquiryError) {\n        console.warn('EnqIdGenerator failed, using fallback ID generation:', enquiryError);\n        // Fallback to simple ID generation\n        const year = new Date().getFullYear();\n        const randomNum = Math.floor(Math.random() * 10000).toString().padStart(4, '0');\n        enquiryId = `ENQ${year}${randomNum}`;\n        console.log('Using fallback enquiry ID:', enquiryId);\n      }\n      \n      const newQuery: Query = {\n        ...queryData,\n        id: enquiryId,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n\n      queries.push(newQuery);\n      localStorage.setItem(this.queryStorageKey, JSON.stringify(queries));\n      \n      return newQuery;\n    } catch (error) {\n      console.error('Error creating query:', error);\n      throw new Error('Failed to create query');\n    }\n  }\n\n  public getAllQueries(): Query[] {\n    try {\n      const saved = localStorage.getItem(this.queryStorageKey) || '[]';\n      return JSON.parse(saved);\n    } catch (error) {\n      console.error('Error loading queries:', error);\n      return [];\n    }\n  }\n\n  public getQueryById(id: string): Query | null {\n    try {\n      // First try to get from localStorage\n      const savedQueries = localStorage.getItem(this.queryStorageKey) || '[]';\n      const queries = JSON.parse(savedQueries);\n      const foundQuery = queries.find((q: Query) => q.id === id);\n      \n      if (foundQuery) {\n        return foundQuery;\n      }\n\n      // Fallback to mock data\n      const mockQuery = mockQueries.find(q => q.id === id);\n      if (mockQuery) {\n        return mockQuery;\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error loading query:', error);\n      return null;\n    }\n  }\n\n  // Async version with Supabase fallback while preserving existing logic\n  public async getQueryByIdAsync(id: string): Promise<Query | null> {\n    try {\n      // First, reuse existing local/mock logic\n      const localOrMock = this.getQueryById(id);\n      if (localOrMock) return localOrMock;\n\n      // Supabase fallback via enquiriesService\n      const { data, error } = await getEnquiryById(id);\n      if (error) {\n        console.warn('Supabase getEnquiryById error:', error);\n        return null;\n      }\n      return data || null;\n    } catch (err) {\n      console.warn('getQueryByIdAsync fallback failed:', err);\n      return null;\n    }\n  }\n\n  public saveProposal(proposalData: Partial<ProposalData>): string {\n    try {\n      const proposals = this.getAllProposals();\n      \n      // Use enhanced service for new proposals\n      if (!proposalData.id && proposalData.queryId) {\n        return EnhancedService.createProposal(proposalData.queryId, proposalData);\n      }\n      \n      const proposalId = proposalData.id || `PROP_${Date.now()}`;\n      \n      const newProposal: ProposalData = {\n        id: proposalId,\n        queryId: proposalData.queryId || '',\n        query: proposalData.query!,\n        modules: proposalData.modules || [],\n        totals: proposalData.totals || {\n          subtotal: 0,\n          discountAmount: 0,\n          total: 0,\n          moduleCount: 0\n        },\n        metadata: {\n          createdAt: proposalData.metadata?.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          status: proposalData.metadata?.status || 'draft',\n          version: (proposalData.metadata?.version || 0) + 1\n        }\n      };\n\n      const existingIndex = proposals.findIndex(p => p.id === proposalId);\n      if (existingIndex >= 0) {\n        proposals[existingIndex] = newProposal;\n      } else {\n        proposals.push(newProposal);\n      }\n\n      localStorage.setItem(this.storageKey, JSON.stringify(proposals));\n      return proposalId;\n    } catch (error) {\n      console.error('Error saving proposal:', error);\n      throw new Error('Failed to save proposal');\n    }\n  }\n\n  public getProposalById(id: string): ProposalData | null {\n    try {\n      const proposals = this.getAllProposals();\n      return proposals.find(p => p.id === id) || null;\n    } catch (error) {\n      console.error('Error loading proposal:', error);\n      return null;\n    }\n  }\n\n  public getProposalsByQueryId(queryId: string): ProposalData[] {\n    try {\n      const proposals = this.getAllProposals();\n      return proposals.filter(p => p.queryId === queryId);\n    } catch (error) {\n      console.error('Error loading proposals for query:', error);\n      return [];\n    }\n  }\n\n  public getAllProposals(): ProposalData[] {\n    try {\n      const saved = localStorage.getItem(this.storageKey) || '[]';\n      return JSON.parse(saved);\n    } catch (error) {\n      console.error('Error loading proposals:', error);\n      return [];\n    }\n  }\n\n  public deleteProposal(id: string): boolean {\n    try {\n      const proposals = this.getAllProposals();\n      const filtered = proposals.filter(p => p.id !== id);\n      localStorage.setItem(this.storageKey, JSON.stringify(filtered));\n      return true;\n    } catch (error) {\n      console.error('Error deleting proposal:', error);\n      return false;\n    }\n  }\n\n  public exportProposal(proposal: ProposalData): void {\n    try {\n      const dataStr = JSON.stringify(proposal, null, 2);\n      const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);\n      \n      const exportFileDefaultName = `proposal_${proposal.query.destination.country}_${new Date().toISOString().split('T')[0]}.json`;\n      \n      const linkElement = document.createElement('a');\n      linkElement.setAttribute('href', dataUri);\n      linkElement.setAttribute('download', exportFileDefaultName);\n      linkElement.click();\n    } catch (error) {\n      console.error('Error exporting proposal:', error);\n      throw new Error('Failed to export proposal');\n    }\n  }\n\n  public duplicateProposal(id: string): string | null {\n    try {\n      const original = this.getProposalById(id);\n      if (!original) return null;\n\n      const duplicate: ProposalData = {\n        ...original,\n        id: `PROP_${Date.now()}`,\n        metadata: {\n          ...original.metadata,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          version: 1,\n          status: 'draft'\n        }\n      };\n\n      return this.saveProposal(duplicate);\n    } catch (error) {\n      console.error('Error duplicating proposal:', error);\n      return null;\n    }\n  }\n\n  public migrateToEnhancedService(): void {\n    try {\n      const existingProposals = this.getAllProposals();\n      \n      console.log(`Migrating ${existingProposals.length} proposals to enhanced service`);\n      \n      // This would migrate existing proposals to the new enhanced format\n      // For now, both services can coexist\n    } catch (error) {\n      console.error('Error migrating to enhanced service:', error);\n    }\n  }\n}\n\nexport default ProposalService.getInstance();\n","import { supabase } from '@/lib/supabaseClient';\nimport { Query } from '@/types/query';\nimport { ItineraryDay } from '@/components/proposal/DayByDayItineraryBuilder';\n\nconst sb = supabase as any;\n\nfunction isUuid(id: string): boolean {\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id);\n}\n\nasync function resolveEnquiryUuid(enquiryBusinessOrUuid: string): Promise<string | null> {\n  try {\n    if (isUuid(enquiryBusinessOrUuid)) return enquiryBusinessOrUuid;\n    const { data, error } = await sb\n      .from('enquiries')\n      .select('id')\n      .eq('enquiry_id', enquiryBusinessOrUuid)\n      .limit(1)\n      .maybeSingle();\n    if (error) return null;\n    return data?.id ?? null;\n  } catch {\n    return null;\n  }\n}\n\nasync function getCurrentProfileId(): Promise<string | null> {\n  try {\n    const { data } = await supabase.auth.getUser();\n    return data?.user?.id ?? null;\n  } catch {\n    return null;\n  }\n}\n\nfunction generateDraftProposalId(queryId: string, draftType: string): string {\n  return `DRAFT-${queryId}-${draftType}`;\n}\n\nfunction generateProposalId(queryId: string): string {\n  const year = new Date().getFullYear();\n  const rand = Math.floor(Math.random() * 100000).toString().padStart(5, '0');\n  return `PROP${year}${rand}`;\n}\n\nfunction computeCostPerPerson(query: Query, totalCost: number): number {\n  const pax = (query?.paxDetails?.adults || 0) + (query?.paxDetails?.children || 0) + (query?.paxDetails?.infants || 0);\n  const divisor = pax > 0 ? pax : 1;\n  return Number((totalCost / divisor).toFixed(2));\n}\n\nfunction buildTitle(query: Query, days: ItineraryDay[]): string {\n  const d = days?.length || query?.tripDuration?.days || 0;\n  const country = query?.destination?.country || 'Trip';\n  return `Proposal for ${country} (${d} days)`;\n}\n\nfunction buildDescription(days: ItineraryDay[]): string {\n  const parts = days.slice(0, 5).map((d) => d.title || `Day ${d.dayNumber}`);\n  return parts.length ? `Includes: ${parts.join(', ')}...` : 'Day-by-day itinerary proposal.';\n}\n\nfunction buildItineraryData(days: ItineraryDay[]): Record<string, any> {\n  const normalizedDays = days.map((day) => ({\n    id: day.id,\n    dayNumber: day.dayNumber,\n    title: day.title,\n    city: day.city,\n    description: day.description,\n    date: day.date,\n    activities: day.activities || [],\n    transport: day.transport || [],\n    accommodations: day.accommodations || [],\n    accommodation: day.accommodation || null,\n    meals: day.meals || { breakfast: false, lunch: false, dinner: false },\n    totalCost: day.totalCost || 0,\n  }));\n  // Initial shape supports optional selections alongside days\n  return {\n    days: normalizedDays,\n    sightseeing_options: [],\n    city_selection: null,\n  };\n}\n\nfunction buildAccommodationData(days: ItineraryDay[]): Record<string, any> {\n  const all: any[] = [];\n  for (const day of days) {\n    if (day.accommodation) {\n      all.push({ ...day.accommodation, dayId: day.id, city: day.city, date: day.date });\n    }\n    (day.accommodations || []).forEach((acc) => {\n      all.push({ ...acc, dayId: day.id, city: day.city, date: day.date });\n    });\n  }\n  return { options: all };\n}\n\nfunction buildPricingData(totalCost: number, currency = 'USD'): Record<string, any> {\n  return {\n    basePrice: totalCost,\n    finalPrice: totalCost,\n    markup: 0,\n    currency,\n    transport_options: [],\n  };\n}\n\n// Generic deep merge for plain objects; arrays are replaced by source\nfunction isPlainObject(value: any): boolean {\n  return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n\nfunction deepMerge<T extends Record<string, any>>(target: T, source: Partial<T>): T {\n  const result: any = { ...target };\n  for (const key of Object.keys(source || {})) {\n    const srcVal = (source as any)[key];\n    const tgtVal = result[key];\n    if (srcVal === undefined) continue;\n    if (Array.isArray(srcVal)) {\n      // Replace arrays entirely to avoid unintended concatenation\n      result[key] = srcVal.slice();\n    } else if (isPlainObject(srcVal) && isPlainObject(tgtVal)) {\n      result[key] = deepMerge(tgtVal, srcVal);\n    } else {\n      result[key] = srcVal;\n    }\n  }\n  return result as T;\n}\n\n// Normalize legacy itinerary_data that may be stored as an array\nfunction normalizeItineraryData(data: any): { days: any[]; sightseeing_options: any[]; city_selection: string | null } {\n  if (Array.isArray(data)) {\n    return { days: data, sightseeing_options: [], city_selection: null };\n  }\n  const base = isPlainObject(data) ? data : {};\n  return {\n    days: Array.isArray((base as any).days) ? (base as any).days : [],\n    sightseeing_options: Array.isArray((base as any).sightseeing_options) ? (base as any).sightseeing_options : [],\n    city_selection: typeof (base as any).city_selection === 'string' || (base as any).city_selection === null\n      ? (base as any).city_selection ?? null\n      : null,\n  };\n}\n\nfunction normalizePricingData(data: any): { basePrice?: number; finalPrice?: number; markup?: number; currency?: string; transport_options: any[] } {\n  const base = isPlainObject(data) ? data : {};\n  return {\n    basePrice: typeof (base as any).basePrice === 'number' ? (base as any).basePrice : undefined,\n    finalPrice: typeof (base as any).finalPrice === 'number' ? (base as any).finalPrice : undefined,\n    markup: typeof (base as any).markup === 'number' ? (base as any).markup : undefined,\n    currency: typeof (base as any).currency === 'string' ? (base as any).currency : undefined,\n    transport_options: Array.isArray((base as any).transport_options) ? (base as any).transport_options : [],\n  };\n}\n\nexport const SupabaseProposalService = {\n  /**\n   * Fetch latest draft by enquiry and draft_type\n   */\n  async getLatestDraftForEnquiry(\n    enquiryBusinessOrUuid: string,\n    draftType: 'daywise' | 'enhanced'\n  ): Promise<{ data?: any; error?: any }> {\n    const enquiryUuid = await resolveEnquiryUuid(enquiryBusinessOrUuid);\n    if (!enquiryUuid) return { error: 'enquiry_uuid_not_found' };\n    const { data, error } = await sb\n      .from('proposals')\n      .select(\n        'id, proposal_id, enquiry_id, title, description, cost_per_person, total_cost, final_price, currency, status, inclusions, exclusions, terms, created_by, created_at, updated_at, sent_at, accepted_at, rejected_at, draft_type, version, itinerary_data, accommodation_data, pricing_data, email_data, agent_feedback, modifications, viewed_at, last_saved'\n      )\n      .eq('enquiry_id', enquiryUuid)\n      .eq('draft_type', draftType)\n      .eq('status', 'draft')\n      .order('last_saved', { ascending: false, nullsFirst: false })\n      .limit(1)\n      .maybeSingle();\n    if (error) return { error };\n    return { data };\n  },\n  /**\n   * List all proposals (including drafts) for an enquiry\n   */\n  async listProposalsByEnquiry(enquiryBusinessOrUuid: string): Promise<{ data?: any[]; error?: any }> {\n    const enquiryUuid = await resolveEnquiryUuid(enquiryBusinessOrUuid);\n    if (!enquiryUuid) return { error: 'enquiry_uuid_not_found' };\n    const { data, error } = await sb\n      .from('proposals')\n      .select(\n        'id, proposal_id, enquiry_id, title, description, cost_per_person, total_cost, final_price, currency, status, inclusions, exclusions, terms, created_by, created_at, updated_at, sent_at, accepted_at, rejected_at, draft_type, version, itinerary_data, accommodation_data, pricing_data, email_data, agent_feedback, modifications, viewed_at, last_saved'\n      )\n      .eq('enquiry_id', enquiryUuid)\n      .order('updated_at', { ascending: false, nullsFirst: false });\n    if (error) return { error };\n    return { data: data || [] };\n  },\n\n  /**\n   * Fetch draft by its proposal_id\n   */\n  async getDraftByProposalId(proposalId: string): Promise<{ data?: any; error?: any }> {\n    const { data, error } = await sb\n      .from('proposals')\n      .select(\n        'id, proposal_id, enquiry_id, title, description, cost_per_person, total_cost, final_price, currency, status, inclusions, exclusions, terms, created_by, created_at, updated_at, sent_at, accepted_at, rejected_at, draft_type, version, itinerary_data, accommodation_data, pricing_data, email_data, agent_feedback, modifications, viewed_at, last_saved'\n      )\n      .eq('proposal_id', proposalId)\n      .limit(1)\n      .maybeSingle();\n    if (error) return { error };\n    return { data };\n  },\n  async upsertDraftProposal(params: {\n    query: Query;\n    days: ItineraryDay[];\n    totalCost: number;\n    draftType: string;\n  }): Promise<{ id?: string; proposal_id?: string; error?: any }> {\n    const { query, days, totalCost, draftType } = params;\n    const enquiryUuid = await resolveEnquiryUuid(query.id);\n    if (!enquiryUuid) {\n      return { error: 'enquiry_uuid_not_found' };\n    }\n\n    const createdBy = await getCurrentProfileId();\n    const proposal_id = generateDraftProposalId(query.id, draftType);\n\n    const row = {\n      proposal_id,\n      enquiry_id: enquiryUuid,\n      title: buildTitle(query, days),\n      description: buildDescription(days),\n      cost_per_person: computeCostPerPerson(query, totalCost),\n      total_cost: Number(totalCost.toFixed(2)),\n      final_price: Number(totalCost.toFixed(2)),\n      currency: query?.budget?.currency || 'USD',\n      status: 'draft',\n      inclusions: [],\n      exclusions: [],\n      terms: query?.inclusions?.mealPlan || null,\n      created_by: createdBy,\n      draft_type: draftType,\n      version: 1,\n      itinerary_data: buildItineraryData(days),\n      accommodation_data: buildAccommodationData(days),\n      pricing_data: buildPricingData(totalCost, query?.budget?.currency || 'USD'),\n      email_data: {},\n      agent_feedback: null,\n      modifications: [],\n      last_saved: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    };\n\n    const { data, error } = await sb\n      .from('proposals')\n      .upsert(row, { onConflict: 'proposal_id' })\n      .select('id,proposal_id')\n      .maybeSingle();\n\n    if (error) return { error };\n    return { id: data?.id, proposal_id: data?.proposal_id };\n  },\n\n  async createProposal(params: {\n    query: Query;\n    days: ItineraryDay[];\n    totalCost: number;\n    draftType?: string;\n    title?: string;\n    description?: string;\n  }): Promise<{ id?: string; proposal_id?: string; error?: any }> {\n    const { query, days, totalCost, draftType = 'enhanced', title, description } = params;\n    const enquiryUuid = await resolveEnquiryUuid(query.id);\n    if (!enquiryUuid) {\n      return { error: 'enquiry_uuid_not_found' };\n    }\n\n    const createdBy = await getCurrentProfileId();\n    const proposal_id = generateProposalId(query.id);\n\n    // Build optional records from query data\n    const optionalRecords = {}; // Default empty optional records\n\n    const row = {\n      proposal_id,\n      enquiry_id: enquiryUuid,\n      title: title || buildTitle(query, days),\n      description: description || buildDescription(days),\n      cost_per_person: computeCostPerPerson(query, totalCost),\n      total_cost: Number(totalCost.toFixed(2)),\n      final_price: Number(totalCost.toFixed(2)),\n      currency: query?.budget?.currency || 'USD',\n      status: 'draft',\n      inclusions: [],\n      exclusions: [],\n      terms: query?.inclusions?.mealPlan || null,\n      created_by: createdBy,\n      draft_type: draftType,\n      version: 1,\n      itinerary_data: buildItineraryData(days),\n      accommodation_data: buildAccommodationData(days),\n      pricing_data: buildPricingData(totalCost, query?.budget?.currency || 'USD'),\n      email_data: {},\n      agent_feedback: null,\n      modifications: [],\n      last_saved: new Date().toISOString(),\n      optional_records: optionalRecords,\n    };\n\n    const { data, error } = await sb\n      .from('proposals')\n      .insert(row)\n      .select('id,proposal_id')\n      .maybeSingle();\n\n    if (error) return { error };\n    return { id: data?.id, proposal_id: data?.proposal_id };\n  },\n\n  async updateProposalStatus(proposalId: string, status: 'draft' | 'ready' | 'sent' | 'accepted' | 'rejected') {\n    const payload: any = { status, updated_at: new Date().toISOString() };\n    if (status === 'sent') payload.sent_at = new Date().toISOString();\n    if (status === 'accepted') payload.accepted_at = new Date().toISOString();\n    if (status === 'rejected') payload.rejected_at = new Date().toISOString();\n    \n    // Handle draft formats by extracting the base enquiry ID\n    let searchId = proposalId;\n    \n    // If it's a draft format like \"DRAFT-ENQ20257999-enhanced\", extract the base enquiry ID\n    if (proposalId.startsWith('DRAFT-')) {\n      const parts = proposalId.split('-');\n      if (parts.length >= 2 && parts[1].startsWith('ENQ')) {\n        searchId = parts[1]; // Extract \"ENQ20257999\" from \"DRAFT-ENQ20257999-enhanced\"\n      }\n    }\n    \n    return await sb.from('proposals').update(payload).eq('proposal_id', searchId);\n  },\n\n  /**\n   * Update draft fields for an existing draft row identified by queryId + draftType.\n   * Will not create rows. Ensure a row is created via upsertDraftProposal beforehand.\n   */\n  async updateDraftFields(params: {\n    queryId: string;\n    draftType: 'daywise' | 'enhanced';\n    patch: Partial<{\n      itinerary_data: any;\n      accommodation_data: any;\n      pricing_data: any;\n      email_data: any;\n      terms: string;\n      inclusions: any;\n      exclusions: any;\n      status: 'draft' | 'ready' | 'sent' | 'accepted' | 'rejected';\n      version: number;\n    }>;\n  }): Promise<{ data?: any; error?: any }> {\n    const { queryId, draftType, patch } = params;\n    const proposalId = generateDraftProposalId(queryId, draftType);\n\n    try {\n      // Fetch existing JSONB fields to allow deep merge\n      const { data: existing, error: fetchError } = await sb\n        .from('proposals')\n        .select('id, itinerary_data, accommodation_data, pricing_data, email_data, inclusions, exclusions, terms, version')\n        .eq('proposal_id', proposalId)\n        .limit(1)\n        .maybeSingle();\n\n      if (fetchError) {\n        // If fetch fails, attempt direct update as a fallback\n        const payload = {\n          ...patch,\n          updated_at: new Date().toISOString(),\n          last_saved: new Date().toISOString(),\n        } as any;\n        const { data, error } = await sb\n          .from('proposals')\n          .update(payload)\n          .eq('proposal_id', proposalId)\n          .select('id, proposal_id, version, last_saved')\n          .maybeSingle();\n        if (error) return { error };\n        return { data };\n      }\n\n      // Prepare merged payloads for JSONB fields\n      let mergedItinerary = existing?.itinerary_data;\n      if (patch.itinerary_data !== undefined) {\n        const currentNormalized = normalizeItineraryData(existing?.itinerary_data);\n        const patchNormalized = normalizeItineraryData(patch.itinerary_data);\n        mergedItinerary = deepMerge(currentNormalized, patchNormalized);\n      }\n\n      let mergedPricing = existing?.pricing_data;\n      if (patch.pricing_data !== undefined) {\n        const currentNormalized = normalizePricingData(existing?.pricing_data);\n        const patchNormalized = normalizePricingData(patch.pricing_data);\n        mergedPricing = deepMerge(currentNormalized, patchNormalized);\n      }\n\n      // Accommodation and email: simple replacement if provided\n      const mergedAccommodation = patch.accommodation_data !== undefined ? patch.accommodation_data : existing?.accommodation_data;\n      const mergedEmail = patch.email_data !== undefined ? patch.email_data : existing?.email_data;\n\n      // Inclusions/Exclusions/Terms: replace if provided\n      const mergedInclusions = patch.inclusions !== undefined ? patch.inclusions : existing?.inclusions;\n      const mergedExclusions = patch.exclusions !== undefined ? patch.exclusions : existing?.exclusions;\n      const mergedTerms = patch.terms !== undefined ? patch.terms : existing?.terms;\n\n      // Build final payload\n      const payload: any = {\n        updated_at: new Date().toISOString(),\n        last_saved: new Date().toISOString(),\n      };\n      if (patch.status !== undefined) payload.status = patch.status;\n      if (patch.version !== undefined) payload.version = patch.version;\n      if (patch.itinerary_data !== undefined) payload.itinerary_data = mergedItinerary;\n      if (patch.pricing_data !== undefined) payload.pricing_data = mergedPricing;\n      if (patch.accommodation_data !== undefined) payload.accommodation_data = mergedAccommodation;\n      if (patch.email_data !== undefined) payload.email_data = mergedEmail;\n      if (patch.inclusions !== undefined) payload.inclusions = mergedInclusions;\n      if (patch.exclusions !== undefined) payload.exclusions = mergedExclusions;\n      if (patch.terms !== undefined) payload.terms = mergedTerms;\n\n      const { data, error } = await sb\n        .from('proposals')\n        .update(payload)\n        .eq('proposal_id', proposalId)\n        .select('id, proposal_id, version, last_saved')\n        .maybeSingle();\n      if (error) return { error };\n      return { data };\n    } catch (e) {\n      return { error: e };\n    }\n  },\n  /**\n   * Delete a proposal or draft row by its proposal_id\n   */\n  async deleteByProposalId(proposalId: string): Promise<{ data?: any; error?: any }> {\n    try {\n      const { data, error } = await sb\n        .from('proposals')\n        .delete()\n        .eq('proposal_id', proposalId)\n        .select('proposal_id')\n        .maybeSingle();\n      if (error) return { error };\n      return { data };\n    } catch (e) {\n      return { error: e };\n    }\n  },\n};\n\nexport default SupabaseProposalService;\n","import { adminSupabase as supabaseAdmin } from '@/lib/supabaseClient';\nimport type { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types';\n\n// Transport Types service using admin client to bypass RLS\nexport const listTransportTypes = async (filters?: {\n  active?: boolean;\n  category?: string;\n}) => {\n  let query = supabaseAdmin\n    .from('transport_types')\n    .select('*')\n    .order('name', { ascending: true });\n\n  if (filters?.active !== undefined) {\n    query = query.eq('active', filters.active);\n  }\n  if (filters?.category) {\n    query = query.ilike('category', filters.category);\n  }\n\n  const { data, error } = await query;\n  if (error) throw error;\n  return (data || []) as Tables<'transport_types'>[];\n};\n\nexport const createTransportType = async (\n  payload: TablesInsert<'transport_types'>\n) => {\n  const { data, error } = await supabaseAdmin\n    .from('transport_types')\n    .insert({\n      name: payload.name,\n      category: payload.category,\n      seating_capacity: payload.seating_capacity ?? 0,\n      luggage_capacity: payload.luggage_capacity ?? 0,\n      active: payload.active ?? true,\n    })\n    .select('*')\n    .single();\n  if (error) throw error;\n  return data as Tables<'transport_types'>;\n};\n\nexport const updateTransportType = async (\n  id: string,\n  payload: TablesUpdate<'transport_types'>\n) => {\n  const { data, error } = await supabaseAdmin\n    .from('transport_types')\n    .update({\n      name: payload.name,\n      category: payload.category,\n      seating_capacity: payload.seating_capacity,\n      luggage_capacity: payload.luggage_capacity,\n      active: payload.active,\n    })\n    .eq('id', id)\n    .select('*')\n    .single();\n  if (error) throw error;\n  return data as Tables<'transport_types'>;\n};\n\nexport const deleteTransportType = async (id: string) => {\n  const { error } = await supabaseAdmin\n    .from('transport_types')\n    .delete()\n    .eq('id', id);\n  if (error) throw error;\n  return true;\n};\n\nexport const toggleTransportTypeActive = async (id: string, active: boolean) => {\n  const { data, error } = await supabaseAdmin\n    .from('transport_types')\n    .update({ active })\n    .eq('id', id)\n    .select('*')\n    .single();\n  if (error) throw error;\n  return data as Tables<'transport_types'>;\n};\n\n// Helpers for mapping between UI and DB fields\nexport function mapTransportTypeRowToUI(\n  row: Tables<'transport_types'>\n): {\n  id: string;\n  name: string;\n  category: string;\n  seatingCapacity: number;\n  luggageCapacity: number;\n  active: boolean;\n} {\n  return {\n    id: row.id,\n    name: row.name,\n    category: row.category,\n    seatingCapacity: row.seating_capacity,\n    luggageCapacity: row.luggage_capacity,\n    active: row.active,\n  };\n}\n\nexport function mapTransportTypeUIToInsert(ui: {\n  name: string;\n  category: string;\n  seatingCapacity: number;\n  luggageCapacity: number;\n  active?: boolean;\n}): TablesInsert<'transport_types'> {\n  return {\n    name: ui.name,\n    category: ui.category,\n    seating_capacity: ui.seatingCapacity,\n    luggage_capacity: ui.luggageCapacity,\n    active: ui.active ?? true,\n  };\n}\n\nexport function mapTransportTypeUIToUpdate(ui: {\n  id: string;\n  name: string;\n  category: string;\n  seatingCapacity: number;\n  luggageCapacity: number;\n  active: boolean;\n}): TablesUpdate<'transport_types'> {\n  return {\n    name: ui.name,\n    category: ui.category,\n    seating_capacity: ui.seatingCapacity,\n    luggage_capacity: ui.luggageCapacity,\n    active: ui.active,\n  };\n}\n\n// Alias for backward compatibility\nexport const mapUIToTransportTypeRow = mapTransportTypeUIToUpdate;","import { adminSupabase as supabaseAdmin, isAdminClientConfigured, supabase } from '@/lib/supabaseClient';\nimport type { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types';\n\nexport type LocationCodeRow = Tables<'location_codes'>;\nexport type LocationCodeInsert = TablesInsert<'location_codes'>;\nexport type LocationCodeUpdate = TablesUpdate<'location_codes'>;\n\ntype ListFilters = {\n  search?: string;\n  country?: string;\n  status?: string;\n  category?: string;\n};\n\nconst table = 'location_codes';\n\nexport const listLocationCodes = async (filters: ListFilters = {}) => {\n  const client = isAdminClientConfigured ? supabaseAdmin : supabase;\n  let query = client.from<LocationCodeRow>(table).select('*').order('code', { ascending: true });\n\n  if (filters.country && filters.country !== 'All') {\n    query = query.eq('country', filters.country);\n  }\n  if (filters.status) {\n    query = query.eq('status', filters.status);\n  }\n  if (filters.category && filters.category !== 'All') {\n    query = query.eq('category', filters.category);\n  }\n  if (filters.search) {\n    // Basic ILIKE across code and full_name\n    const s = `%${filters.search}%`;\n    query = query.or(`code.ilike.${s},full_name.ilike.${s}`);\n  }\n\n  const { data, error } = await query;\n  if (error) throw error;\n  return data || [];\n};\n\nexport const createLocationCode = async (payload: Omit<LocationCodeInsert, 'id' | 'created_at' | 'updated_at'>) => {\n  const client = isAdminClientConfigured ? supabaseAdmin : supabase;\n  const now = new Date().toISOString();\n  const insertData: LocationCodeInsert = { ...payload, status: payload.status ?? 'active', created_at: now, updated_at: now };\n  const { data, error } = await client.from<LocationCodeRow>(table).insert(insertData).select('*').single();\n  if (error) throw error;\n  return data;\n};\n\nexport const updateLocationCode = async (id: string, updates: LocationCodeUpdate) => {\n  const client = isAdminClientConfigured ? supabaseAdmin : supabase;\n  const { data, error } = await client\n    .from<LocationCodeRow>(table)\n    .update({ ...updates, updated_at: new Date().toISOString() })\n    .eq('id', id)\n    .select('*')\n    .single();\n  if (error) throw error;\n  return data;\n};\n\nexport const deleteLocationCode = async (id: string) => {\n  const client = isAdminClientConfigured ? supabaseAdmin : supabase;\n  const { error } = await client.from<LocationCodeRow>(table).delete().eq('id', id);\n  if (error) throw error;\n  return true;\n};\n\nexport const toggleLocationCodeStatus = async (id: string, status: 'active' | 'inactive') => {\n  return updateLocationCode(id, { status });\n};","import { TaxConfiguration, TaxCalculationResult, TaxBreakdownItem } from '@/types/taxManagement';\nimport { PricingConfigurationService } from '@/integrations/supabase/services/pricingConfigurationService';\nimport { TaxConfigurationSupabase, toUI, fromUI } from '@/integrations/supabase/services/taxConfigurationService';\nimport { CountriesService } from '@/integrations/supabase/services/countriesService';\n\n// Default tax configurations for common countries\nconst DEFAULT_TAX_CONFIGURATIONS: TaxConfiguration[] = [\n  {\n    id: 'IN',\n    countryCode: 'IN',\n    taxType: 'GST',\n    isActive: true,\n    taxRates: [\n      { id: 'gst-transport', serviceType: 'transport', rate: 5, description: 'Transport Services GST', isDefault: false },\n      { id: 'gst-hotel', serviceType: 'hotel', rate: 18, description: 'Hotel Services GST', isDefault: false },\n      { id: 'gst-sightseeing', serviceType: 'sightseeing', rate: 18, description: 'Sightseeing Services GST', isDefault: false },\n      { id: 'gst-restaurant', serviceType: 'restaurant', rate: 5, description: 'Restaurant Services GST', isDefault: false },\n      { id: 'gst-all', serviceType: 'all', rate: 18, description: 'General Tourism Services GST', isDefault: true }\n    ],\n    tdsConfiguration: {\n      isApplicable: true,\n      rate: 2,\n      threshold: 50000,\n      exemptionLimit: 40000\n    },\n    exemptions: [],\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  },\n  {\n    id: 'AE',\n    countryCode: 'AE',\n    taxType: 'VAT',\n    isActive: true,\n    taxRates: [\n      { id: 'vat-all', serviceType: 'all', rate: 5, description: 'UAE VAT', isDefault: true }\n    ],\n    exemptions: [],\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  },\n  {\n    id: 'US',\n    countryCode: 'US',\n    taxType: 'SALES_TAX',\n    isActive: true,\n    taxRates: [\n      { id: 'sales-all', serviceType: 'all', rate: 8.5, description: 'Sales Tax', isDefault: true }\n    ],\n    exemptions: [],\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  },\n  {\n    id: 'GB',\n    countryCode: 'GB',\n    taxType: 'VAT',\n    isActive: true,\n    taxRates: [\n      { id: 'vat-all', serviceType: 'all', rate: 20, description: 'UK VAT', isDefault: true }\n    ],\n    exemptions: [],\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  }\n];\n\nexport class TaxCalculationService {\n  private static taxConfigurations: TaxConfiguration[] = DEFAULT_TAX_CONFIGURATIONS;\n  private static initializedFromSupabase = false;\n  private static currentConfigId: string | undefined;\n  private static defaultCountry: string = 'IN';\n  private static countryNameMap: Record<string, string> = {};\n\n  /**\n   * Initialize tax configurations from Supabase pricing configuration + tax tables.\n   * Falls back to built-in defaults if Supabase is unavailable.\n   */\n  static async initializeFromSupabase(): Promise<void> {\n    try {\n      let config = await PricingConfigurationService.getDefaultConfiguration();\n      if (!config) {\n        try {\n          // Seed a default pricing configuration to ensure tax can bind to a config_id\n          config = await PricingConfigurationService.setDefaultConfiguration(this.defaultCountry);\n        } catch (seedErr) {\n          console.warn('Failed to seed default pricing configuration for tax initialization.', seedErr);\n        }\n        if (!config) {\n          this.initializedFromSupabase = false;\n          return;\n        }\n      }\n      this.currentConfigId = config.id;\n      this.defaultCountry = config.default_country || this.defaultCountry;\n      let rows = await TaxConfigurationSupabase.listByConfig(config.id);\n      let mapped = rows.map((r) => toUI(r));\n\n      // If table is empty, seed defaults directly into Supabase instead of falling back\n      if (mapped.length === 0) {\n        try {\n          for (const def of DEFAULT_TAX_CONFIGURATIONS) {\n            const row = fromUI(def, config.id);\n            await TaxConfigurationSupabase.upsert(config.id, row);\n          }\n          rows = await TaxConfigurationSupabase.listByConfig(config.id);\n          mapped = rows.map((r) => toUI(r));\n        } catch (seedErr) {\n          console.warn('Failed to seed default tax configurations to Supabase.', seedErr);\n        }\n      }\n\n      if (mapped.length > 0) {\n        this.taxConfigurations = mapped;\n        this.initializedFromSupabase = true;\n      }\n      // Hydrate country names for UI dropdowns\n      const countries = await CountriesService.listActiveCountries();\n      this.countryNameMap = Object.fromEntries(countries.map((c) => [c.code, c.name]));\n    } catch (err) {\n      // Keep defaults on any error\n      this.initializedFromSupabase = false;\n    }\n  }\n\n  static getTaxConfigurations(): TaxConfiguration[] {\n    return this.taxConfigurations;\n  }\n\n  static getTaxConfiguration(countryCode: string): TaxConfiguration | undefined {\n    return this.taxConfigurations.find(\n      config => config.countryCode === countryCode && config.isActive\n    );\n  }\n\n  static getDefaultCountry(): string {\n    return this.defaultCountry;\n  }\n\n  static getAvailableCountries(): Array<{ code: string; name: string; taxType: string }> {\n    return this.taxConfigurations.map((config) => ({\n      code: config.countryCode,\n      name: this.countryNameMap[config.countryCode] || config.countryCode,\n      taxType: config.taxType,\n    }));\n  }\n\n  static detectCountryFromCurrency(currency: string): string {\n    const currencyToCountry: Record<string, string> = {\n      'INR': 'IN',\n      'AED': 'AE',\n      'USD': 'US',\n      'GBP': 'GB'\n    };\n    return currencyToCountry[currency] || this.getDefaultCountry();\n  }\n\n  static initializeDefaultConfigurations(): void {\n    // Keep defaults available immediately; async Supabase init can override after\n    if (this.taxConfigurations.length === 0) {\n      this.taxConfigurations = DEFAULT_TAX_CONFIGURATIONS;\n    }\n    // Fire-and-forget async hydration (components may optionally await initializeFromSupabase instead)\n    this.initializeFromSupabase().catch(() => {\n      /* ignore */\n    });\n  }\n\n  static calculateTax(\n    baseAmount: number,\n    countryCode: string,\n    serviceType: string = 'all',\n    isInclusive: boolean = false\n  ): TaxCalculationResult {\n    const config = this.getTaxConfiguration(countryCode);\n    \n    if (!config) {\n      return {\n        baseAmount,\n        taxAmount: 0,\n        totalAmount: baseAmount,\n        taxBreakdown: [],\n        isInclusive\n      };\n    }\n\n    // Find applicable tax rate\n    const taxRate = config.taxRates.find(\n      rate => rate.serviceType === serviceType || (rate.serviceType === 'all' && rate.isDefault)\n    ) || config.taxRates.find(rate => rate.isDefault);\n\n    if (!taxRate) {\n      return {\n        baseAmount,\n        taxAmount: 0,\n        totalAmount: baseAmount,\n        taxBreakdown: [],\n        isInclusive\n      };\n    }\n\n    let taxableAmount = baseAmount;\n    let taxAmount = 0;\n    let totalAmount = baseAmount;\n    let tdsAmount = 0;\n\n    if (isInclusive) {\n      // Tax is included in the amount\n      taxableAmount = baseAmount / (1 + taxRate.rate / 100);\n      taxAmount = baseAmount - taxableAmount;\n      totalAmount = baseAmount;\n    } else {\n      // Tax is additional to the amount\n      taxableAmount = baseAmount;\n      taxAmount = baseAmount * (taxRate.rate / 100);\n      totalAmount = baseAmount + taxAmount;\n    }\n\n    // Calculate TDS if applicable\n    if (config.tdsConfiguration?.isApplicable && totalAmount > config.tdsConfiguration.threshold) {\n      tdsAmount = totalAmount * (config.tdsConfiguration.rate / 100);\n    }\n\n    const taxBreakdown: TaxBreakdownItem[] = [\n      {\n        type: config.taxType,\n        rate: taxRate.rate,\n        amount: taxAmount,\n        description: taxRate.description\n      }\n    ];\n\n    if (tdsAmount > 0) {\n      taxBreakdown.push({\n        type: 'TDS',\n        rate: config.tdsConfiguration!.rate,\n        amount: tdsAmount,\n        description: 'Tax Deducted at Source'\n      });\n    }\n\n    return {\n      baseAmount: taxableAmount,\n      taxAmount,\n      tdsAmount: tdsAmount > 0 ? tdsAmount : undefined,\n      totalAmount: totalAmount - (tdsAmount || 0),\n      taxBreakdown,\n      isInclusive\n    };\n  }\n\n  static addTaxConfiguration(config: TaxConfiguration): void {\n    this.taxConfigurations.push(config);\n  }\n\n  static async updateTaxConfiguration(configOrCountryCode: TaxConfiguration | string, config?: Partial<TaxConfiguration>): Promise<void> {\n    if (typeof configOrCountryCode === 'string') {\n      // Legacy method signature: updateTaxConfiguration(countryCode, config)\n      const countryCode = configOrCountryCode;\n      const index = this.taxConfigurations.findIndex(c => c.countryCode === countryCode);\n      if (index !== -1 && config) {\n        this.taxConfigurations[index] = { ...this.taxConfigurations[index], ...config };\n      }\n    } else {\n      // New method signature: updateTaxConfiguration(config)\n      const fullConfig = configOrCountryCode;\n      const index = this.taxConfigurations.findIndex(c => c.countryCode === fullConfig.countryCode);\n      if (index !== -1) {\n        this.taxConfigurations[index] = fullConfig;\n      }\n    }\n\n    // Persist to Supabase if initialized with a known configuration\n    try {\n      if (this.currentConfigId) {\n        const cfg = typeof configOrCountryCode === 'string'\n          ? this.taxConfigurations.find(c => c.countryCode === configOrCountryCode)\n          : configOrCountryCode;\n        if (cfg) {\n          const row = fromUI(cfg, this.currentConfigId);\n          await TaxConfigurationSupabase.upsert(this.currentConfigId, row);\n        }\n      }\n    } catch {\n      // Swallow errors to avoid interrupting UI; local state remains updated\n    }\n  }\n\n  // Exposed getters for UI tracking/debug\n  static isInitializedFromSupabase(): boolean {\n    return this.initializedFromSupabase;\n  }\n\n  static getCurrentConfigId(): string | undefined {\n    return this.currentConfigId;\n  }\n}","\nimport { MarkupSlab, PricingSettings, CurrencyRate, ModulePricing } from '@/types/pricing';\nimport { PricingConfigurationService } from '@/integrations/supabase/services/pricingConfigurationService';\n\nexport class PricingService {\n  private static settings: PricingSettings = {\n    defaultMarkupPercentage: 7,\n    useSlabPricing: false,\n    slabApplicationMode: 'per-person',\n    markupSlabs: [\n      {\n        id: '1',\n        name: 'Budget Range',\n        minAmount: 1000,\n        maxAmount: 5000,\n        markupType: 'fixed',\n        markupValue: 100,\n        currency: 'THB',\n        isActive: true,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      },\n      {\n        id: '2',\n        name: 'Mid Range',\n        minAmount: 5001,\n        maxAmount: 15000,\n        markupType: 'percentage',\n        markupValue: 8,\n        currency: 'THB',\n        isActive: true,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      },\n      {\n        id: '3',\n        name: 'Luxury Range',\n        minAmount: 15001,\n        maxAmount: 999999,\n        markupType: 'percentage',\n        markupValue: 10,\n        currency: 'THB',\n        isActive: true,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      }\n    ],\n    showPricingToAgents: true,\n    showPricingToStaff: true,\n    allowStaffPricingEdit: true\n  };\n\n  static getSettings(): PricingSettings {\n    // Supabase-only: hydrate from pricing_configurations\n    // Synchronous fallback removed; callers should handle async contexts upstream\n    // For legacy synchronous usage, return last cached value but refresh in background\n    (async () => {\n      try {\n        let cfg = await PricingConfigurationService.getDefaultConfiguration();\n        if (!cfg) {\n          cfg = await PricingConfigurationService.setDefaultConfiguration('TH');\n        }\n        const mapped = await PricingConfigurationService.toPricingSettings(cfg);\n        if (mapped) this.settings = mapped;\n      } catch (err) {\n        console.warn('PricingService: failed to hydrate settings from Supabase', err);\n      }\n    })();\n    return this.settings;\n  }\n\n  static updateSettings(settings: Partial<PricingSettings>): void {\n    // Supabase-only: upsert configuration\n    (async () => {\n      try {\n        const countryCode = 'TH'; // default tie-in; UI maintains default country elsewhere\n        const row = await PricingConfigurationService.upsertConfiguration({\n          country_code: countryCode,\n          base_markup_percentage: settings.defaultMarkupPercentage,\n          slab_markup_enabled: settings.useSlabPricing,\n        } as any);\n        const mapped = await PricingConfigurationService.toPricingSettings(row);\n        if (mapped) this.settings = mapped;\n        // Emit event for real-time updates\n        window.dispatchEvent(new CustomEvent('pricing-settings-updated', {\n          detail: this.settings\n        }));\n      } catch (err) {\n        console.warn('PricingService: failed to persist settings to Supabase', err);\n      }\n    })();\n  }\n\n  static calculateMarkup(basePrice: number, paxCount: number, currency: string = 'THB'): ModulePricing {\n    const settings = this.getSettings();\n    \n    // Validate inputs\n    if (basePrice <= 0 || paxCount <= 0) {\n      return {\n        basePrice: 0,\n        markup: 0,\n        markupType: 'percentage',\n        finalPrice: 0,\n        currency,\n        perPersonPrice: 0,\n        totalPrice: 0\n      };\n    }\n    \n    const perPersonPrice = basePrice / paxCount;\n    let markup = 0;\n    let markupType: 'percentage' | 'fixed' | 'slab' = 'percentage';\n\n    if (settings.useSlabPricing) {\n      const comparisonAmount = settings.slabApplicationMode === 'per-person' \n        ? perPersonPrice \n        : basePrice;\n        \n      const applicableSlab = settings.markupSlabs.find(slab => \n        slab.isActive && \n        slab.currency === currency &&\n        comparisonAmount >= slab.minAmount && \n        comparisonAmount <= slab.maxAmount\n      );\n\n      if (applicableSlab) {\n        markupType = 'slab';\n        if (applicableSlab.markupType === 'fixed') {\n          markup = applicableSlab.markupValue * paxCount;\n        } else {\n          markup = (basePrice * applicableSlab.markupValue) / 100;\n        }\n      } else {\n        markup = (basePrice * settings.defaultMarkupPercentage) / 100;\n      }\n    } else {\n      markup = (basePrice * settings.defaultMarkupPercentage) / 100;\n    }\n\n    const finalPrice = Math.round((basePrice + markup) * 100) / 100;\n\n    return {\n      basePrice,\n      markup: Math.round(markup * 100) / 100,\n      markupType,\n      finalPrice,\n      currency,\n      perPersonPrice: Math.round((finalPrice / paxCount) * 100) / 100,\n      totalPrice: finalPrice\n    };\n  }\n\n  static convertCurrency(amount: number, fromCurrency: string, toCurrency: string): number {\n    // Enhanced exchange rates with more currencies\n    const rates: { [key: string]: number } = {\n      // THB conversions\n      'THB_USD': 0.028,\n      'USD_THB': 35.7,\n      'THB_EUR': 0.026,\n      'EUR_THB': 38.5,\n      'THB_AED': 0.103,\n      'AED_THB': 9.7,\n      'THB_SGD': 0.037,\n      'SGD_THB': 27.0,\n      'THB_INR': 2.4,\n      'INR_THB': 0.42,\n      'THB_GBP': 0.022,\n      'GBP_THB': 45.2,\n      \n      // USD conversions\n      'USD_EUR': 0.92,\n      'EUR_USD': 1.09,\n      'USD_AED': 3.67,\n      'AED_USD': 0.27,\n      'USD_SGD': 1.35,\n      'SGD_USD': 0.74,\n      'USD_INR': 84.5,\n      'INR_USD': 0.012,\n      'USD_GBP': 0.79,\n      'GBP_USD': 1.27,\n      \n      // Cross rates\n      'AED_SGD': 0.37,\n      'SGD_AED': 2.72,\n      'INR_AED': 0.043,\n      'AED_INR': 23.0,\n      'EUR_GBP': 0.86,\n      'GBP_EUR': 1.16\n    };\n\n    if (fromCurrency === toCurrency) return amount;\n    \n    const rateKey = `${fromCurrency}_${toCurrency}`;\n    const directRate = rates[rateKey];\n    \n    if (directRate) {\n      return Math.round(amount * directRate * 100) / 100;\n    }\n    \n    // If no direct rate, try conversion through USD\n    const toUSDKey = `${fromCurrency}_USD`;\n    const fromUSDKey = `USD_${toCurrency}`;\n    \n    if (rates[toUSDKey] && rates[fromUSDKey]) {\n      const usdAmount = amount * rates[toUSDKey];\n      return Math.round(usdAmount * rates[fromUSDKey] * 100) / 100;\n    }\n    \n    console.warn(`No conversion rate found for ${fromCurrency} to ${toCurrency}, returning original amount`);\n    return amount;\n  }\n}\n","\nimport { initialCountries } from '@/pages/inventory/countries/data/countryData';\nimport { getPricingCurrencyByCountryName, getPricingCurrencyByCountryCode } from '@/pages/inventory/countries/utils/currencyUtils';\n\nexport interface CountryCurrency {\n  countryCode: string;\n  countryName: string;\n  currency: string;\n  currencySymbol: string;\n  pricingCurrency?: string;\n  pricingCurrencySymbol?: string;\n}\n\nexport class CountryCurrencyService {\n  /**\n   * Get currency information by country name\n   */\n  static getCurrencyByCountryName(countryName: string): { code: string; symbol: string } {\n    console.log('CountryCurrencyService: Getting currency for country:', countryName);\n    \n    // First try to get from countries module with pricing currency override\n    const pricingCurrency = getPricingCurrencyByCountryName(countryName);\n    if (pricingCurrency.code !== 'USD' || pricingCurrency.symbol !== '$') {\n      console.log('Using pricing currency override:', pricingCurrency);\n      return pricingCurrency;\n    }\n\n    // Fallback to initialCountries data\n    const country = initialCountries.find(c => \n      c.name.toLowerCase() === countryName.toLowerCase() ||\n      c.name.toLowerCase().includes(countryName.toLowerCase()) ||\n      countryName.toLowerCase().includes(c.name.toLowerCase())\n    );\n\n    if (country) {\n      console.log('Found country in initialCountries:', country);\n      return {\n        code: country.currency,\n        symbol: country.currencySymbol\n      };\n    }\n\n    console.log('Country not found, using default USD');\n    return { code: 'USD', symbol: '$' };\n  }\n\n  /**\n   * Get currency information by country code\n   */\n  static getCurrencyByCountryCode(countryCode: string): { code: string; symbol: string } {\n    console.log('CountryCurrencyService: Getting currency for country code:', countryCode);\n    \n    // First try to get from countries module with pricing currency override\n    const pricingCurrency = getPricingCurrencyByCountryCode(countryCode);\n    if (pricingCurrency.code !== 'USD' || pricingCurrency.symbol !== '$') {\n      console.log('Using pricing currency override:', pricingCurrency);\n      return pricingCurrency;\n    }\n\n    // Fallback to initialCountries data\n    const country = initialCountries.find(c => c.code === countryCode);\n    if (country) {\n      console.log('Found country in initialCountries:', country);\n      return {\n        code: country.currency,\n        symbol: country.currencySymbol\n      };\n    }\n\n    console.log('Country code not found, using default USD');\n    return { code: 'USD', symbol: '$' };\n  }\n\n  /**\n   * Get all available countries with their currency information\n   */\n  static getAllCountriesWithCurrency(): CountryCurrency[] {\n    return initialCountries.map(country => ({\n      countryCode: country.code,\n      countryName: country.name,\n      currency: country.currency,\n      currencySymbol: country.currencySymbol,\n      pricingCurrency: country.pricingCurrencyOverride ? country.pricingCurrency : undefined,\n      pricingCurrencySymbol: country.pricingCurrencyOverride ? country.pricingCurrencySymbol : undefined\n    }));\n  }\n\n  /**\n   * Check if a country has pricing currency override\n   */\n  static hasPricingCurrencyOverride(countryName: string): boolean {\n    const country = initialCountries.find(c => \n      c.name.toLowerCase() === countryName.toLowerCase()\n    );\n    return country?.pricingCurrencyOverride || false;\n  }\n\n  /**\n   * Format currency amount with proper symbol\n   */\n  static formatCurrency(amount: number, countryName: string): string {\n    const currency = this.getCurrencyByCountryName(countryName);\n    return `${currency.symbol}${amount.toLocaleString('en-US', {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2\n    })}`;\n  }\n\n  /**\n   * Get effective currency for pricing (considers overrides)\n   */\n  static getEffectiveCurrency(countryName: string): { code: string; symbol: string; isOverride: boolean } {\n    const country = initialCountries.find(c => \n      c.name.toLowerCase() === countryName.toLowerCase()\n    );\n\n    if (country?.pricingCurrencyOverride && country.pricingCurrency) {\n      return {\n        code: country.pricingCurrency,\n        symbol: country.pricingCurrencySymbol || '$',\n        isOverride: true\n      };\n    }\n\n    if (country) {\n      return {\n        code: country.currency,\n        symbol: country.currencySymbol,\n        isOverride: false\n      };\n    }\n\n    return {\n      code: 'USD',\n      symbol: '$',\n      isOverride: false\n    };\n  }\n}\n","\nimport { PricingService } from './pricingService';\nimport { EnhancedPricingSettings, CountryPricingCalculation, BulkPricingOperation } from '@/types/enhancedPricing';\nimport { CountryPricingRule, RegionalPricingTemplate } from '@/types/countryPricing';\nimport { CountryCurrencyService } from './countryCurrencyService';\nimport { initialCountries } from '@/pages/inventory/countries/data/countryData';\nimport { PricingConfigurationService } from '@/integrations/supabase/services/pricingConfigurationService';\n\nexport class EnhancedPricingService extends PricingService {\n  private static enhancedSettings: EnhancedPricingSettings = {\n    ...PricingService.getSettings(),\n    countryRules: [\n      {\n        id: '1',\n        countryCode: 'TH',\n        countryName: 'Thailand',\n        currency: 'THB',\n        currencySymbol: '',\n        defaultMarkup: 8,\n        markupType: 'percentage',\n        isActive: true,\n        region: 'Southeast Asia',\n        tier: 'standard',\n        conversionMargin: 2,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      },\n      {\n        id: '2',\n        countryCode: 'AE',\n        countryName: 'UAE',\n        currency: 'AED',\n        currencySymbol: '.',\n        defaultMarkup: 10,\n        markupType: 'percentage',\n        isActive: true,\n        region: 'Middle East',\n        tier: 'premium',\n        conversionMargin: 1.5,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      },\n      {\n        id: '3',\n        countryCode: 'SG',\n        countryName: 'Singapore',\n        currency: 'SGD',\n        currencySymbol: 'S$',\n        defaultMarkup: 12,\n        markupType: 'percentage',\n        isActive: true,\n        region: 'Southeast Asia',\n        tier: 'luxury',\n        conversionMargin: 1.8,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      }\n    ],\n    regionalTemplates: [\n      {\n        id: '1',\n        name: 'Southeast Asia Standard',\n        region: 'Southeast Asia',\n        description: 'Standard pricing for Southeast Asian destinations',\n        defaultMarkup: 8,\n        markupType: 'percentage',\n        countries: ['TH', 'MY', 'ID', 'VN'],\n        isActive: true\n      },\n      {\n        id: '2',\n        name: 'Premium Middle East',\n        region: 'Middle East',\n        description: 'Premium pricing for Middle Eastern destinations',\n        defaultMarkup: 12,\n        markupType: 'percentage',\n        countries: ['AE', 'QA', 'KW'],\n        isActive: true\n      }\n    ],\n    currencyConversion: {\n      baseCurrency: 'USD',\n      autoUpdateRates: false,\n      updateFrequency: 'daily',\n      fallbackRates: {\n        'THB_USD': 0.028,\n        'USD_THB': 35.7,\n        'AED_USD': 0.27,\n        'USD_AED': 3.67,\n        'SGD_USD': 0.74,\n        'USD_SGD': 1.35\n      },\n      conversionMargins: {\n        'THB': 2,\n        'AED': 1.5,\n        'SGD': 1.8,\n        'MYR': 2.2,\n        'USD': 1,\n        'EUR': 1.2\n      }\n    },\n    enableCountryBasedPricing: true,\n    defaultCountry: 'TH',\n    popularDestinations: ['TH', 'AE', 'SG', 'MY', 'US', 'FR']\n  };\n\n  static getEnhancedSettings(): EnhancedPricingSettings {\n    // Supabase-only: hydrate base pricing settings and merge enhanced fields (not persisted)\n    (async () => {\n      try {\n        let cfg = await PricingConfigurationService.getDefaultConfiguration();\n        if (!cfg) {\n          cfg = await PricingConfigurationService.setDefaultConfiguration('TH');\n        }\n        const mapped = await PricingConfigurationService.toPricingSettings(cfg);\n        if (mapped) {\n          this.enhancedSettings = {\n            ...this.enhancedSettings,\n            ...mapped,\n          };\n        }\n      } catch (err) {\n        console.warn('EnhancedPricingService: failed to hydrate from Supabase', err);\n      }\n    })();\n    return this.enhancedSettings;\n  }\n\n  static updateEnhancedSettings(settings: Partial<EnhancedPricingSettings>): void {\n    // Supabase-only: persist base pricing-related fields; enhanced fields remain in-memory\n    (async () => {\n      try {\n        const row = await PricingConfigurationService.upsertConfiguration({\n          country_code: 'TH',\n          base_markup_percentage: settings.defaultMarkupPercentage,\n          slab_markup_enabled: settings.useSlabPricing,\n        } as any);\n        const mapped = await PricingConfigurationService.toPricingSettings(row);\n        if (mapped) {\n          this.enhancedSettings = { ...this.enhancedSettings, ...mapped, ...settings };\n        } else {\n          this.enhancedSettings = { ...this.enhancedSettings, ...settings };\n        }\n      } catch (err) {\n        console.warn('EnhancedPricingService: failed to persist settings to Supabase', err);\n        this.enhancedSettings = { ...this.enhancedSettings, ...settings };\n      }\n    })();\n  }\n\n  static getCountryRule(countryCode: string): CountryPricingRule | null {\n    const settings = this.getEnhancedSettings();\n    return settings.countryRules.find(rule => rule.countryCode === countryCode && rule.isActive) || null;\n  }\n\n  static calculateCountryBasedPricing(\n    basePrice: number, \n    paxCount: number, \n    countryCode: string,\n    targetCurrency?: string\n  ): CountryPricingCalculation {\n    const settings = this.getEnhancedSettings();\n    const countryRule = this.getCountryRule(countryCode);\n    \n    // Validate inputs\n    if (basePrice <= 0 || paxCount <= 0) {\n      return {\n        basePrice: 0,\n        markup: 0,\n        markupType: 'country-based',\n        finalPrice: 0,\n        currency: targetCurrency || 'USD',\n        perPersonPrice: 0,\n        totalPrice: 0,\n        countryCode,\n        originalCurrency: targetCurrency || 'USD',\n        convertedCurrency: targetCurrency || 'USD',\n        conversionRate: 1,\n        conversionMargin: 0,\n        regionalAdjustment: 0,\n        tierMultiplier: 1\n      };\n    }\n    \n    if (!countryRule || !settings.enableCountryBasedPricing) {\n      // Use the centralized currency service to get the proper currency for the country\n      const countryInfo = CountryCurrencyService.getCurrencyByCountryCode(countryCode);\n      const currency = targetCurrency || countryInfo.code;\n      \n      const standardCalc = this.calculateMarkup(basePrice, paxCount, currency);\n      return {\n        ...standardCalc,\n        countryCode,\n        originalCurrency: currency,\n        convertedCurrency: currency,\n        conversionRate: 1,\n        conversionMargin: 0,\n        regionalAdjustment: 0,\n        tierMultiplier: 1\n      };\n    }\n\n    let markup = 0;\n    const perPersonPrice = basePrice / paxCount;\n\n    // Apply country-specific markup\n    if (countryRule.markupType === 'fixed') {\n      markup = countryRule.defaultMarkup * paxCount;\n    } else {\n      markup = (basePrice * countryRule.defaultMarkup) / 100;\n    }\n\n    // Apply tier multiplier\n    const tierMultipliers = {\n      budget: 0.8,\n      standard: 1,\n      premium: 1.2,\n      luxury: 1.5\n    };\n    const tierMultiplier = tierMultipliers[countryRule.tier] || 1;\n    markup *= tierMultiplier;\n\n    // Apply seasonal adjustment if available\n    if (countryRule.seasonalAdjustment) {\n      markup *= (1 + countryRule.seasonalAdjustment / 100);\n    }\n\n    // Currency conversion if needed\n    let convertedPrice = basePrice + markup;\n    let conversionRate = 1;\n    const targetCurr = targetCurrency || countryRule.currency;\n    \n    if (targetCurr !== countryRule.currency) {\n      const rateKey = `${countryRule.currency}_${targetCurr}`;\n      conversionRate = settings.currencyConversion.fallbackRates[rateKey] || 1;\n      const conversionMargin = settings.currencyConversion.conversionMargins[targetCurr] || 0;\n      convertedPrice = (convertedPrice * conversionRate) * (1 + conversionMargin / 100);\n    }\n\n    // Round all monetary values to 2 decimal places\n    const finalPrice = Math.round(convertedPrice * 100) / 100;\n    const roundedMarkup = Math.round(markup * 100) / 100;\n\n    return {\n      basePrice,\n      markup: roundedMarkup,\n      markupType: 'country-based',\n      finalPrice,\n      currency: targetCurr,\n      perPersonPrice: Math.round((finalPrice / paxCount) * 100) / 100,\n      totalPrice: finalPrice,\n      countryCode,\n      originalCurrency: countryRule.currency,\n      convertedCurrency: targetCurr,\n      conversionRate,\n      conversionMargin: settings.currencyConversion.conversionMargins[targetCurr] || 0,\n      regionalAdjustment: countryRule.seasonalAdjustment || 0,\n      tierMultiplier\n    };\n  }\n\n  static createCountryRule(rule: Omit<CountryPricingRule, 'id' | 'createdAt' | 'updatedAt'>): CountryPricingRule {\n    // Generate a robust unique ID to avoid duplicate keys in React lists\n    const uniqueId = ((): string => {\n      try {\n        // Prefer crypto.randomUUID when available for strong uniqueness\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const c: any = (globalThis as unknown as { crypto?: { randomUUID?: () => string } }).crypto;\n        if (c?.randomUUID) {\n          return `country_${c.randomUUID()}`;\n        }\n      } catch {\n        // Fall through to timestamp/random\n      }\n      const rand = Math.floor(Math.random() * 1e9);\n      return `country_${rule.countryCode}_${Date.now()}_${rand}`;\n    })();\n\n    const newRule: CountryPricingRule = {\n      ...rule,\n      id: uniqueId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n\n    const settings = this.getEnhancedSettings();\n    const updatedRules = [...settings.countryRules, newRule];\n    this.updateEnhancedSettings({ countryRules: updatedRules });\n\n    return newRule;\n  }\n\n  static updateCountryRule(ruleId: string, updates: Partial<CountryPricingRule>): void {\n    const settings = this.getEnhancedSettings();\n    const updatedRules = settings.countryRules.map(rule => \n      rule.id === ruleId \n        ? { ...rule, ...updates, updatedAt: new Date().toISOString() }\n        : rule\n    );\n    this.updateEnhancedSettings({ countryRules: updatedRules });\n  }\n\n  static deleteCountryRule(ruleId: string): void {\n    const settings = this.getEnhancedSettings();\n    const updatedRules = settings.countryRules.filter(rule => rule.id !== ruleId);\n    this.updateEnhancedSettings({ countryRules: updatedRules });\n  }\n\n  static applyRegionalTemplate(templateId: string, targetCountries: string[]): void {\n    const settings = this.getEnhancedSettings();\n    const template = settings.regionalTemplates.find(t => t.id === templateId);\n    \n    if (!template) return;\n\n    targetCountries.forEach(countryCode => {\n      const country = initialCountries.find(c => c.code === countryCode);\n      if (!country) return;\n\n      const existingRule = this.getCountryRule(countryCode);\n      if (existingRule) {\n        this.updateCountryRule(existingRule.id, {\n          defaultMarkup: template.defaultMarkup,\n          markupType: template.markupType\n        });\n      } else {\n        // Use centralized currency service for accurate currency information\n        const currencyInfo = CountryCurrencyService.getCurrencyByCountryCode(countryCode);\n        this.createCountryRule({\n          countryCode,\n          countryName: country.name,\n          currency: currencyInfo.code,\n          currencySymbol: currencyInfo.symbol,\n          defaultMarkup: template.defaultMarkup,\n          markupType: template.markupType,\n          isActive: true,\n          region: country.region,\n          tier: 'standard',\n          conversionMargin: 2\n        });\n      }\n    });\n  }\n\n  static performBulkOperation(operation: BulkPricingOperation): void {\n    const settings = this.getEnhancedSettings();\n    \n    operation.targetCountries.forEach(countryCode => {\n      const existingRule = this.getCountryRule(countryCode);\n      \n      if (operation.operation === 'set') {\n        if (existingRule) {\n          this.updateCountryRule(existingRule.id, {\n            defaultMarkup: operation.adjustmentValue,\n            markupType: operation.adjustmentType\n          });\n        }\n      } else if (operation.operation === 'adjust' && existingRule) {\n        let newMarkup = existingRule.defaultMarkup;\n        if (operation.adjustmentType === 'percentage') {\n          newMarkup += (newMarkup * operation.adjustmentValue / 100);\n        } else {\n          newMarkup += operation.adjustmentValue;\n        }\n        \n        this.updateCountryRule(existingRule.id, {\n          defaultMarkup: Math.max(0, newMarkup)\n        });\n      }\n    });\n  }\n\n  static getAvailableCountries() {\n    // Use the centralized CountryCurrencyService to get currency information\n    return CountryCurrencyService.getAllCountriesWithCurrency().map(country => ({\n      code: country.countryCode,\n      name: country.countryName,\n      currency: country.pricingCurrency || country.currency,\n      currencySymbol: country.pricingCurrencySymbol || country.currencySymbol,\n      region: initialCountries.find(c => c.code === country.countryCode)?.region || 'Unknown'\n    }));\n  }\n}\n","import { AppSettingsService, SETTING_CATEGORIES } from '@/services/appSettingsService_database';\n\nexport interface SMTPConfig {\n  smtp_host?: string;\n  smtp_port?: number | string;\n  smtp_secure?: boolean | string;\n  smtp_user?: string;\n  smtp_password?: string;\n  from_email?: string;\n  from_name?: string;\n}\n\nexport async function loadSMTPConfig(): Promise<SMTPConfig> {\n  try {\n    console.log(' Loading SMTP configuration from app settings...');\n    \n    const [host, port, secure, user, password, fromEmail, fromName] = await Promise.all([\n      AppSettingsService.getSettingValue(SETTING_CATEGORIES.NOTIFICATIONS, 'smtp_host'),\n      AppSettingsService.getSettingValue(SETTING_CATEGORIES.NOTIFICATIONS, 'smtp_port'),\n      AppSettingsService.getSettingValue(SETTING_CATEGORIES.NOTIFICATIONS, 'smtp_secure'),\n      AppSettingsService.getSettingValue(SETTING_CATEGORIES.NOTIFICATIONS, 'smtp_user'),\n      AppSettingsService.getSettingValue(SETTING_CATEGORIES.NOTIFICATIONS, 'smtp_password'),\n      AppSettingsService.getSettingValue(SETTING_CATEGORIES.NOTIFICATIONS, 'from_email'),\n      AppSettingsService.getSettingValue(SETTING_CATEGORIES.NOTIFICATIONS, 'from_name'),\n    ]);\n\n    console.log(' SMTP config loaded:', {\n      host: host ? '' : '',\n      port: port ? '' : '',\n      secure: secure ? '' : '',\n      user: user ? '' : '',\n      password: password ? '' : '',\n      fromEmail: fromEmail ? '' : '',\n      fromName: fromName ? '' : ''\n    });\n\n    return {\n      smtp_host: host as string | undefined,\n      smtp_port: (port as any) ?? undefined,\n      smtp_secure: (secure as any) ?? undefined,\n      smtp_user: user as string | undefined,\n      smtp_password: password as string | undefined,\n      from_email: (fromEmail as string) || undefined,\n      from_name: (fromName as string) || undefined,\n    };\n  } catch (e) {\n    console.warn(' Failed to load SMTP config from settings, using empty config:', e.message);\n    return {};\n  }\n}\n\nexport async function sendEmail(to: string, subject: string, html: string, configOverride?: SMTPConfig) {\n  try {\n    console.log(' Email service: Starting email send...');\n    console.log(' To:', to);\n    console.log(' Subject:', subject);\n    console.log(' Has HTML:', !!html);\n    \n    const baseConfig = await loadSMTPConfig();\n    const config: SMTPConfig = { ...baseConfig, ...(configOverride || {}) };\n    console.log(' Config loaded:', Object.keys(config));\n    \n    // Resolve email server URL/port with env override and sensible defaults\n    const port = (import.meta as any).env?.VITE_EMAIL_SERVER_PORT || 3003;\n    const baseUrl = (import.meta as any).env?.VITE_EMAIL_SERVER_URL || `http://localhost:${port}`;\n    console.log(' Email server URL:', `${baseUrl}/send-email`);\n\n    console.log(' Sending request to email server...');\n    const res = await fetch(`${baseUrl}/send-email`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ to, subject, html, config })\n    });\n\n    console.log(' Email server response status:', res.status);\n\n    if (!res.ok) {\n      console.error(' Email server error response:', res.status, res.statusText);\n      const err = await res.json().catch(() => ({}));\n      console.error(' Error details:', err);\n      throw new Error(err.error || `Failed to send email: ${res.status} ${res.statusText}`);\n    }\n\n    const result = await res.json();\n    console.log(' Email sent successfully:', result.messageId);\n    return result;\n  } catch (error) {\n    console.error(' Email service error:', error.message);\n    console.error(' Full error:', error);\n    throw error;\n  }\n}","import { Language } from '@/contexts/AppContext';\n\n// Translation cache to avoid repeated API calls for the same text\ntype CacheKey = `${string}|${string}|${string}`;\nconst translationCache = new Map<CacheKey, string>();\n\n// Supported languages by LibreTranslate\nconst supportedLanguages = {\n  'en': 'English',\n  'ar': 'Arabic',\n  'zh': 'Chinese',\n  'fr': 'French',\n  'de': 'German',\n  'hi': 'Hindi',\n  'it': 'Italian',\n  'ja': 'Japanese',\n  'pt': 'Portuguese',\n  'ru': 'Russian',\n  'es': 'Spanish'\n};\n\n/**\n * Check if a language is supported by the translation service\n */\nexport const isLanguageSupported = (lang: string): boolean => {\n  return Object.keys(supportedLanguages).includes(lang);\n};\n\n/**\n * Get supported languages for translation\n */\nexport const getSupportedLanguages = (): Record<string, string> => {\n  return supportedLanguages;\n};\n\n/**\n * Detect the language of a text\n */\nexport const detectLanguage = async (text: string): Promise<string> => {\n  try {\n    // Using LibreTranslate API\n    const response = await fetch('https://libretranslate.com/detect', {\n      method: 'POST',\n      body: JSON.stringify({\n        q: text\n      }),\n      headers: { 'Content-Type': 'application/json' }\n    });\n    \n    const data = await response.json();\n    if (Array.isArray(data) && data.length > 0) {\n      return data[0].language;\n    }\n    \n    return 'en'; // Default to English if detection fails\n  } catch (error) {\n    console.error('Error detecting language:', error);\n    return 'en';\n  }\n};\n\n/**\n * Translate text from one language to another\n */\nexport const translateText = async (\n  text: string, \n  targetLang: string, \n  sourceLang: string = 'auto'\n): Promise<string> => {\n  // Return original text if it's empty\n  if (!text.trim()) {\n    return text;\n  }\n  \n  // Create cache key\n  const cacheKey: CacheKey = `${text}|${sourceLang}|${targetLang}`;\n  \n  // Check cache first\n  if (translationCache.has(cacheKey)) {\n    return translationCache.get(cacheKey) as string;\n  }\n  \n  try {\n    // For demo purposes, using LibreTranslate API\n    // In production, you should use an API key or self-host LibreTranslate\n    const response = await fetch('https://libretranslate.com/translate', {\n      method: 'POST',\n      body: JSON.stringify({\n        q: text,\n        source: sourceLang === 'auto' ? 'auto' : sourceLang,\n        target: targetLang,\n        format: 'text'\n      }),\n      headers: { 'Content-Type': 'application/json' }\n    });\n    \n    const data = await response.json();\n    \n    if (data && data.translatedText) {\n      // Store in cache\n      translationCache.set(cacheKey, data.translatedText);\n      return data.translatedText;\n    }\n    \n    // If translation fails, return original text\n    return text;\n  } catch (error) {\n    console.error('Translation error:', error);\n    return text;\n  }\n};\n\n/**\n * Fallback translation using a simple dictionary for common phrases\n * Used when API calls fail or for demo purposes\n */\nexport const fallbackTranslate = (\n  text: string,\n  targetLang: Language\n): string => {\n  // Very simple fallback dictionary for common phrases\n  const simpleDictionary: Record<string, Record<Language, string>> = {\n    'Hello': {\n      en: 'Hello',\n      fr: 'Bonjour',\n      es: 'Hola',\n      ar: '',\n      hi: '',\n      it: 'Ciao',\n      ru: '',\n      ja: '',\n      de: 'Hallo',\n      pt: 'Ol',\n      zh: '',\n      ko: ''\n    },\n    'Goodbye': {\n      en: 'Goodbye',\n      fr: 'Au revoir',\n      es: 'Adis',\n      ar: '',\n      hi: '',\n      it: 'Arrivederci',\n      ru: ' ',\n      ja: '',\n      de: 'Auf Wiedersehen',\n      pt: 'Adeus',\n      zh: '',\n      ko: ' '\n    }\n    // Add more common phrases as needed\n  };\n  \n  // Check if the text is in our simple dictionary\n  const lowerText = text.toLowerCase().trim();\n  for (const [key, translations] of Object.entries(simpleDictionary)) {\n    if (key.toLowerCase() === lowerText && translations[targetLang]) {\n      return translations[targetLang];\n    }\n  }\n  \n  // If not found, return original text\n  return text;\n};\n","import { EmailTemplate, EmailTemplateVariable, EmailPreview } from '@/types/query';\n\nclass EmailTemplateService {\n  private templates: EmailTemplate[] = [];\n  private templateId = 1;\n\n  private defaultTemplates: Omit<EmailTemplate, 'id' | 'createdAt' | 'updatedAt' | 'createdBy'>[] = [\n    {\n      name: 'Lead Enquiry Thank You',\n      subject: 'Thank you for your enquiry  {TripName}',\n      content: `Hi {ClientName},\n\nThank you for your interest in our {TripName} package. Our team will review your request and get back to you shortly.\n\nYou can also reach us at {SupportEmail} or WhatsApp us at {SupportPhone}.\n\nWarm regards,\nTeam {CompanyName}`,\n      category: 'lead',\n      role: 'traveller',\n      trigger: 'Lead submission',\n      language: 'en',\n      variables: ['ClientName', 'TripName', 'SupportEmail', 'SupportPhone', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    {\n      name: 'Quotation Sent',\n      subject: 'Your Tour Quotation for {TripName}  Ref: {QuoteID}',\n      content: `Hi {ClientName},\n\nPlease find your requested tour quotation below:\n\n Destination: {TripName}\n Travel Dates: {StartDate} to {EndDate}\n Pax: {AdultCount} Adults, {ChildCount} Children\n\n [View Quotation PDF]\nLet us know if you'd like any changes.\n\nBest Regards,\n{AgentName}  {CompanyName}`,\n      category: 'quotation',\n      role: 'traveller',\n      trigger: 'Proposal sent',\n      language: 'en',\n      variables: ['ClientName', 'TripName', 'QuoteID', 'StartDate', 'EndDate', 'AdultCount', 'ChildCount', 'AgentName', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    {\n      name: 'Booking Confirmation',\n      subject: 'Booking Confirmed  {TripName} | Ref: {BookingID}',\n      content: `Hi {ClientName},\n\nYour trip to {Destination} from {StartDate} is now confirmed!\n\n Booking ID: {BookingID}\n Total Amount: {TotalAmount}\n Hotel: {HotelName}\n Sightseeing: {SightseeingList}\n\n Download your itinerary and vouchers: [Download PDF]\n\nThank you for choosing {CompanyName}!`,\n      category: 'booking',\n      role: 'traveller',\n      trigger: 'Booking confirmed',\n      language: 'en',\n      variables: ['ClientName', 'TripName', 'Destination', 'StartDate', 'BookingID', 'TotalAmount', 'HotelName', 'SightseeingList', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    {\n      name: 'Payment Receipt',\n      subject: 'Payment Acknowledgement  Ref: {InvoiceNo}',\n      content: `Hi {ClientName},\n\nWe have received your payment of {AmountPaid} for booking {BookingID}.\n\n Payment Date: {PaymentDate}\n Invoice No: {InvoiceNo}\n [Download Invoice PDF]\n\nThank you for your trust in us.\n\nRegards,\nAccounts Team  {CompanyName}`,\n      category: 'payment',\n      role: 'traveller',\n      trigger: 'Payment received',\n      language: 'en',\n      variables: ['ClientName', 'AmountPaid', 'BookingID', 'PaymentDate', 'InvoiceNo', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    {\n      name: 'Agent Performance Summary',\n      subject: 'Monthly Report  Performance Summary for {MonthYear}',\n      content: `Hi {AgentName},\n\nHere's your performance summary for {MonthYear}:\n\n Total Bookings: {BookingCount}\n Total Revenue: {TotalRevenue}\n Conversion Rate: {ConversionRate}%\n\nKeep up the great work!\n\nRegards,\n{CompanyName} CRM Team`,\n      category: 'account',\n      role: 'agent',\n      trigger: 'Monthly report generation',\n      language: 'en',\n      variables: ['AgentName', 'MonthYear', 'BookingCount', 'TotalRevenue', 'ConversionRate', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  1. Lead Follow-Up Reminder\n    {\n      name: 'Lead Follow-Up Reminder',\n      subject: 'Follow-Up Reminder for Your Trip Enquiry  {TripName}',\n      content: `Hi {TravellerName},\n\nWe wanted to follow up on your recent enquiry for {TripName}.\n\n Follow-up Date: {FollowupDate}\n Assigned Agent: {AgentName}\n\nWe'd love to help you plan your perfect trip. Please let us know if you have any questions or would like to proceed with booking.\n\nBest regards,\n{AgentName} - {CompanyName}`,\n      category: 'lead',\n      role: 'traveller',\n      trigger: 'Lead follow-up scheduled',\n      language: 'en',\n      variables: ['LeadID', 'TripName', 'TravellerName', 'FollowupDate', 'AgentName', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  2. Lead Auto-Closure Warning\n    {\n      name: 'Lead Auto Closure Alert',\n      subject: 'Your Enquiry Will Auto-Close in 24 Hours  {TripName}',\n      content: `Hi {TravellerName},\n\nThis is a friendly reminder that your enquiry for {TripName} will automatically close in 24 hours.\n\n Closure Time: {ClosureTime}\n Lead ID: {LeadID}\n\nIf you're still interested in this trip, please respond to this email or contact us to keep your enquiry active.\n\nBest regards,\n{CompanyName} Team`,\n      category: 'lead',\n      role: 'traveller',\n      trigger: 'Lead auto-close warning',\n      language: 'en',\n      variables: ['LeadID', 'TripName', 'TravellerName', 'ClosureTime', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  3. Proposal Expiry Alert\n    {\n      name: 'Proposal Expiry Notification',\n      subject: 'Your Tour Proposal for {TripName} Expires Soon',\n      content: `Hi {TravellerName},\n\nYour tour proposal for {TripName} will expire soon.\n\n Quote ID: {QuoteID}\n Expiry Date: {ExpiryDate}\n\nTo secure your booking at the quoted prices, please confirm your acceptance before the expiry date. Prices may change after expiry.\n\n Contact us: {SupportPhone}\n Email: {SupportEmail}\n\nBest regards,\n{CompanyName}`,\n      category: 'quotation',\n      role: 'traveller',\n      trigger: 'Proposal expiry reminder',\n      language: 'en',\n      variables: ['QuoteID', 'TripName', 'ExpiryDate', 'TravellerName', 'SupportPhone', 'SupportEmail', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  4. Revised Quotation Sent\n    {\n      name: 'Updated Quotation Sent',\n      subject: 'Revised Tour Quotation for {TripName}  Ref: {QuoteID}',\n      content: `Hi {TravellerName},\n\nWe have sent you a revised quotation for your {TripName} trip.\n\n Quote ID: {QuoteID}\n Revision No: {RevisionNo}\n Total Amount: {TotalAmount}\n Valid Until: {ValidityDate}\n\nPlease review the updated details and let us know if you'd like to proceed or need any further modifications.\n\n Questions? Call us at {SupportPhone}\n\nBest regards,\n{AgentName} - {CompanyName}`,\n      category: 'quotation',\n      role: 'traveller',\n      trigger: 'Revised quotation sent',\n      language: 'en',\n      variables: ['QuoteID', 'TripName', 'RevisionNo', 'TotalAmount', 'ValidityDate', 'TravellerName', 'AgentName', 'SupportPhone', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  5. Booking Payment Due Reminder\n    {\n      name: 'Payment Due Reminder',\n      subject: 'Payment Reminder for Your Booking  Ref: {BookingID}',\n      content: `Hi {TravellerName},\n\nThis is a friendly reminder about your pending payment for booking {BookingID}.\n\n Booking ID: {BookingID}\n Trip: {TripName}\n Due Amount: {DueAmount}\n Due Date: {DueDate}\n\nTo avoid cancellation, please make the payment by the due date. You can pay online or contact us for payment assistance.\n\n Pay Now: [Payment Link]\n Need Help? Call {SupportPhone}\n\nBest regards,\nAccounts Team - {CompanyName}`,\n      category: 'booking',\n      role: 'traveller',\n      trigger: 'Payment due reminder',\n      language: 'en',\n      variables: ['BookingID', 'TripName', 'DueAmount', 'DueDate', 'TravellerName', 'SupportPhone', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  6. Voucher Delivery (Flight/Hotel/Sightseeing)\n    {\n      name: 'Your Travel Vouchers Are Ready',\n      subject: 'Travel Vouchers for {TripName}  Ref: {BookingID}',\n      content: `Hi {TravellerName},\n\nYour travel vouchers for {TripName} are now ready for download!\n\n Booking Reference: {BookingID}\n Trip Name: {TripName}\n Voucher Links: {VoucherLinks}\n\nPlease download and save these vouchers. You may need to present them during your trip.\n\n Save to Phone: [Mobile Vouchers]\n Print Options: [Printable Version]\n\nHave a wonderful trip!\n\nBest regards,\n{CompanyName} Team`,\n      category: 'booking',\n      role: 'traveller',\n      trigger: 'Vouchers generated',\n      language: 'en',\n      variables: ['BookingID', 'TripName', 'VoucherLinks', 'TravellerName', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  7. Final Itinerary Delivery\n    {\n      name: 'Your Final Travel Itinerary',\n      subject: 'Final Itinerary for {TripName}  Ref: {BookingID}',\n      content: `Hi {TravellerName},\n\nYour final travel itinerary for {TripName} is ready!\n\n Booking Reference: {BookingID}\n Trip Name: {TripName}\n Trip Start Date: {TripStartDate}\n Itinerary PDF: {PDFLink}\n\nThis is your complete itinerary with all confirmed details. Please review it carefully and contact us immediately if you notice any discrepancies.\n\n Mobile Version: [Mobile Itinerary]\n Offline Access: [Download for Offline]\n\nSafe travels!\n\nBest regards,\n{CompanyName}`,\n      category: 'itinerary',\n      role: 'traveller',\n      trigger: 'Itinerary finalized',\n      language: 'en',\n      variables: ['BookingID', 'TripName', 'PDFLink', 'TripStartDate', 'TravellerName', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  8. Travel Reminder (Trip Starts Soon)\n    {\n      name: 'Trip Reminder',\n      subject: 'Your Trip to {Destination} Starts Tomorrow',\n      content: `Hi {TravellerName},\n\nYour exciting trip to {Destination} starts tomorrow!\n\n Trip Name: {TripName}\n Start Date: {StartDate}\n Emergency Contact: {EmergencyContact}\n\nFinal Reminders:\n Check your passport and travel documents\n Confirm airport/station arrival time\n Pack according to weather forecast\n Keep vouchers and itinerary handy\n\nHave an amazing journey!\n\nSafe travels,\n{CompanyName} Team`,\n      category: 'reminder',\n      role: 'traveller',\n      trigger: 'Trip start reminder',\n      language: 'en',\n      variables: ['TravellerName', 'TripName', 'StartDate', 'Destination', 'EmergencyContact', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  9. Post-Trip Feedback Request\n    {\n      name: 'Thank You  Share Your Feedback',\n      subject: 'How Was Your Trip to {Destination}?',\n      content: `Hi {TravellerName},\n\nWe hope you had a wonderful time on your trip to {Destination}!\n\n Trip: {TripName}\n We'd love to hear about your experience: {FeedbackLink}\n\nYour feedback helps us improve our services and plan even better trips for future travelers. It only takes 2 minutes to complete.\n\nAs a token of appreciation, you'll receive a 10% discount on your next booking after submitting your feedback.\n\nThank you for choosing {CompanyName}!\n\nBest regards,\nCustomer Experience Team`,\n      category: 'feedback',\n      role: 'traveller',\n      trigger: 'Post-trip feedback request',\n      language: 'en',\n      variables: ['TravellerName', 'TripName', 'Destination', 'FeedbackLink', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  10. Cancellation Notification\n    {\n      name: 'Booking Cancellation Notice',\n      subject: 'Cancellation Confirmed  {TripName} | Ref: {BookingID}',\n      content: `Hi {TravellerName},\n\nYour booking has been cancelled as requested.\n\n Booking ID: {BookingID}\n Trip: {TripName}\n Refund Amount: {RefundAmount}\n Cancellation Date: {CancellationDate}\n\nWe understand that plans can change. Your refund of {RefundAmount} will be processed within 5-7 business days to your original payment method.\n\nIf you have any questions about the cancellation or refund process, please don't hesitate to contact us.\n\nWe hope to serve you again in the future.\n\nBest regards,\n{CompanyName} Team`,\n      category: 'booking',\n      role: 'traveller',\n      trigger: 'Booking cancelled',\n      language: 'en',\n      variables: ['BookingID', 'TripName', 'RefundAmount', 'CancellationDate', 'TravellerName', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  11. Refund Processed\n    {\n      name: 'Refund Successfully Processed',\n      subject: 'Refund for {TripName}  Ref: {RefundID}',\n      content: `Hi {TravellerName},\n\nYour refund has been successfully processed!\n\n Refund ID: {RefundID}\n Booking Reference: {BookingID}\n Refund Amount: {RefundAmount}\n Refund Date: {RefundDate}\n\nThe refund has been initiated to your original payment method and should reflect in your account within 3-5 business days, depending on your bank's processing time.\n\nThank you for your patience during this process.\n\nBest regards,\nAccounts Team - {CompanyName}`,\n      category: 'payment',\n      role: 'traveller',\n      trigger: 'Refund processed',\n      language: 'en',\n      variables: ['RefundID', 'BookingID', 'RefundAmount', 'RefundDate', 'TravellerName', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  12. Agent New Lead Notification\n    {\n      name: 'New Lead Assigned',\n      subject: 'New Lead Assigned  {TravellerName} for {TripName}',\n      content: `Hi {AgentName},\n\nA new lead has been assigned to you!\n\n Client: {TravellerName}\n Trip: {TripName}\n Lead ID: {LeadID}\n\nPlease contact the client within 2 hours for best results. Review their requirements and prepare a customized proposal.\n\n Contact Priority: High\n Response Time: Within 2 hours\n\nGood luck with the conversion!\n\nBest regards,\nLead Management Team - {CompanyName}`,\n      category: 'lead',\n      role: 'agent',\n      trigger: 'New lead assigned',\n      language: 'en',\n      variables: ['AgentName', 'TravellerName', 'TripName', 'LeadID', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  13. Agent Query Reminder\n    {\n      name: 'Pending Lead Reminder',\n      subject: 'Follow-Up Required  Lead ID: {LeadID}',\n      content: `Hi {AgentName},\n\nThis is a reminder about your pending lead that requires follow-up.\n\n Lead ID: {LeadID}\n Client: {TravellerName}\n Trip: {TripName}\n Last Follow-Up: {LastFollowUp}\n\nPlease contact the client today to maintain engagement and move towards conversion.\n\n Suggested Action: Call to discuss their concerns and offer solutions\n Priority: Medium-High\n\nKeep up the good work!\n\nBest regards,\nSales Team - {CompanyName}`,\n      category: 'lead',\n      role: 'agent',\n      trigger: 'Lead follow-up reminder',\n      language: 'en',\n      variables: ['LeadID', 'TravellerName', 'TripName', 'LastFollowUp', 'AgentName', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  14. Agent Payment Settlement Summary\n    {\n      name: 'Payment Settlement Summary',\n      subject: 'Monthly Agent Settlement  {MonthYear}',\n      content: `Hi {AgentName},\n\nYour monthly settlement summary for {MonthYear} is ready!\n\n Sales Performance:\n Total Sales: {TotalSales}\n Total Bookings: {BookingCount}\n Commission Rate: 8%\n\n Commission Details:\n Commission Amount: {CommissionAmount}\n Adjustments: 0\n Net Payable: {CommissionAmount}\n\nThe commission amount will be transferred to your registered bank account within 5 business days.\n\nThank you for your excellent performance this month!\n\nBest regards,\nFinance Team - {CompanyName}`,\n      category: 'account',\n      role: 'agent',\n      trigger: 'Monthly settlement',\n      language: 'en',\n      variables: ['AgentName', 'MonthYear', 'TotalSales', 'CommissionAmount', 'BookingCount', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    },\n    //  15. Admin System Alerts (Low Balance / API Error)\n    {\n      name: 'System Alert',\n      subject: 'API/Balance Alert  {AlertType}',\n      content: `URGENT: System Alert\n\nAlert Type: {AlertType}\nDescription: {Description}\nTime: {Time}\nPriority Level: {PriorityLevel}\n\nImmediate action may be required. Please check the system dashboard and take appropriate action.\n\n Action Required: Check system logs and resolve issue\n Dashboard: [View System Status]\n Emergency Contact: Technical Team\n\nThis is an automated system alert.\n\nSystem Monitoring - {CompanyName}`,\n      category: 'support',\n      role: 'admin',\n      trigger: 'System alert triggered',\n      language: 'en',\n      variables: ['AlertType', 'Description', 'Time', 'PriorityLevel', 'CompanyName'],\n      isActive: true,\n      isDefault: true\n    }\n  ];\n\n  private availableVariables: EmailTemplateVariable[] = [\n    { name: 'ClientName', description: 'Customer/Client name', example: 'John Smith', category: 'Customer' },\n    { name: 'TravellerName', description: 'Traveller name', example: 'John Smith', category: 'Customer' },\n    { name: 'AgentName', description: 'Agent name', example: 'Sarah Johnson', category: 'Staff' },\n    { name: 'CompanyName', description: 'Company name', example: 'Dream Travels', category: 'Company' },\n    { name: 'TripName', description: 'Trip/Package name', example: 'Dubai 5D/4N', category: 'Trip' },\n    { name: 'Destination', description: 'Travel destination', example: 'Dubai, UAE', category: 'Trip' },\n    { name: 'StartDate', description: 'Trip start date', example: '15th March 2024', category: 'Trip' },\n    { name: 'EndDate', description: 'Trip end date', example: '20th March 2024', category: 'Trip' },\n    { name: 'TripStartDate', description: 'Trip start date', example: '15th March 2024', category: 'Trip' },\n    { name: 'BookingID', description: 'Booking reference ID', example: 'DTR-2024-001', category: 'Booking' },\n    { name: 'QuoteID', description: 'Quotation reference ID', example: 'QT-2024-001', category: 'Quotation' },\n    { name: 'LeadID', description: 'Lead reference ID', example: 'LD-2024-001', category: 'Lead' },\n    { name: 'RefundID', description: 'Refund reference ID', example: 'RF-2024-001', category: 'Payment' },\n    { name: 'TotalAmount', description: 'Total booking amount', example: '45,000', category: 'Payment' },\n    { name: 'AmountPaid', description: 'Amount paid', example: '15,000', category: 'Payment' },\n    { name: 'DueAmount', description: 'Due payment amount', example: '30,000', category: 'Payment' },\n    { name: 'RefundAmount', description: 'Refund amount', example: '15,000', category: 'Payment' },\n    { name: 'PaymentDate', description: 'Payment date', example: '10th March 2024', category: 'Payment' },\n    { name: 'DueDate', description: 'Payment due date', example: '25th March 2024', category: 'Payment' },\n    { name: 'RefundDate', description: 'Refund date', example: '15th March 2024', category: 'Payment' },\n    { name: 'InvoiceNo', description: 'Invoice number', example: 'INV-2024-001', category: 'Payment' },\n    { name: 'HotelName', description: 'Hotel name', example: 'Burj Al Arab', category: 'Trip' },\n    { name: 'SightseeingList', description: 'Sightseeing activities list', example: 'City Tour, Desert Safari, Burj Khalifa', category: 'Trip' },\n    { name: 'VoucherLinks', description: 'Travel voucher download links', example: '[Download Vouchers]', category: 'Booking' },\n    { name: 'PDFLink', description: 'PDF document link', example: '[Download PDF]', category: 'Documents' },\n    { name: 'FeedbackLink', description: 'Feedback form link', example: '[Submit Feedback]', category: 'Feedback' },\n    { name: 'AdultCount', description: 'Number of adults', example: '2', category: 'Passengers' },\n    { name: 'ChildCount', description: 'Number of children', example: '1', category: 'Passengers' },\n    { name: 'SupportEmail', description: 'Support email address', example: 'support@dreamtravels.com', category: 'Company' },\n    { name: 'SupportPhone', description: 'Support phone number', example: '+91 98765 43210', category: 'Company' },\n    { name: 'EmergencyContact', description: 'Emergency contact number', example: '+91 98765 43210', category: 'Emergency' },\n    { name: 'FollowupDate', description: 'Follow-up scheduled date', example: '20th March 2024', category: 'Lead' },\n    { name: 'ClosureTime', description: 'Auto-closure time', example: '24 hours', category: 'Lead' },\n    { name: 'LastFollowUp', description: 'Last follow-up date', example: '15th March 2024', category: 'Lead' },\n    { name: 'ExpiryDate', description: 'Proposal expiry date', example: '25th March 2024', category: 'Quotation' },\n    { name: 'RevisionNo', description: 'Quotation revision number', example: '2', category: 'Quotation' },\n    { name: 'ValidityDate', description: 'Quotation validity date', example: '30th March 2024', category: 'Quotation' },\n    { name: 'CancellationDate', description: 'Booking cancellation date', example: '18th March 2024', category: 'Booking' },\n    { name: 'MonthYear', description: 'Month and year', example: 'March 2024', category: 'Date' },\n    { name: 'BookingCount', description: 'Total booking count', example: '15', category: 'Statistics' },\n    { name: 'TotalRevenue', description: 'Total revenue amount', example: '450,000', category: 'Statistics' },\n    { name: 'ConversionRate', description: 'Lead conversion rate', example: '25%', category: 'Statistics' },\n    { name: 'TotalSales', description: 'Total sales amount', example: '500,000', category: 'Statistics' },\n    { name: 'CommissionAmount', description: 'Agent commission amount', example: '40,000', category: 'Commission' },\n    { name: 'AlertType', description: 'System alert type', example: 'Low Balance', category: 'System' },\n    { name: 'Description', description: 'Alert description', example: 'API connection failed', category: 'System' },\n    { name: 'Time', description: 'Alert timestamp', example: '14:30 PM', category: 'System' },\n    { name: 'PriorityLevel', description: 'Alert priority level', example: 'HIGH', category: 'System' }\n  ];\n\n  constructor() {\n    this.initializeDefaultTemplates();\n  }\n\n  private initializeDefaultTemplates(): void {\n    this.defaultTemplates.forEach(template => {\n      const newTemplate: EmailTemplate = {\n        ...template,\n        id: this.generateId(),\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        createdBy: 'system'\n      };\n      this.templates.push(newTemplate);\n    });\n  }\n\n  private generateId(): string {\n    return `template_${this.templateId++}_${Date.now()}`;\n  }\n\n  // Get all templates\n  async getTemplates(): Promise<EmailTemplate[]> {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    return [...this.templates];\n  }\n\n  // Get templates by category\n  async getTemplatesByCategory(category: EmailTemplate['category']): Promise<EmailTemplate[]> {\n    return this.templates.filter(t => t.category === category);\n  }\n\n  // Get templates by role\n  async getTemplatesByRole(role: EmailTemplate['role']): Promise<EmailTemplate[]> {\n    return this.templates.filter(t => t.role === role);\n  }\n\n  // Get template by ID\n  async getTemplateById(id: string): Promise<EmailTemplate | null> {\n    return this.templates.find(t => t.id === id) || null;\n  }\n\n  // Create new template\n  async createTemplate(template: Omit<EmailTemplate, 'id' | 'createdAt' | 'updatedAt'>): Promise<EmailTemplate> {\n    const newTemplate: EmailTemplate = {\n      ...template,\n      id: this.generateId(),\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n\n    this.templates.push(newTemplate);\n    return newTemplate;\n  }\n\n  // Update template\n  async updateTemplate(id: string, updates: Partial<EmailTemplate>): Promise<EmailTemplate | null> {\n    const index = this.templates.findIndex(t => t.id === id);\n    if (index === -1) return null;\n\n    this.templates[index] = {\n      ...this.templates[index],\n      ...updates,\n      updatedAt: new Date().toISOString()\n    };\n\n    return this.templates[index];\n  }\n\n  // Delete template\n  async deleteTemplate(id: string): Promise<boolean> {\n    const index = this.templates.findIndex(t => t.id === id);\n    if (index === -1) return false;\n\n    // Don't allow deletion of default templates\n    if (this.templates[index].isDefault) {\n      throw new Error('Cannot delete default templates');\n    }\n\n    this.templates.splice(index, 1);\n    return true;\n  }\n\n  // Duplicate template\n  async duplicateTemplate(id: string): Promise<EmailTemplate | null> {\n    const original = await this.getTemplateById(id);\n    if (!original) return null;\n\n    return this.createTemplate({\n      ...original,\n      name: `${original.name} (Copy)`,\n      isDefault: false\n    });\n  }\n\n  // Toggle template status\n  async toggleTemplateStatus(id: string): Promise<EmailTemplate | null> {\n    const template = this.templates.find(t => t.id === id);\n    if (!template) return null;\n\n    template.isActive = !template.isActive;\n    template.updatedAt = new Date().toISOString();\n\n    return template;\n  }\n\n  // Get available variables\n  getAvailableVariables(): EmailTemplateVariable[] {\n    return [...this.availableVariables];\n  }\n\n  // Get variables by category\n  getVariablesByCategory(category: string): EmailTemplateVariable[] {\n    return this.availableVariables.filter(v => v.category === category);\n  }\n\n  // Preview template with variables\n  previewTemplate(template: EmailTemplate, variables: Record<string, string>): EmailPreview {\n    let previewSubject = template.subject;\n    let previewContent = template.content;\n\n    // Replace variables in subject and content\n    Object.entries(variables).forEach(([key, value]) => {\n      const regex = new RegExp(`{${key}}`, 'g');\n      previewSubject = previewSubject.replace(regex, value);\n      previewContent = previewContent.replace(regex, value);\n    });\n\n    return {\n      subject: previewSubject,\n      content: previewContent,\n      variables\n    };\n  }\n\n  // Send test email\n  async sendTestEmail(templateId: string, testEmail: string, variables: Record<string, string>): Promise<void> {\n    const template = await this.getTemplateById(templateId);\n    if (!template) throw new Error('Template not found');\n\n    const preview = this.previewTemplate(template, variables);\n    \n    // Use the email service to actually send the email\n    try {\n      console.log(' Attempting to send test email...');\n      console.log('Template preview:', preview);\n      console.log('Recipient:', testEmail);\n      \n      const { sendEmail } = await import('@/services/emailService');\n      console.log('Email service imported successfully');\n      \n      const result = await sendEmail(testEmail, preview.subject, preview.content);\n      console.log(' Test email sent successfully:', result);\n      \n      console.log(' Test Email Sent:', {\n        to: testEmail,\n        subject: preview.subject,\n        content: preview.content,\n        templateId,\n        timestamp: new Date().toISOString()\n      });\n      \n      return result;\n    } catch (error) {\n      console.error(' Failed to send test email:', error);\n      console.error('Error details:', {\n        message: error.message,\n        stack: error.stack,\n        name: error.name\n      });\n      throw new Error(`Failed to send test email: ${error.message}`);\n    }\n  }\n\n  // Get template statistics\n  getTemplateStats(): {\n    total: number;\n    active: number;\n    inactive: number;\n    byCategory: Record<string, number>;\n    byRole: Record<string, number>;\n  } {\n    const stats = {\n      total: this.templates.length,\n      active: this.templates.filter(t => t.isActive).length,\n      inactive: this.templates.filter(t => !t.isActive).length,\n      byCategory: {} as Record<string, number>,\n      byRole: {} as Record<string, number>\n    };\n\n    this.templates.forEach(template => {\n      stats.byCategory[template.category] = (stats.byCategory[template.category] || 0) + 1;\n      stats.byRole[template.role] = (stats.byRole[template.role] || 0) + 1;\n    });\n\n    return stats;\n  }\n}\n\nexport const emailTemplateService = new EmailTemplateService();","\nexport interface CurrencyApiResponse {\n  meta: {\n    last_updated_at: string;\n  };\n  data: {\n    [key: string]: {\n      code: string;\n      value: number;\n    };\n  };\n}\n\nexport interface ApiUsage {\n  used: number;\n  limit: number;\n  resetDate: string;\n  lastFetch: string;\n}\n\nexport class CurrencyApiService {\n  private static readonly API_BASE_URL = 'https://api.currencyapi.com/v3/latest';\n  private static readonly CACHE_KEY = 'currencyapi_cache';\n  private static readonly USAGE_KEY = 'currencyapi_usage';\n  private static readonly API_KEY_KEY = 'currencyapi_key';\n  private static readonly CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours\n\n  static getApiKey(): string | null {\n    return localStorage.getItem(this.API_KEY_KEY);\n  }\n\n  static getUsage(): ApiUsage {\n    const saved = localStorage.getItem(this.USAGE_KEY);\n    if (saved) {\n      return JSON.parse(saved);\n    }\n    \n    // Initialize usage tracking\n    const now = new Date();\n    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);\n    return {\n      used: 0,\n      limit: 300,\n      resetDate: nextMonth.toISOString(),\n      lastFetch: ''\n    };\n  }\n\n  static updateUsage(increment: number = 1): void {\n    const usage = this.getUsage();\n    \n    // Check if we need to reset monthly usage\n    const now = new Date();\n    const resetDate = new Date(usage.resetDate);\n    \n    if (now >= resetDate) {\n      // Reset for new month\n      const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);\n      usage.used = 0;\n      usage.resetDate = nextMonth.toISOString();\n    }\n    \n    usage.used += increment;\n    usage.lastFetch = now.toISOString();\n    \n    localStorage.setItem(this.USAGE_KEY, JSON.stringify(usage));\n  }\n\n  static getCachedRates(): { rates: Record<string, number>; timestamp: number } | null {\n    const cached = localStorage.getItem(this.CACHE_KEY);\n    if (!cached) return null;\n    \n    try {\n      const data = JSON.parse(cached);\n      const now = Date.now();\n      \n      // Check if cache is still valid (24 hours)\n      if (now - data.timestamp < this.CACHE_DURATION) {\n        return data;\n      }\n    } catch (error) {\n      console.error('Error parsing cached rates:', error);\n    }\n    \n    return null;\n  }\n\n  static setCachedRates(rates: Record<string, number>): void {\n    const cacheData = {\n      rates,\n      timestamp: Date.now()\n    };\n    localStorage.setItem(this.CACHE_KEY, JSON.stringify(cacheData));\n  }\n\n  static async fetchRealTimeRates(): Promise<{ rates: Record<string, number>; isRealTime: boolean }> {\n    const apiKey = this.getApiKey();\n    if (!apiKey) {\n      throw new Error('API key not configured');\n    }\n\n    const usage = this.getUsage();\n    \n    // Check if we're approaching the limit\n    if (usage.used >= usage.limit - 5) { // Keep 5 requests buffer\n      console.warn('API limit nearly reached, using cached rates');\n      const cached = this.getCachedRates();\n      if (cached) {\n        return { rates: cached.rates, isRealTime: false };\n      }\n      throw new Error('API limit exceeded and no cached rates available');\n    }\n\n    // Check cache first\n    const cached = this.getCachedRates();\n    if (cached) {\n      console.log('Using cached rates to preserve API requests');\n      return { rates: cached.rates, isRealTime: false };\n    }\n\n    try {\n      // Fetch all needed currencies in one request to minimize API usage\n      const currencies = 'THB,INR,AED,EUR,GBP,JPY,AUD,CAD,CHF,CNY,SGD,MYR';\n      const url = `${this.API_BASE_URL}?apikey=${apiKey}&currencies=${currencies}&base_currency=USD`;\n      \n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        if (response.status === 429) {\n          throw new Error('API rate limit exceeded');\n        } else if (response.status === 401) {\n          throw new Error('Invalid API key');\n        } else {\n          throw new Error(`API error: ${response.status}`);\n        }\n      }\n\n      const data: CurrencyApiResponse = await response.json();\n      \n      // Update usage counter\n      this.updateUsage(1);\n      \n      // Convert API response to our format\n      const rates: Record<string, number> = {};\n      Object.entries(data.data).forEach(([code, currencyData]) => {\n        rates[`USD_${code}`] = currencyData.value;\n        rates[`${code}_USD`] = 1 / currencyData.value;\n      });\n\n      // Add cross rates (THB to INR, etc.)\n      if (rates['USD_THB'] && rates['USD_INR']) {\n        rates['THB_INR'] = rates['USD_INR'] / rates['USD_THB'];\n        rates['INR_THB'] = rates['USD_THB'] / rates['USD_INR'];\n      }\n\n      // Cache the rates\n      this.setCachedRates(rates);\n      \n      console.log(`Fetched real-time rates. Usage: ${this.getUsage().used}/${this.getUsage().limit}`);\n      \n      return { rates, isRealTime: true };\n    } catch (error) {\n      console.error('Failed to fetch real-time rates:', error);\n      \n      // Try to use cached rates as fallback\n      const cached = this.getCachedRates();\n      if (cached) {\n        console.log('Using cached rates as fallback');\n        return { rates: cached.rates, isRealTime: false };\n      }\n      \n      throw error;\n    }\n  }\n\n  static async fetchSpecificRate(fromCurrency: string, toCurrency: string): Promise<{ rate: number; isRealTime: boolean }> {\n    try {\n      const { rates, isRealTime } = await this.fetchRealTimeRates();\n      const rateKey = `${fromCurrency}_${toCurrency}`;\n      \n      if (rates[rateKey]) {\n        return { rate: rates[rateKey], isRealTime };\n      }\n      \n      // Try reverse rate\n      const reverseKey = `${toCurrency}_${fromCurrency}`;\n      if (rates[reverseKey]) {\n        return { rate: 1 / rates[reverseKey], isRealTime };\n      }\n      \n      throw new Error(`Rate not found for ${fromCurrency} to ${toCurrency}`);\n    } catch (error) {\n      console.error('Error fetching specific rate:', error);\n      throw error;\n    }\n  }\n\n  static clearCache(): void {\n    localStorage.removeItem(this.CACHE_KEY);\n  }\n\n  static getRemainingRequests(): number {\n    const usage = this.getUsage();\n    return Math.max(0, usage.limit - usage.used);\n  }\n}\n","\nimport { CurrencyService } from './currencyService';\nimport { getMillisecondsUntilNextIST, getISTTime, formatISTTime } from '../utils/timezoneUtils';\n\nexport class CurrencyScheduler {\n  private static timeoutId: NodeJS.Timeout | null = null;\n  private static isScheduled = false;\n  private static refreshCallback: (() => void) | null = null;\n\n  static scheduleDaily9AM(callback?: () => void): void {\n    if (callback) {\n      this.refreshCallback = callback;\n    }\n\n    // Clear existing schedule\n    this.clearSchedule();\n\n    const millisecondsUntil9AM = getMillisecondsUntilNextIST(9, 0); // 9:00 AM IST\n    \n    console.log(`Scheduling next currency refresh in ${Math.round(millisecondsUntil9AM / 1000 / 60)} minutes (9:00 AM IST)`);\n    \n    this.timeoutId = setTimeout(() => {\n      this.performScheduledRefresh();\n    }, millisecondsUntil9AM);\n    \n    this.isScheduled = true;\n  }\n\n  private static async performScheduledRefresh(): Promise<void> {\n    try {\n      const currentTime = getISTTime();\n      console.log(`Performing scheduled currency refresh at ${formatISTTime(currentTime)} IST`);\n      \n      // Trigger the refresh callback if provided\n      if (this.refreshCallback) {\n        this.refreshCallback();\n      }\n      \n      // Schedule next refresh for tomorrow\n      this.scheduleDaily9AM();\n      \n    } catch (error) {\n      console.error('Scheduled currency refresh failed:', error);\n      // Still schedule next refresh even if this one failed\n      this.scheduleDaily9AM();\n    }\n  }\n\n  static clearSchedule(): void {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n    this.isScheduled = false;\n  }\n\n  static getNextRefreshTime(): string {\n    if (!this.isScheduled) return 'Not scheduled';\n    \n    const nextRefresh = new Date();\n    nextRefresh.setTime(nextRefresh.getTime() + getMillisecondsUntilNextIST(9, 0));\n    \n    return formatISTTime(nextRefresh);\n  }\n\n  static isActive(): boolean {\n    return this.isScheduled;\n  }\n}\n","import { supabase } from '@/lib/supabaseClient';\n\nexport interface EmailConfiguration {\n  id?: string;\n  name: string;\n  smtp_host: string;\n  smtp_port: number;\n  smtp_secure: boolean;\n  smtp_user: string;\n  smtp_password: string;\n  from_email: string;\n  from_name: string;\n  is_active?: boolean;\n  is_default?: boolean;\n  created_at?: string;\n  updated_at?: string;\n  created_by?: string;\n  updated_by?: string;\n}\n\nexport interface EmailConfigurationResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\nclass EmailConfigurationService {\n  private static instance: EmailConfigurationService;\n  private readonly tableName = 'email_configurations';\n\n  private constructor() {}\n\n  static getInstance(): EmailConfigurationService {\n    if (!EmailConfigurationService.instance) {\n      EmailConfigurationService.instance = new EmailConfigurationService();\n    }\n    return EmailConfigurationService.instance;\n  }\n\n  /**\n   * Get all email configurations\n   */\n  async getEmailConfigurations(): Promise<EmailConfigurationResponse<EmailConfiguration[]>> {\n    try {\n      const { data, error } = await supabase\n        .from(this.tableName)\n        .select('*')\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        console.error('Error fetching email configurations:', error);\n        // Handle schema cache issues\n        if (error.code === 'PGRST205') {\n          console.warn('Table not found in schema cache, returning empty array');\n          return { success: true, data: [] };\n        }\n        return { success: false, error: error.message };\n      }\n\n      console.log('Raw data from database:', data);\n      return { success: true, data: data || [] };\n    } catch (error) {\n      console.error('Unexpected error fetching email configurations:', error);\n      return { success: false, error: 'Failed to fetch email configurations' };\n    }\n  }\n\n  /**\n   * Get active email configuration\n   */\n  async getActiveEmailConfiguration(): Promise<EmailConfigurationResponse<EmailConfiguration | null>> {\n    try {\n      // Try to use the function first\n      const { data, error } = await supabase\n        .rpc('get_active_email_config')\n        .single();\n\n      if (error) {\n        console.error('Error fetching active email configuration:', error);\n        // If function doesn't exist, try to get manually\n        if (error.code === 'PGRST205') {\n          console.warn('Function not found, trying manual query');\n          const { data: manualData, error: manualError } = await supabase\n            .from(this.tableName)\n            .select('*')\n            .eq('is_active', true)\n            .order('is_default', { ascending: false })\n            .order('created_at', { ascending: true })\n            .limit(1)\n            .single();\n\n          if (manualError) {\n            return { success: false, error: manualError.message };\n          }\n          return { success: true, data: manualData };\n        }\n        return { success: false, error: error.message };\n      }\n\n      return { success: true, data: data };\n    } catch (error) {\n      console.error('Unexpected error fetching active email configuration:', error);\n      return { success: false, error: 'Failed to fetch active email configuration' };\n    }\n  }\n  async getEmailConfigurationById(id: string): Promise<EmailConfigurationResponse<EmailConfiguration>> {\n    try {\n      console.log('Fetching email configuration by ID:', id);\n      const { data, error } = await supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('id', id)\n        .single();\n\n      if (error) {\n        console.error('Error fetching email configuration:', error);\n        // Handle schema cache issues\n        if (error.code === 'PGRST205') {\n          return { success: false, error: 'Email configurations table not available. Please try again later.' };\n        }\n        return { success: false, error: error.message };\n      }\n\n      console.log('Fetched configuration data:', data);\n\n      if (!data) {\n        return { success: false, error: 'Email configuration not found' };\n      }\n\n      return { success: true, data };\n    } catch (error) {\n      console.error('Unexpected error fetching email configuration:', error);\n      return { success: false, error: 'Failed to fetch email configuration' };\n    }\n  }\n\n  /**\n   * Create email configuration\n   */\n  async createEmailConfiguration(\n    config: Omit<EmailConfiguration, 'id' | 'created_at' | 'updated_at' | 'created_by' | 'updated_by'>\n  ): Promise<EmailConfigurationResponse<EmailConfiguration>> {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) {\n        return { success: false, error: 'User not authenticated' };\n      }\n\n      const configData = {\n        ...config,\n        created_by: user.id,\n        updated_by: user.id,\n      };\n\n      const { data, error } = await supabase\n        .from(this.tableName)\n        .insert(configData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error creating email configuration:', error);\n        // Handle schema cache issues\n        if (error.code === 'PGRST205') {\n          return { success: false, error: 'Email configurations table is not available. Please try again in a few moments.' };\n        }\n        return { success: false, error: error.message };\n      }\n\n      return { success: true, data };\n    } catch (error) {\n      console.error('Unexpected error creating email configuration:', error);\n      return { success: false, error: 'Failed to create email configuration' };\n    }\n  }\n\n  /**\n   * Update email configuration\n   */\n  async updateEmailConfiguration(\n    id: string,\n    config: Partial<Omit<EmailConfiguration, 'id' | 'created_at' | 'created_by'>>\n  ): Promise<EmailConfigurationResponse<EmailConfiguration>> {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) {\n        return { success: false, error: 'User not authenticated' };\n      }\n\n      const configData = {\n        ...config,\n        updated_by: user.id,\n      };\n\n      const { data, error } = await supabase\n        .from(this.tableName)\n        .update(configData)\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error updating email configuration:', error);\n        return { success: false, error: error.message };\n      }\n\n      return { success: true, data };\n    } catch (error) {\n      console.error('Unexpected error updating email configuration:', error);\n      return { success: false, error: 'Failed to update email configuration' };\n    }\n  }\n\n  /**\n   * Delete email configuration\n   */\n  async deleteEmailConfiguration(id: string): Promise<EmailConfigurationResponse<boolean>> {\n    try {\n      const { error } = await supabase\n        .from(this.tableName)\n        .delete()\n        .eq('id', id);\n\n      if (error) {\n        console.error('Error deleting email configuration:', error);\n        return { success: false, error: error.message };\n      }\n\n      return { success: true, data: true };\n    } catch (error) {\n      console.error('Unexpected error deleting email configuration:', error);\n      return { success: false, error: 'Failed to delete email configuration' };\n    }\n  }\n\n  /**\n   * Set default email configuration\n   */\n  async setDefaultEmailConfiguration(id: string): Promise<EmailConfigurationResponse<boolean>> {\n    try {\n      // First, unset all defaults\n      const { error: unsetError } = await supabase\n        .from(this.tableName)\n        .update({ is_default: false })\n        .neq('id', id);\n\n      if (unsetError) {\n        console.error('Error unsetting default configurations:', unsetError);\n        return { success: false, error: unsetError.message };\n      }\n\n      // Then set the new default\n      const { error: setError } = await supabase\n        .from(this.tableName)\n        .update({ is_default: true })\n        .eq('id', id);\n\n      if (setError) {\n        console.error('Error setting default configuration:', setError);\n        return { success: false, error: setError.message };\n      }\n\n      return { success: true, data: true };\n    } catch (error) {\n      console.error('Unexpected error setting default configuration:', error);\n      return { success: false, error: 'Failed to set default email configuration' };\n    }\n  }\n\n  /**\n   * Toggle email configuration active status\n   */\n  async toggleEmailConfigurationStatus(id: string): Promise<EmailConfigurationResponse<boolean>> {\n    try {\n      const { data: currentConfig, error: fetchError } = await this.getEmailConfigurationById(id);\n      \n      if (fetchError || !currentConfig.data) {\n        return { success: false, error: fetchError?.error || 'Configuration not found' };\n      }\n\n      const { error } = await supabase\n        .from(this.tableName)\n        .update({ is_active: !currentConfig.data.is_active })\n        .eq('id', id);\n\n      if (error) {\n        console.error('Error toggling configuration status:', error);\n        return { success: false, error: error.message };\n      }\n\n      return { success: true, data: true };\n    } catch (error) {\n      console.error('Unexpected error toggling configuration status:', error);\n      return { success: false, error: 'Failed to toggle email configuration status' };\n    }\n  }\n\n  /**\n   * Test email configuration by sending a test email\n   */\n  async testEmailConfiguration(\n    id: string,\n    testEmail: string\n  ): Promise<EmailConfigurationResponse<{ messageId: string; previewUrl?: string }>> {\n    try {\n      console.log('Testing email configuration:', id, 'to:', testEmail);\n      \n      const configResult = await this.getEmailConfigurationById(id);\n      \n      if (!configResult.success || !configResult.data) {\n        console.error('Configuration not found:', configResult.error);\n        return { success: false, error: configResult.error || 'Configuration not found' };\n      }\n\n      const config = configResult.data;\n      console.log('Config object:', config);\n      console.log('Config keys:', Object.keys(config));\n      console.log('Config name:', config.name);\n      console.log('Config host:', config.smtp_host);\n      console.log('Found configuration:', config.name);\n\n      // Build the HTML content\n      const htmlContent = `\n        <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\n          <h2 style=\"color: #333;\">Email Configuration Test</h2>\n          <p>This is a test email to verify your email configuration is working correctly.</p>\n          <div style=\"background-color: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0;\">\n            <h3 style=\"margin-top: 0;\">Configuration Details:</h3>\n            <p><strong>Name:</strong> ${config.name}</p>\n            <p><strong>SMTP Host:</strong> ${config.smtp_host}</p>\n            <p><strong>SMTP Port:</strong> ${config.smtp_port}</p>\n            <p><strong>From Email:</strong> ${config.from_email}</p>\n            <p><strong>From Name:</strong> ${config.from_name}</p>\n          </div>\n          <p style=\"color: #666; font-size: 12px;\">Sent on: ${new Date().toLocaleString()}</p>\n        </div>\n      `;\n\n      // Send test email using the Vercel API route\n      const emailServerUrl = '/api/email/send';\n      console.log('Calling email server at:', emailServerUrl);\n      \n      const response = await fetch(emailServerUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          to: testEmail,\n          subject: 'Test Email Configuration',\n          html: htmlContent,\n          config: {\n            smtp_host: config.smtp_host,\n            smtp_port: config.smtp_port,\n            smtp_secure: config.smtp_secure,\n            smtp_user: config.smtp_user,\n            smtp_password: config.smtp_password,\n            from_email: config.from_email,\n            from_name: config.from_name,\n          }\n        }),\n      });\n\n      console.log('Email server response status:', response.status);\n      \n      if (!response.ok) {\n        console.error('Email server returned error:', response.status, response.statusText);\n        \n        // Handle specific error cases\n        if (response.status === 500) {\n          // Try to get more detailed error information\n          try {\n            const errorData = await response.json();\n            if (errorData.error && errorData.error.includes('Authentication failed')) {\n              return { \n                success: false, \n                error: 'SMTP authentication failed. Please check your username and password.' \n              };\n            }\n          } catch (e) {\n            // If we can't parse the error JSON, use generic message\n          }\n          \n          return { \n            success: false, \n            error: 'Email server error. Please check your SMTP configuration and try again.' \n          };\n        }\n        \n        return { success: false, error: `Email server error: ${response.status} ${response.statusText}` };\n      }\n\n      const result = await response.json();\n      console.log('Email server result:', result);\n\n      if (!result.success) {\n        return { success: false, error: result.error || 'Failed to send test email' };\n      }\n\n      return { \n        success: true, \n        data: { \n          messageId: result.messageId,\n          previewUrl: result.previewUrl \n        } \n      };\n    } catch (error) {\n      console.error('Unexpected error testing email configuration:', error);\n      return { success: false, error: `Failed to test email configuration: ${error.message}` };\n    }\n  }\n}\n\nexport const emailConfigurationService = EmailConfigurationService.getInstance();","import { supabase } from '@/lib/supabaseClient';\n\nexport interface CountryEmailSetting {\n  id?: string;\n  country_id: string;\n  country_name?: string;\n  country_code?: string;\n  cc_emails: string[];\n  bcc_emails: string[];\n  is_active: boolean;\n  created_at?: string;\n  updated_at?: string;\n  created_by?: string;\n  updated_by?: string;\n}\n\nexport interface CountryEmailSettingResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\nclass CountryEmailSettingsService {\n  private static instance: CountryEmailSettingsService;\n  private readonly tableName = 'country_email_settings';\n\n  private constructor() {}\n\n  static getInstance(): CountryEmailSettingsService {\n    if (!CountryEmailSettingsService.instance) {\n      CountryEmailSettingsService.instance = new CountryEmailSettingsService();\n    }\n    return CountryEmailSettingsService.instance;\n  }\n\n  /**\n   * Get all country email settings with country details\n   */\n  async getCountryEmailSettings(): Promise<CountryEmailSettingResponse<CountryEmailSetting[]>> {\n    try {\n      const { data, error } = await supabase\n        .from(this.tableName)\n        .select(`\n          *, \n          countries!inner(name, code, status)\n        `)\n        .order('countries(name)', { ascending: true });\n\n      if (error) {\n        console.error('Error fetching country email settings:', error);\n        // Handle schema cache issues\n        if (error.code === 'PGRST205') {\n          console.warn('Table not found in schema cache, returning empty array');\n          return { success: true, data: [] };\n        }\n        return { success: false, error: error.message };\n      }\n\n      console.log('Country email settings fetched:', data);\n      return { success: true, data: data || [] };\n    } catch (error) {\n      console.error('Unexpected error fetching country email settings:', error);\n      return { success: false, error: 'Failed to fetch country email settings' };\n    }\n  }\n\n  /**\n   * Get country email setting by country ID\n   */\n  async getCountryEmailSettingByCountryId(countryId: string): Promise<CountryEmailSettingResponse<CountryEmailSetting | null>> {\n    try {\n      const { data, error } = await supabase\n        .from(this.tableName)\n        .select(`*, countries!inner(name, code, status)`)\n        .eq('country_id', countryId);\n\n      if (error) {\n        console.error('Error fetching country email setting:', error);\n        return { success: false, error: error.message };\n      }\n\n      // Return the first result if found, otherwise null\n      return { success: true, data: data && data.length > 0 ? data[0] : null };\n    } catch (error) {\n      console.error('Unexpected error fetching country email setting:', error);\n      return { success: false, error: 'Failed to fetch country email setting' };\n    }\n  }\n\n  /**\n   * Create or update country email setting\n   */\n  async saveCountryEmailSetting(setting: Omit<CountryEmailSetting, 'id' | 'created_at' | 'updated_at' | 'created_by' | 'updated_by'>): Promise<CountryEmailSettingResponse<CountryEmailSetting>> {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) {\n        return { success: false, error: 'User not authenticated' };\n      }\n\n      // Check if setting already exists for this country\n      const existingSetting = await this.getCountryEmailSettingByCountryId(setting.country_id);\n      \n      if (existingSetting.success && existingSetting.data) {\n        // Update existing setting\n        const { data, error } = await supabase\n          .from(this.tableName)\n          .update({\n            cc_emails: setting.cc_emails,\n            bcc_emails: setting.bcc_emails,\n            is_active: setting.is_active,\n            updated_by: user.id,\n            updated_at: new Date().toISOString()\n          })\n          .eq('country_id', setting.country_id)\n          .select()\n          .single();\n\n        if (error) {\n          console.error('Error updating country email setting:', error);\n          return { success: false, error: error.message };\n        }\n\n        return { success: true, data };\n      } else {\n        // Create new setting\n        const settingData = {\n          ...setting,\n          created_by: user.id,\n          updated_by: user.id,\n        };\n\n        const { data, error } = await supabase\n          .from(this.tableName)\n          .insert(settingData)\n          .select()\n          .single();\n\n        if (error) {\n          console.error('Error creating country email setting:', error);\n          // Handle schema cache issues\n          if (error.code === 'PGRST205') {\n            return { success: false, error: 'Country email settings table is not available. Please try again in a few moments.' };\n          }\n          return { success: false, error: error.message };\n        }\n\n        return { success: true, data };\n      }\n    } catch (error) {\n      console.error('Unexpected error saving country email setting:', error);\n      return { success: false, error: 'Failed to save country email setting' };\n    }\n  }\n\n  /**\n   * Delete country email setting\n   */\n  async deleteCountryEmailSetting(id: string): Promise<CountryEmailSettingResponse<boolean>> {\n    try {\n      const { error } = await supabase\n        .from(this.tableName)\n        .delete()\n        .eq('id', id);\n\n      if (error) {\n        console.error('Error deleting country email setting:', error);\n        return { success: false, error: error.message };\n      }\n\n      return { success: true, data: true };\n    } catch (error) {\n      console.error('Unexpected error deleting country email setting:', error);\n      return { success: false, error: 'Failed to delete country email setting' };\n    }\n  }\n\n  /**\n   * Toggle country email setting status\n   */\n  async toggleCountryEmailSettingStatus(id: string): Promise<CountryEmailSettingResponse<boolean>> {\n    try {\n      const { data: currentSetting, error: fetchError } = await supabase\n        .from(this.tableName)\n        .select('is_active')\n        .eq('id', id)\n        .single();\n\n      if (fetchError || !currentSetting) {\n        return { success: false, error: fetchError?.message || 'Country email setting not found' };\n      }\n\n      const { error } = await supabase\n        .from(this.tableName)\n        .update({ is_active: !currentSetting.is_active })\n        .eq('id', id);\n\n      if (error) {\n        console.error('Error toggling country email setting status:', error);\n        return { success: false, error: error.message };\n      }\n\n      return { success: true, data: true };\n    } catch (error) {\n      console.error('Unexpected error toggling country email setting status:', error);\n      return { success: false, error: 'Failed to toggle country email setting status' };\n    }\n  }\n\n  /**\n   * Get CC and BCC emails for a specific country\n   */\n  async getCountryEmailRecipients(countryId: string): Promise<{\n    cc_emails: string[];\n    bcc_emails: string[];\n  }> {\n    try {\n      const { data, error } = await supabase\n        .from(this.tableName)\n        .select('cc_emails, bcc_emails')\n        .eq('country_id', countryId)\n        .eq('is_active', true)\n        .single();\n\n      if (error || !data) {\n        return { cc_emails: [], bcc_emails: [] };\n      }\n\n      return {\n        cc_emails: data.cc_emails || [],\n        bcc_emails: data.bcc_emails || []\n      };\n    } catch (error) {\n      console.error('Error getting country email recipients:', error);\n      return { cc_emails: [], bcc_emails: [] };\n    }\n  }\n\n  /**\n   * Get all active countries without email settings\n   */\n  async getCountriesWithoutSettings(): Promise<CountryEmailSettingResponse<any[]>> {\n    try {\n      // First get all active countries\n      const { data: activeCountries, error: countriesError } = await supabase\n        .from('countries')\n        .select('id, name, code')\n        .eq('status', 'active');\n\n      if (countriesError) {\n        console.error('Error fetching active countries:', countriesError);\n        return { success: false, error: countriesError.message };\n      }\n\n      // Then get countries that already have email settings\n      const { data: settingsCountries, error: settingsError } = await supabase\n        .from('country_email_settings')\n        .select('country_id')\n        .eq('is_active', true);\n\n      if (settingsError) {\n        console.error('Error fetching countries with settings:', settingsError);\n        return { success: false, error: settingsError.message };\n      }\n\n      // Filter out countries that already have settings\n      const countriesWithSettings = settingsCountries?.map(s => s.country_id) || [];\n      const countriesWithoutSettings = activeCountries?.filter(country => \n        !countriesWithSettings.includes(country.id)\n      ) || [];\n\n      return { success: true, data: countriesWithoutSettings };\n    } catch (error) {\n      console.error('Unexpected error fetching countries without settings:', error);\n      return { success: false, error: 'Failed to fetch countries without settings' };\n    }\n  }\n}\n\nexport const countryEmailSettingsService = CountryEmailSettingsService.getInstance();","type QueryParams = Record<string, string | number | boolean | undefined>;\n\nexport function getBaseUrl() {\n  const port = (import.meta as any).env?.VITE_EMAIL_SERVER_PORT || 3001;\n  const baseUrl = (import.meta as any).env?.VITE_EMAIL_SERVER_URL || `http://localhost:${port}`;\n  return baseUrl;\n}\n\nfunction buildUrl(path: string, params?: QueryParams) {\n  const url = new URL(path, getBaseUrl());\n  if (params) {\n    Object.entries(params).forEach(([k, v]) => {\n      if (v !== undefined && v !== null) url.searchParams.set(k, String(v));\n    });\n  }\n  return url.toString();\n}\n\nexport async function fetchOutbox(params?: QueryParams) {\n  const res = await fetch(buildUrl('/email/outbox', params));\n  if (!res.ok) throw new Error('Failed to load outbox');\n  return res.json();\n}\n\nexport async function fetchInbox(params?: QueryParams) {\n  const res = await fetch(buildUrl('/email/inbox', params));\n  if (!res.ok) throw new Error('Failed to load inbox');\n  return res.json();\n}\n\nexport async function markInboxRead(messageId: string, read: boolean) {\n  const res = await fetch(buildUrl('/email/inbox/mark-read'), {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ messageId, read })\n  });\n  if (!res.ok) throw new Error('Failed to update read status');\n  return res.json();\n}\n\nexport async function fetchCampaigns(params?: QueryParams) {\n  const res = await fetch(buildUrl('/email/campaigns', params));\n  if (!res.ok) throw new Error('Failed to load campaigns');\n  return res.json();\n}\n\nexport async function fetchCampaignRecipients(id: string) {\n  const res = await fetch(buildUrl(`/email/campaigns/${id}/recipients`));\n  if (!res.ok) throw new Error('Failed to load recipients');\n  return res.json();\n}\n\nexport async function fetchQueueStatus() {\n  const res = await fetch(buildUrl('/email/queue/status'));\n  if (!res.ok) throw new Error('Failed to load queue status');\n  return res.json();\n}\n\nexport async function createCampaign(payload: { sender_email?: string; subject: string; body_html: string; campaign_type?: string; recipients: string[]; scheduled_at?: string; created_by?: string; config_id?: string; }) {\n  const res = await fetch(buildUrl('/email/campaigns'), {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) {\n    let err: any = {};\n    try { err = await res.json(); } catch {}\n    throw new Error(err.error || 'Failed to create campaign');\n  }\n  return res.json();\n}\n\nexport async function sendCampaignNow(id: string) {\n  const res = await fetch(buildUrl(`/email/campaigns/${id}/send-now`), { method: 'POST' });\n  if (!res.ok) throw new Error('Failed to enqueue campaign');\n  return res.json();\n}\n\nexport async function scheduleCampaign(id: string, scheduled_at: string) {\n  const res = await fetch(buildUrl(`/email/campaigns/${id}/schedule`), {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ scheduled_at })\n  });\n  if (!res.ok) throw new Error('Failed to schedule campaign');\n  return res.json();\n}\n\nexport async function webhookBounce(provider: string, payload: any) {\n  const res = await fetch(buildUrl(`/email/webhooks/${provider}`), {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) throw new Error('Webhook failed');\n  return res.json();\n}\n\nexport async function pauseCampaign(id: string) {\n  const res = await fetch(buildUrl(`/email/campaigns/${id}/pause`), { method: 'POST' });\n  if (!res.ok) throw new Error('Failed to pause campaign');\n  return res.json();\n}\n\nexport async function resumeCampaign(id: string) {\n  const res = await fetch(buildUrl(`/email/campaigns/${id}/resume`), { method: 'POST' });\n  if (!res.ok) throw new Error('Failed to resume campaign');\n  return res.json();\n}\n\nexport async function fetchDashboard() {\n  const res = await fetch(buildUrl('/email/dashboard'));\n  if (!res.ok) throw new Error('Failed to load dashboard');\n  return res.json();\n}\n","import { supabase } from '@/lib/supabaseClient'\n\nexport type Provider = { id: string, provider_name: string, base_url: string, api_key?: string, model_name?: string, priority?: number, status?: string }\n\nexport function getAiBaseUrl(): string {\n  const base = (import.meta as any).env?.VITE_AI_SERVER_URL || 'http://localhost:3004'\n  return String(base)\n}\n\nexport async function getActiveProviders(): Promise<Provider[]> {\n  const { data, error } = await supabase\n    .from('api_integrations')\n    .select('*')\n    .eq('status', 'active')\n    .order('priority', { ascending: true })\n  if (error) return []\n  return (data || []) as Provider[]\n}\n\nexport async function checkHealth(base: string): Promise<boolean> {\n  try {\n    const res = await fetch(`${base.replace(/\\/$/, '')}/health`)\n    return res.ok\n  } catch {\n    return false\n  }\n}\n\nexport async function generateEmailTemplate(args: { subject: string, category: string, providerHint?: string, contentGuide?: string }) {\n  const base = getAiBaseUrl().replace(/\\/$/, '')\n  const res = await fetch(`${base}/api/generate-email`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(args)\n  })\n  if (!res.ok) {\n    let err: any = {}\n    try { err = await res.json() } catch {}\n    throw new Error(err.error || 'AI generation failed')\n  }\n  return res.json()\n}\n","import { supabase } from '@/lib/supabaseClient';\nimport type { Tables, TablesInsert, TablesUpdate, Json } from '@/integrations/supabase/types';\nimport { CountriesService } from './countriesService';\n\n// Location resolution service for fetching location details\nexport class LocationResolutionService {\n  static async getLocationDetails(locationCode: string): Promise<{\n    full_name?: string;\n    coordinates?: Json;\n    error?: string;\n  }> {\n    try {\n      const { data, error } = await supabase\n        .from('location_codes')\n        .select('full_name, latitude, longitude')\n        .eq('code', locationCode)\n        .single();\n\n      if (error) {\n        console.warn(`Location not found for code: ${locationCode}`);\n        return { error: `Location not found for code: ${locationCode}` };\n      }\n\n      // Convert latitude/longitude to coordinates JSON format\n      const coordinates = data.latitude && data.longitude \n        ? { lat: data.latitude, lng: data.longitude }\n        : null;\n\n      return {\n        full_name: data.full_name,\n        coordinates: coordinates as Json,\n      };\n    } catch (error) {\n      console.error('Error fetching location details:', error);\n      return { error: 'Failed to fetch location details' };\n    }\n  }\n\n  static async resolveLocationFields(formData: TransportRouteFormData): Promise<TransportRouteFormData> {\n    const resolvedData = { ...formData };\n\n    // Resolve start location if only code is provided\n    if (formData.start_location && !formData.start_location_full_name) {\n      const startDetails = await this.getLocationDetails(formData.start_location);\n      if (startDetails.full_name) {\n        resolvedData.start_location_full_name = startDetails.full_name;\n        resolvedData.start_coordinates = startDetails.coordinates;\n      }\n    }\n\n    // Resolve end location if only code is provided\n    if (formData.end_location && !formData.end_location_full_name) {\n      const endDetails = await this.getLocationDetails(formData.end_location);\n      if (endDetails.full_name) {\n        resolvedData.end_location_full_name = endDetails.full_name;\n        resolvedData.end_coordinates = endDetails.coordinates;\n      }\n    }\n\n    // Resolve intermediate stops locations\n    if (formData.intermediate_stops) {\n      for (let i = 0; i < formData.intermediate_stops.length; i++) {\n        const stop = formData.intermediate_stops[i];\n        if (stop.location_code && !stop.full_name) {\n          const stopDetails = await this.getLocationDetails(stop.location_code);\n          if (stopDetails.full_name) {\n            resolvedData.intermediate_stops![i] = {\n              ...stop,\n              full_name: stopDetails.full_name,\n              coordinates: stopDetails.coordinates,\n            };\n          }\n        }\n      }\n    }\n\n    return resolvedData;\n  }\n\n  // Resolve location fields for intermediate stops\n  static async resolveStopLocation(stopData: any): Promise<any> {\n    const resolvedData = { ...stopData };\n\n    if (stopData.location_code) {\n      const locationDetails = await this.getLocationDetails(stopData.location_code);\n      if (locationDetails) {\n        resolvedData.location_full_name = locationDetails.full_name;\n        resolvedData.coordinates = locationDetails.coordinates;\n      }\n    }\n\n    return resolvedData;\n  }\n\n  // Resolve location fields for sightseeing options\n  static async resolveSightseeingLocation(optionData: any): Promise<any> {\n    const resolvedData = { ...optionData };\n\n    if (optionData.location_code) {\n      const locationDetails = await this.getLocationDetails(optionData.location_code);\n      if (locationDetails) {\n        resolvedData.location_full_name = locationDetails.full_name;\n        resolvedData.coordinates = locationDetails.coordinates;\n      }\n    }\n\n    return resolvedData;\n  }\n}\n\n// Type definitions for transport-related data\nexport type TransportRoute = Tables<'transport_routes'>;\nexport type IntermediateStop = Tables<'intermediate_stops'>;\nexport type SightseeingOption = Tables<'sightseeing_options'>;\nexport type TransportType = Tables<'transport_types'>;\n\nexport type TransportRouteInsert = TablesInsert<'transport_routes'>;\nexport type IntermediateStopInsert = TablesInsert<'intermediate_stops'>;\nexport type SightseeingOptionInsert = TablesInsert<'sightseeing_options'>;\n\nexport type TransportRouteUpdate = TablesUpdate<'transport_routes'>;\nexport type IntermediateStopUpdate = TablesUpdate<'intermediate_stops'>;\nexport type SightseeingOptionUpdate = TablesUpdate<'sightseeing_options'>;\n\n// Enhanced query options for better filtering and pagination\ninterface QueryOptions {\n  page?: number;\n  limit?: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n  filters?: {\n    country?: string;\n    transfer_type?: string;\n    status?: string;\n    search?: string;\n    start_location?: string;\n    end_location?: string;\n  };\n}\n\n// Response interface for paginated results\ninterface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  limit: number;\n  totalPages: number;\n}\n\n// Complete route data with relationships\nexport interface CompleteTransportRoute extends TransportRoute {\n  intermediate_stops?: IntermediateStop[];\n  sightseeing_options?: SightseeingOption[];\n}\n\n// Form data structure for creating/updating routes\nexport interface TransportRouteFormData {\n  // Basic route information\n  id?: string;\n  route_code?: string;\n  route_name: string;\n  country: string;\n  transfer_type: 'One-Way' | 'Round-Trip' | 'Multi-Stop' | 'en route';\n  \n  // Location information\n  start_location: string;\n  start_location_full_name: string;\n  start_coordinates?: Json;\n  end_location: string;\n  end_location_full_name: string;\n  end_coordinates?: Json;\n  \n  // Route details\n  distance?: number;\n  duration?: string;\n  description?: string;\n  notes?: string;\n  status?: string;\n  enable_sightseeing?: boolean;\n  name?: string;\n  \n  // Related data\n  intermediate_stops?: Omit<IntermediateStopInsert, 'route_id'>[];\n  sightseeing_options?: Omit<SightseeingOptionInsert, 'route_id'>[];\n}\n\nexport class ComprehensiveTransportService {\n  /**\n   * Create a new transport route with all related data\n   */\n  static async createCompleteRoute(formData: TransportRouteFormData): Promise<{\n    success: boolean;\n    data?: CompleteTransportRoute;\n    error?: string;\n  }> {\n    try {\n      // Resolve location data before validation\n      const resolvedFormData = await LocationResolutionService.resolveLocationFields(formData);\n\n      // Validate the form data including secure country validation\n      const validation = await this.validateRouteData(resolvedFormData);\n      if (!validation.isValid) {\n        throw new Error(`Validation failed: ${validation.errors.join(', ')}`);\n      }\n\n      // Start a transaction by creating the main route first\n      const routeData: TransportRouteInsert = {\n        route_code: resolvedFormData.route_code || this.generateRouteCode(resolvedFormData),\n        route_name: resolvedFormData.route_name,\n        country: resolvedFormData.country,\n        transfer_type: resolvedFormData.transfer_type,\n        start_location: resolvedFormData.start_location,\n        start_location_full_name: resolvedFormData.start_location_full_name,\n        start_coordinates: resolvedFormData.start_coordinates,\n        end_location: resolvedFormData.end_location,\n        end_location_full_name: resolvedFormData.end_location_full_name,\n        end_coordinates: resolvedFormData.end_coordinates,\n        distance: resolvedFormData.distance,\n        duration: resolvedFormData.duration,\n        notes: resolvedFormData.notes,\n        status: resolvedFormData.status || 'active',\n        enable_sightseeing: resolvedFormData.enable_sightseeing || false,\n        name: resolvedFormData.name,\n      };\n\n      const { data: route, error: routeError } = await supabase\n        .from('transport_routes')\n        .insert(routeData)\n        .select()\n        .single();\n\n      if (routeError) {\n        throw new Error(`Failed to create route: ${routeError.message}`);\n      }\n\n      // Create intermediate stops if provided\n      let intermediateStops: IntermediateStop[] = [];\n      if (resolvedFormData.intermediate_stops && resolvedFormData.intermediate_stops.length > 0) {\n        // Resolve location data for each stop\n        const resolvedStops = await Promise.all(\n          resolvedFormData.intermediate_stops.map(stop => \n            LocationResolutionService.resolveStopLocation(stop)\n          )\n        );\n        \n        const stopsData = resolvedStops.map((stop, index) => ({\n          ...stop,\n          route_id: route.id,\n          stop_order: stop.stop_order || index + 1,\n        }));\n\n        const { data: stops, error: stopsError } = await supabase\n          .from('intermediate_stops')\n          .insert(stopsData)\n          .select();\n\n        if (stopsError) {\n          // Rollback: delete the created route\n          await supabase.from('transport_routes').delete().eq('id', route.id);\n          throw new Error(`Failed to create intermediate stops: ${stopsError.message}`);\n        }\n\n        intermediateStops = stops;\n      }\n\n      // Create sightseeing options if provided\n      let sightseeingOptions: SightseeingOption[] = [];\n      if (resolvedFormData.sightseeing_options && resolvedFormData.sightseeing_options.length > 0) {\n        // Resolve location data for each sightseeing option\n        const resolvedOptions = await Promise.all(\n          resolvedFormData.sightseeing_options.map(option => \n            LocationResolutionService.resolveSightseeingLocation(option)\n          )\n        );\n        \n        const sightseeingData = resolvedOptions.map(option => ({\n          ...option,\n          route_id: route.id,\n        }));\n\n        const { data: options, error: optionsError } = await supabase\n          .from('sightseeing_options')\n          .insert(sightseeingData)\n          .select();\n\n        if (optionsError) {\n          // Rollback: delete created route and stops\n          await supabase.from('transport_routes').delete().eq('id', route.id);\n          throw new Error(`Failed to create sightseeing options: ${optionsError.message}`);\n        }\n\n        sightseeingOptions = options;\n      }\n\n      return {\n        success: true,\n        data: {\n          ...route,\n          intermediate_stops: intermediateStops,\n          sightseeing_options: sightseeingOptions,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Get a transport route with all related data\n   */\n  static async getCompleteRoute(routeId: string): Promise<{\n    success: boolean;\n    data?: CompleteTransportRoute;\n    error?: string;\n  }> {\n    try {\n      const { data: route, error: routeError } = await supabase\n        .from('transport_routes')\n        .select(`\n          *,\n          intermediate_stops(*),\n          sightseeing_options(*)\n        `)\n        .eq('id', routeId)\n        .single();\n\n      if (routeError) {\n        throw new Error(`Failed to fetch route: ${routeError.message}`);\n      }\n\n      return {\n        success: true,\n        data: route,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Get all transport routes with enhanced filtering and pagination\n   */\n  static async getCompleteRoutes(options: QueryOptions = {}): Promise<{\n    success: boolean;\n    data?: PaginatedResponse<CompleteTransportRoute>;\n    error?: string;\n  }> {\n    try {\n      const {\n        page = 1,\n        limit = 10,\n        sortBy = 'created_at',\n        sortOrder = 'desc',\n        filters = {}\n      } = options;\n\n      // Auth guard: avoid unauthenticated calls to protected tables\n      const { data: { session }, error: authError } = await supabase.auth.getSession();\n      if (authError || !session) {\n        return {\n          success: true,\n          data: {\n            data: [],\n            total: 0,\n            page,\n            limit,\n            totalPages: 0\n          }\n        };\n      }\n\n      // Calculate offset for pagination\n      const offset = (page - 1) * limit;\n\n      // Build the base query\n      let query = supabase\n        .from('transport_routes')\n        .select(`\n          *,\n          intermediate_stops(*),\n          sightseeing_options(*)\n        `, { count: 'exact' });\n\n      // Apply filters\n      if (filters.country) {\n        query = query.eq('country', filters.country);\n      }\n      if (filters.transfer_type) {\n        query = query.eq('transfer_type', filters.transfer_type);\n      }\n      if (filters.status) {\n        query = query.eq('status', filters.status);\n      }\n      if (filters.start_location) {\n        query = query.eq('start_location', filters.start_location);\n      }\n      if (filters.end_location) {\n        query = query.eq('end_location', filters.end_location);\n      }\n      if (filters.search) {\n        query = query.or(`route_name.ilike.%${filters.search}%,route_code.ilike.%${filters.search}%,notes.ilike.%${filters.search}%`);\n      }\n\n      // Apply sorting\n      query = query.order(sortBy, { ascending: sortOrder === 'asc' });\n\n      // Apply pagination\n      query = query.range(offset, offset + limit - 1);\n\n      const { data: routes, error: routesError, count } = await query;\n\n      if (routesError) {\n        throw new Error(`Failed to fetch routes: ${routesError.message}`);\n      }\n\n      const totalPages = Math.ceil((count || 0) / limit);\n\n      return {\n        success: true,\n        data: {\n          data: routes || [],\n          total: count || 0,\n          page,\n          limit,\n          totalPages\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Update a transport route and its related data\n   */\n  static async updateCompleteRoute(\n    routeId: string,\n    formData: Partial<TransportRouteFormData>\n  ): Promise<{\n    success: boolean;\n    data?: CompleteTransportRoute;\n    error?: string;\n  }> {\n    try {\n      // Resolve location data before validation if route data is provided\n      let resolvedFormData = formData;\n      if (Object.keys(formData).length > 0) {\n        resolvedFormData = await LocationResolutionService.resolveLocationFields(formData as TransportRouteFormData);\n        \n        const validation = await this.validateRouteData(resolvedFormData as TransportRouteFormData);\n        if (!validation.isValid) {\n          throw new Error(`Validation failed: ${validation.errors.join(', ')}`);\n        }\n      }\n\n      // Update the main route\n      const routeUpdateData: TransportRouteUpdate = {};\n      \n      // Only include fields that are provided\n      if (resolvedFormData.route_name !== undefined) routeUpdateData.route_name = resolvedFormData.route_name;\n      if (resolvedFormData.country !== undefined) routeUpdateData.country = resolvedFormData.country;\n      if (resolvedFormData.transfer_type !== undefined) routeUpdateData.transfer_type = resolvedFormData.transfer_type;\n      if (resolvedFormData.start_location !== undefined) routeUpdateData.start_location = resolvedFormData.start_location;\n      if (resolvedFormData.start_location_full_name !== undefined) routeUpdateData.start_location_full_name = resolvedFormData.start_location_full_name;\n      if (resolvedFormData.start_coordinates !== undefined) routeUpdateData.start_coordinates = resolvedFormData.start_coordinates;\n      if (resolvedFormData.end_location !== undefined) routeUpdateData.end_location = resolvedFormData.end_location;\n      if (resolvedFormData.end_location_full_name !== undefined) routeUpdateData.end_location_full_name = resolvedFormData.end_location_full_name;\n      if (resolvedFormData.end_coordinates !== undefined) routeUpdateData.end_coordinates = resolvedFormData.end_coordinates;\n      if (resolvedFormData.distance !== undefined) routeUpdateData.distance = resolvedFormData.distance;\n      if (resolvedFormData.duration !== undefined) routeUpdateData.duration = resolvedFormData.duration;\n      if (resolvedFormData.notes !== undefined) routeUpdateData.notes = resolvedFormData.notes;\n      if (resolvedFormData.status !== undefined) routeUpdateData.status = resolvedFormData.status;\n      if (resolvedFormData.enable_sightseeing !== undefined) routeUpdateData.enable_sightseeing = resolvedFormData.enable_sightseeing;\n      if (resolvedFormData.name !== undefined) routeUpdateData.name = resolvedFormData.name;\n\n      const { data: route, error: routeError } = await supabase\n        .from('transport_routes')\n        .update(routeUpdateData)\n        .eq('id', routeId)\n        .select()\n        .single();\n\n      if (routeError) {\n        throw new Error(`Failed to update route: ${routeError.message}`);\n      }\n\n      // Handle intermediate stops updates if provided\n      if (resolvedFormData.intermediate_stops !== undefined) {\n        // Delete existing stops\n        await supabase.from('intermediate_stops').delete().eq('route_id', routeId);\n\n        // Create new stops\n        if (resolvedFormData.intermediate_stops.length > 0) {\n          // Resolve location data for each stop\n          const resolvedStops = await Promise.all(\n            resolvedFormData.intermediate_stops.map(stop => \n              LocationResolutionService.resolveStopLocation(stop)\n            )\n          );\n          \n          const stopsData = resolvedStops.map((stop, index) => ({\n            ...stop,\n            route_id: routeId,\n            stop_order: stop.stop_order || index + 1,\n          }));\n\n          const { error: stopsError } = await supabase\n            .from('intermediate_stops')\n            .insert(stopsData);\n\n          if (stopsError) {\n            throw new Error(`Failed to update intermediate stops: ${stopsError.message}`);\n          }\n        }\n      }\n\n      // Handle sightseeing options updates if provided\n      if (resolvedFormData.sightseeing_options !== undefined) {\n        // Delete existing options\n        await supabase.from('sightseeing_options').delete().eq('route_id', routeId);\n\n        // Create new options\n        if (resolvedFormData.sightseeing_options.length > 0) {\n          // Resolve location data for each sightseeing option\n          const resolvedOptions = await Promise.all(\n            resolvedFormData.sightseeing_options.map(option => \n              LocationResolutionService.resolveSightseeingLocation(option)\n            )\n          );\n          \n          const sightseeingData = resolvedOptions.map(option => ({\n            ...option,\n            route_id: routeId,\n          }));\n\n          const { error: optionsError } = await supabase\n            .from('sightseeing_options')\n            .insert(sightseeingData);\n\n          if (optionsError) {\n            throw new Error(`Failed to update sightseeing options: ${optionsError.message}`);\n          }\n        }\n      }\n\n      // Fetch the updated route with all relationships\n      return await this.getCompleteRoute(routeId);\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Delete a transport route and all related data\n   */\n  static async deleteCompleteRoute(routeId: string): Promise<{\n    success: boolean;\n    error?: string;\n  }> {\n    try {\n      // Delete the route (cascade will handle related data)\n      const { error: deleteError } = await supabase\n        .from('transport_routes')\n        .delete()\n        .eq('id', routeId);\n\n      if (deleteError) {\n        throw new Error(`Failed to delete route: ${deleteError.message}`);\n      }\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Get available transport types (reference table)\n   */\n  static async getTransportTypes(): Promise<{\n    success: boolean;\n    data?: TransportType[];\n    error?: string;\n  }> {\n    try {\n      // Auth guard: avoid unauthenticated calls to protected tables\n      const { data: { session }, error: authError } = await supabase.auth.getSession();\n      if (authError || !session) {\n        return {\n          success: true,\n          data: []\n        };\n      }\n\n      const { data: types, error: typesError } = await supabase\n        .from('transport_types')\n        .select('*')\n        .eq('active', true)\n        .order('name');\n\n      if (typesError) {\n        throw new Error(`Failed to fetch transport types: ${typesError.message}`);\n      }\n\n      return {\n        success: true,\n        data: types || [],\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Manage intermediate stops for a route\n   */\n  static async manageIntermediateStops(\n    routeId: string,\n    stops: Omit<IntermediateStopInsert, 'route_id'>[]\n  ): Promise<{\n    success: boolean;\n    data?: IntermediateStop[];\n    error?: string;\n  }> {\n    try {\n      // Delete existing stops\n      await supabase.from('intermediate_stops').delete().eq('route_id', routeId);\n\n      if (stops.length === 0) {\n        return { success: true, data: [] };\n      }\n\n      // Create new stops\n      const stopsData = stops.map((stop, index) => ({\n        ...stop,\n        route_id: routeId,\n        stop_order: stop.stop_order || index + 1,\n      }));\n\n      const { data: newStops, error: stopsError } = await supabase\n        .from('intermediate_stops')\n        .insert(stopsData)\n        .select();\n\n      if (stopsError) {\n        throw new Error(`Failed to manage intermediate stops: ${stopsError.message}`);\n      }\n\n      return {\n        success: true,\n        data: newStops,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Enhanced intermediate stops management\n   */\n  static async getIntermediateStops(routeId: string): Promise<{\n    success: boolean;\n    data?: IntermediateStop[];\n    error?: string;\n  }> {\n    try {\n      const { data, error } = await supabase\n        .from('intermediate_stops')\n        .select('*')\n        .eq('route_id', routeId)\n        .order('stop_order', { ascending: true });\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        data: data || []\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to fetch intermediate stops'\n      };\n    }\n  }\n\n  static async createIntermediateStop(stopData: Omit<IntermediateStopInsert, 'id'>): Promise<{\n    success: boolean;\n    data?: IntermediateStop;\n    error?: string;\n  }> {\n    try {\n      // Resolve location data before creating\n      const resolvedStopData = await LocationResolutionService.resolveStopLocation(stopData);\n      \n      const { data, error } = await supabase\n        .from('intermediate_stops')\n        .insert(resolvedStopData)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        data\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to create intermediate stop'\n      };\n    }\n  }\n\n  static async updateIntermediateStop(id: string, updates: IntermediateStopUpdate): Promise<{\n    success: boolean;\n    data?: IntermediateStop;\n    error?: string;\n  }> {\n    try {\n      const { data, error } = await supabase\n        .from('intermediate_stops')\n        .update(updates)\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        data\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to update intermediate stop'\n      };\n    }\n  }\n\n  static async deleteIntermediateStop(id: string): Promise<{\n    success: boolean;\n    error?: string;\n  }> {\n    try {\n      const { error } = await supabase\n        .from('intermediate_stops')\n        .delete()\n        .eq('id', id);\n\n      if (error) throw error;\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to delete intermediate stop'\n      };\n    }\n  }\n\n  static async reorderIntermediateStops(routeId: string, stopIds: string[]): Promise<{\n    success: boolean;\n    error?: string;\n  }> {\n    try {\n      // Update stop_order for each stop\n      const updates = stopIds.map((stopId, index) => \n        supabase\n          .from('intermediate_stops')\n          .update({ stop_order: index + 1 })\n          .eq('id', stopId)\n          .eq('route_id', routeId)\n      );\n\n      await Promise.all(updates);\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to reorder intermediate stops'\n      };\n    }\n  }\n\n  /**\n   * Manage sightseeing options for a route\n   */\n  static async manageSightseeingOptions(\n    routeId: string,\n    options: Omit<SightseeingOptionInsert, 'route_id'>[]\n  ): Promise<{\n    success: boolean;\n    data?: SightseeingOption[];\n    error?: string;\n  }> {\n    try {\n      // Delete existing options\n      await supabase.from('sightseeing_options').delete().eq('route_id', routeId);\n\n      if (options.length === 0) {\n        return { success: true, data: [] };\n      }\n\n      // Create new options\n      const optionsData = options.map(option => ({\n        ...option,\n        route_id: routeId,\n      }));\n\n      const { data: newOptions, error: optionsError } = await supabase\n        .from('sightseeing_options')\n        .insert(optionsData)\n        .select();\n\n      if (optionsError) {\n        throw new Error(`Failed to manage sightseeing options: ${optionsError.message}`);\n      }\n\n      return {\n        success: true,\n        data: newOptions,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Enhanced sightseeing options management\n   */\n  static async getSightseeingOptions(routeId: string): Promise<{\n    success: boolean;\n    data?: SightseeingOption[];\n    error?: string;\n  }> {\n    try {\n      const { data, error } = await supabase\n        .from('sightseeing_options')\n        .select('*')\n        .eq('route_id', routeId)\n        .order('created_at', { ascending: true });\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        data: data || []\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to fetch sightseeing options'\n      };\n    }\n  }\n\n  static async createSightseeingOption(optionData: Omit<SightseeingOptionInsert, 'id'>): Promise<{\n    success: boolean;\n    data?: SightseeingOption;\n    error?: string;\n  }> {\n    try {\n      // Resolve location data before creating\n      const resolvedOptionData = await LocationResolutionService.resolveSightseeingLocation(optionData);\n      \n      const { data, error } = await supabase\n        .from('sightseeing_options')\n        .insert(resolvedOptionData)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        data\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to create sightseeing option'\n      };\n    }\n  }\n\n  static async updateSightseeingOption(id: string, updates: SightseeingOptionUpdate): Promise<{\n    success: boolean;\n    data?: SightseeingOption;\n    error?: string;\n  }> {\n    try {\n      const { data, error } = await supabase\n        .from('sightseeing_options')\n        .update(updates)\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        data\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to update sightseeing option'\n      };\n    }\n  }\n\n  static async deleteSightseeingOption(id: string): Promise<{\n    success: boolean;\n    error?: string;\n  }> {\n    try {\n      const { error } = await supabase\n        .from('sightseeing_options')\n        .delete()\n        .eq('id', id);\n\n      if (error) throw error;\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to delete sightseeing option'\n      };\n    }\n  }\n\n  /**\n   * Generate a route code based on route data\n   */\n  private static generateRouteCode(formData: TransportRouteFormData): string {\n    const start = formData.start_location.substring(0, 3).toUpperCase();\n    const end = formData.end_location.substring(0, 3).toUpperCase();\n    const type = formData.transfer_type.substring(0, 2).toUpperCase();\n    const timestamp = Date.now().toString().slice(-4);\n    \n    return `${start}-${end}-${type}-${timestamp}`;\n  }\n\n  /**\n   * Validate country against active countries from public.countries table\n   */\n  static async validateCountry(countryName: string): Promise<{\n    isValid: boolean;\n    error?: string;\n  }> {\n    try {\n      if (!countryName?.trim()) {\n        return { isValid: false, error: 'Country is required' };\n      }\n\n      // Get active countries from secure public.countries table\n      const response = await CountriesService.getCountriesByStatus('active');\n      \n      if (!response.success || !response.data || response.data.length === 0) {\n        return { \n          isValid: false, \n          error: response.error || 'No active countries available' \n        };\n      }\n\n      // Check if the provided country exists in active countries\n      const countryExists = response.data.some(\n        country => country.name.toLowerCase() === countryName.toLowerCase()\n      );\n\n      if (!countryExists) {\n        const availableCountries = response.data.map(c => c.name).join(', ');\n        return { \n          isValid: false, \n          error: `Invalid country. Available countries: ${availableCountries}` \n        };\n      }\n\n      return { isValid: true };\n    } catch (error) {\n      console.error('Error validating country:', error);\n      return { \n        isValid: false, \n        error: 'Failed to validate country. Please try again.' \n      };\n    }\n  }\n\n  /**\n   * Get list of active countries for form dropdowns\n   */\n  static async getActiveCountries(): Promise<Tables<'countries'>[]> {\n    try {\n      const response = await CountriesService.getCountriesByStatus('active');\n      if (response.success && response.data) {\n        return response.data;\n      }\n      console.error('Error fetching active countries:', response.error);\n      return [];\n    } catch (error) {\n      console.error('Error fetching active countries:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Validate route data before submission\n   */\n  static async validateRouteData(formData: TransportRouteFormData): Promise<{\n    isValid: boolean;\n    errors: string[];\n  }> {\n    const errors: string[] = [];\n\n    // Required fields validation\n    if (!formData.route_name?.trim()) {\n      errors.push('Route name is required');\n    }\n    \n    // Validate country using secure public.countries table\n    const countryValidation = await this.validateCountry(formData.country);\n    if (!countryValidation.isValid) {\n      errors.push(countryValidation.error || 'Invalid country');\n    }\n    if (!formData.transfer_type) {\n      errors.push('Transfer type is required');\n    }\n    if (!formData.start_location?.trim()) {\n      errors.push('Start location is required');\n    }\n    if (!formData.start_location_full_name?.trim()) {\n      errors.push('Start location full name is required');\n    }\n    if (!formData.end_location?.trim()) {\n      errors.push('End location is required');\n    }\n    if (!formData.end_location_full_name?.trim()) {\n      errors.push('End location full name is required');\n    }\n\n    // Transfer type validation\n    const validTransferTypes = ['One-Way', 'Round-Trip', 'Multi-Stop', 'en route'];\n    if (formData.transfer_type && !validTransferTypes.includes(formData.transfer_type)) {\n      errors.push('Invalid transfer type');\n    }\n\n    // Intermediate stops validation for Multi-Stop routes\n    if (formData.transfer_type === 'Multi-Stop') {\n      if (!formData.intermediate_stops || formData.intermediate_stops.length === 0) {\n        errors.push('Multi-Stop routes must have at least one intermediate stop');\n      }\n    }\n\n    // Sightseeing options validation\n    if (formData.enable_sightseeing && formData.sightseeing_options) {\n      formData.sightseeing_options.forEach((option, index) => {\n        if (!option.location?.trim()) {\n          errors.push(`Sightseeing option ${index + 1}: Location is required`);\n        }\n        if (option.adult_price !== undefined && option.adult_price < 0) {\n          errors.push(`Sightseeing option ${index + 1}: Adult price cannot be negative`);\n        }\n        if (option.child_price !== undefined && option.child_price < 0) {\n          errors.push(`Sightseeing option ${index + 1}: Child price cannot be negative`);\n        }\n      });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Get route statistics\n   */\n  static async getRouteStatistics(): Promise<{\n    success: boolean;\n    data?: {\n      totalRoutes: number;\n      routesByTransferType: Record<string, number>;\n      routesByCountry: Record<string, number>;\n      routesWithSightseeing: number;\n      routesWithIntermediateStops: number;\n    };\n    error?: string;\n  }> {\n    try {\n      // Auth guard: avoid unauthenticated calls to protected tables\n      const { data: { session }, error: authError } = await supabase.auth.getSession();\n      if (authError || !session) {\n        return {\n          success: true,\n          data: {\n            totalRoutes: 0,\n            routesByTransferType: {},\n            routesByCountry: {},\n            routesWithSightseeing: 0,\n            routesWithIntermediateStops: 0\n          }\n        };\n      }\n\n      // Get total routes\n      const { count: totalRoutes, error: countError } = await supabase\n        .from('transport_routes')\n        .select('*', { count: 'exact', head: true });\n\n      if (countError) {\n        throw new Error(`Failed to get route count: ${countError.message}`);\n      }\n\n      // Get routes by transfer type\n      const { data: transferTypeData, error: transferTypeError } = await supabase\n        .from('transport_routes')\n        .select('transfer_type');\n\n      if (transferTypeError) {\n        throw new Error(`Failed to get transfer type data: ${transferTypeError.message}`);\n      }\n\n      // Get routes by country\n      const { data: countryData, error: countryError } = await supabase\n        .from('transport_routes')\n        .select('country');\n\n      if (countryError) {\n        throw new Error(`Failed to get country data: ${countryError.message}`);\n      }\n\n      // Get routes with sightseeing\n      const { count: routesWithSightseeing, error: sightseeingError } = await supabase\n        .from('transport_routes')\n        .select('*', { count: 'exact', head: true })\n        .eq('enable_sightseeing', true);\n\n      if (sightseeingError) {\n        throw new Error(`Failed to get sightseeing count: ${sightseeingError.message}`);\n      }\n\n      // Get routes with intermediate stops\n      const { data: routesWithStops, error: stopsError } = await supabase\n        .from('intermediate_stops')\n        .select('route_id');\n\n      if (stopsError) {\n        throw new Error(`Failed to get intermediate stops data: ${stopsError.message}`);\n      }\n\n      // Process data\n      const routesByTransferType = transferTypeData.reduce((acc, route) => {\n        acc[route.transfer_type] = (acc[route.transfer_type] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n\n      const routesByCountry = countryData.reduce((acc, route) => {\n        // Add null check for country field to prevent TypeError\n        const country = route.country || 'Unknown';\n        acc[country] = (acc[country] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n\n      const uniqueRoutesWithStops = new Set(routesWithStops.map(stop => stop.route_id)).size;\n\n      return {\n        success: true,\n        data: {\n          totalRoutes: totalRoutes || 0,\n          routesByTransferType,\n          routesByCountry,\n          routesWithSightseeing: routesWithSightseeing || 0,\n          routesWithIntermediateStops: uniqueRoutesWithStops,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n}","import { adminSupabase as supabaseAdmin, supabase } from '@/lib/supabaseClient';\nimport type { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types';\n\n// Type definitions for integrated transport route data\nexport interface IntegratedTransportRoute extends Tables<'transport_routes'> {\n  start_location_details?: Tables<'location_codes'> | null;\n  end_location_details?: Tables<'location_codes'> | null;\n  intermediate_stops_data?: IntegratedIntermediateStop[];\n  transport_types_data?: Tables<'transport_types'>[];\n  sightseeing_options_data?: Tables<'sightseeing_options'>[];\n}\n\nexport interface IntegratedIntermediateStop extends Tables<'intermediate_stops'> {\n  location_details?: Tables<'location_codes'> | null;\n}\n\nexport interface CreateTransportRoutePayload {\n  // Basic route information\n  route_code: string;\n  route_name: string;\n  country: string;\n  transfer_type: 'One-Way' | 'Round-Trip' | 'Multi-Stop' | 'en route';\n  start_location_code: string;\n  end_location_code: string;\n  distance?: number;\n  duration?: string;\n  notes?: string;\n  vehicle_types?: any[];\n  luggage_capacity?: any[];\n  status?: 'active' | 'inactive';\n  enable_sightseeing?: boolean;\n  \n  // Related data\n  intermediate_stops?: Array<{\n    stop_order: number;\n    location_code: string;\n    coordinates?: { lat: number; lng: number } | null;\n    transfer_method_notes?: string | null;\n  }>;\n  transport_types?: Array<{\n    type: string;\n    seating_capacity: number;\n    luggage_capacity: number;\n    duration: string;\n    price: number;\n    notes?: string;\n  }>;\n  sightseeing_options?: Array<{\n    location: string;\n    description?: string;\n    adult_price: number;\n    child_price: number;\n    additional_charges?: number;\n  }>;\n}\n\nexport interface UpdateTransportRoutePayload extends Partial<CreateTransportRoutePayload> {\n  id: string;\n}\n\n/**\n * Integrated Transport Service\n * Handles proper relationships between location_codes, transport_routes, and intermediate_stops tables\n */\nexport class IntegratedTransportService {\n  private static instance: IntegratedTransportService;\n\n  static getInstance(): IntegratedTransportService {\n    if (!IntegratedTransportService.instance) {\n      IntegratedTransportService.instance = new IntegratedTransportService();\n    }\n    return IntegratedTransportService.instance;\n  }\n\n  /**\n   * Validate that location codes exist in the location_codes table\n   */\n  private async validateLocationCodes(codes: string[]): Promise<{ valid: string[]; invalid: string[] }> {\n    const { data: existingCodes, error } = await supabaseAdmin\n      .from('location_codes')\n      .select('code')\n      .in('code', codes)\n      .eq('status', 'active');\n\n    if (error) {\n      throw new Error(`Failed to validate location codes: ${error.message}`);\n    }\n\n    const validCodes = existingCodes?.map(item => item.code) || [];\n    const invalidCodes = codes.filter(code => !validCodes.includes(code));\n\n    return { valid: validCodes, invalid: invalidCodes };\n  }\n\n  /**\n   * Get location details by code\n   */\n  private async getLocationDetails(code: string): Promise<Tables<'location_codes'> | null> {\n    const { data, error } = await supabaseAdmin\n      .from('location_codes')\n      .select('*')\n      .eq('code', code)\n      .eq('status', 'active')\n      .single();\n\n    if (error) {\n      console.warn(`Failed to get location details for code ${code}:`, error.message);\n      return null;\n    }\n\n    return data;\n  }\n\n  /**\n   * Create a new transport route with proper table relationships\n   */\n  async createTransportRoute(payload: CreateTransportRoutePayload): Promise<{\n    success: boolean;\n    data?: IntegratedTransportRoute;\n    error?: string;\n  }> {\n    try {\n      // Validate transfer type against allowed values\n      const allowedTypes = new Set(['One-Way', 'Round-Trip', 'Multi-Stop', 'en route']);\n      if (!allowedTypes.has(payload.transfer_type)) {\n        return {\n          success: false,\n          error: 'Invalid transfer_type. Allowed values: One-Way, Round-Trip, Multi-Stop, en route'\n        };\n      }\n\n      // Validate all location codes\n      const allLocationCodes = [\n        payload.start_location_code,\n        payload.end_location_code,\n        ...(payload.intermediate_stops?.map(stop => stop.location_code) || [])\n      ];\n\n      const { valid, invalid } = await this.validateLocationCodes(allLocationCodes);\n      if (invalid.length > 0) {\n        return {\n          success: false,\n          error: `Location code ${invalid[0]} not found in location_codes table`\n        };\n      }\n\n      // Get location details for start and end locations\n      const [startLocationDetails, endLocationDetails] = await Promise.all([\n        this.getLocationDetails(payload.start_location_code),\n        this.getLocationDetails(payload.end_location_code)\n      ]);\n\n      if (!startLocationDetails || !endLocationDetails) {\n        return {\n          success: false,\n          error: 'Failed to retrieve location details for start or end location'\n        };\n      }\n\n      // Compute full names and a safe route name (never empty)\n      const startFullName = startLocationDetails.full_name || payload.start_location_code;\n      const endFullName = endLocationDetails.full_name || payload.end_location_code;\n      const startCoordinates = (startLocationDetails.latitude != null && startLocationDetails.longitude != null)\n        ? { lat: startLocationDetails.latitude, lng: startLocationDetails.longitude }\n        : null;\n      const endCoordinates = (endLocationDetails.latitude != null && endLocationDetails.longitude != null)\n        ? { lat: endLocationDetails.latitude, lng: endLocationDetails.longitude }\n        : null;\n      const computedRouteName = (payload.route_name && payload.route_name.trim().length > 0)\n        ? payload.route_name.trim()\n        : `${startFullName}  ${endFullName}`;\n\n      // Generate route code if not provided: {start}-{end}-{type_short}{index}\n      const typeShortMap: Record<string, string> = {\n        'One-Way': 'OW',\n        'Round-Trip': 'RT',\n        'Multi-Stop': 'MS',\n        'en route': 'ER'\n      };\n      let routeCode = (payload.route_code || '').trim();\n      if (!routeCode) {\n        const { count } = await supabaseAdmin\n          .from('transport_routes')\n          .select('*', { count: 'exact', head: true })\n          .eq('start_location', payload.start_location_code)\n          .eq('end_location', payload.end_location_code)\n          .eq('transfer_type', payload.transfer_type);\n        const nextIndex = ((count as number) || 0) + 1;\n        const indexStr = String(nextIndex).padStart(2, '0');\n        const typeShort = typeShortMap[payload.transfer_type] || payload.transfer_type.substring(0, 2).toUpperCase();\n        routeCode = `${payload.start_location_code}-${payload.end_location_code}-${typeShort}${indexStr}`;\n      }\n\n      // Start transaction\n      const { data: route, error: routeError } = await supabaseAdmin\n        .from('transport_routes')\n        .insert({\n          route_code: routeCode,\n          route_name: computedRouteName,\n          name: computedRouteName,\n          country: payload.country,\n          transfer_type: payload.transfer_type,\n          // Map to live schema columns\n          start_location: payload.start_location_code,\n          end_location: payload.end_location_code,\n          // Store full names when available\n          start_location_full_name: startFullName,\n          end_location_full_name: endFullName,\n          start_coordinates: startCoordinates,\n          end_coordinates: endCoordinates,\n          distance: payload.distance,\n          duration: payload.duration,\n      // Live schema uses `notes` for free-text description\n      notes: payload.notes ?? '',\n      // Ensure vehicle_types is a JSON array (optional)\n      vehicle_types: Array.isArray(payload.vehicle_types)\n        ? payload.vehicle_types\n        : (payload.transport_types?.map(t => ({\n            type: t.type,\n            seating_capacity: t.seating_capacity,\n            luggage_capacity: t.luggage_capacity,\n            duration: t.duration,\n            price: t.price,\n            notes: t.notes\n          })) || []),\n      // Ensure luggage_capacity JSONB array exists (optional)\n      luggage_capacity: Array.isArray(payload.luggage_capacity)\n        ? payload.luggage_capacity\n        : (payload.transport_types?.map(t => ({\n            transport_type: t.type,\n            bags: t.luggage_capacity,\n            // kg can be provided by UI later; default to null/undefined\n            kg: undefined\n          })) || []),\n      status: payload.status || 'active',\n      enable_sightseeing: payload.enable_sightseeing || false\n    })\n        .select()\n        .single();\n\n      if (routeError) {\n        return {\n          success: false,\n          error: `Failed to create transport route: ${routeError.message}`\n        };\n      }\n\n      // Create intermediate stops if provided\n      let intermediateStopsData: IntegratedIntermediateStop[] = [];\n      if (payload.intermediate_stops && payload.intermediate_stops.length > 0) {\n        const stopsToInsert = await Promise.all(\n          payload.intermediate_stops.map(async stop => {\n            const details = await this.getLocationDetails(stop.location_code);\n            const resolvedCoords = (stop.coordinates && typeof stop.coordinates === 'object')\n              ? stop.coordinates\n              : (details && details.latitude != null && details.longitude != null\n                  ? { lat: details.latitude, lng: details.longitude }\n                  : null);\n            return {\n              route_id: route.id,\n              stop_order: stop.stop_order,\n              location_code: stop.location_code,\n              full_name: details?.full_name || stop.location_code,\n              coordinates: resolvedCoords,\n              transfer_method_notes: stop.transfer_method_notes ?? null\n            };\n          })\n        );\n\n        const { data: stops, error: stopsError } = await supabaseAdmin\n          .from('intermediate_stops')\n          .insert(stopsToInsert)\n          .select();\n\n        if (stopsError) {\n          // Rollback route creation\n          await supabaseAdmin.from('transport_routes').delete().eq('id', route.id);\n          return {\n            success: false,\n            error: `Failed to create intermediate stops: ${stopsError.message}`\n          };\n        }\n\n        // Enrich stops with location details\n        intermediateStopsData = await Promise.all(\n          (stops || []).map(async (stop) => {\n            const locationDetails = await this.getLocationDetails(stop.location_code);\n            return {\n              ...stop,\n              full_name: locationDetails?.full_name || stop.location_code,\n              location_details: locationDetails\n            };\n          })\n        );\n      }\n\n      // Create transport types if provided\n      let transportTypesData: Tables<'transport_types'>[] = [];\n      if (payload.transport_types && payload.transport_types.length > 0) {\n        const { data: types, error: typesError } = await supabaseAdmin\n          .from('transport_types')\n          .insert(\n            payload.transport_types.map(type => ({\n              route_id: route.id,\n              type: type.type,\n              seating_capacity: type.seating_capacity,\n              luggage_capacity: type.luggage_capacity,\n              duration: type.duration,\n              price: type.price,\n              notes: type.notes\n            }))\n          )\n          .select();\n\n        if (typesError) {\n          console.warn('Failed to create transport types:', typesError.message);\n        } else {\n          transportTypesData = types || [];\n        }\n      }\n\n      // Create sightseeing options if provided\n      let sightseeingOptionsData: Tables<'sightseeing_options'>[] = [];\n      if (payload.sightseeing_options && payload.sightseeing_options.length > 0) {\n        const { data: options, error: optionsError } = await supabaseAdmin\n          .from('sightseeing_options')\n          .insert(\n            payload.sightseeing_options.map(option => ({\n              route_id: route.id,\n              location: option.location,\n              description: option.description,\n              adult_price: option.adult_price,\n              child_price: option.child_price,\n              additional_charges: option.additional_charges || 0\n            }))\n          )\n          .select();\n\n        if (optionsError) {\n          console.warn('Failed to create sightseeing options:', optionsError.message);\n        } else {\n          sightseeingOptionsData = options || [];\n        }\n      }\n\n      // Return integrated route data\n      const integratedRoute: IntegratedTransportRoute = {\n        ...route,\n        start_location_details: startLocationDetails,\n        end_location_details: endLocationDetails,\n        intermediate_stops_data: intermediateStopsData,\n        transport_types_data: transportTypesData,\n        sightseeing_options_data: sightseeingOptionsData\n      };\n\n      return {\n        success: true,\n        data: integratedRoute\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\n      };\n    }\n  }\n\n  /**\n   * Get transport route with all related data\n   */\n  async getTransportRoute(id: string): Promise<{\n    success: boolean;\n    data?: IntegratedTransportRoute;\n    error?: string;\n  }> {\n    try {\n      // Get the main route\n      const { data: route, error: routeError } = await supabaseAdmin\n        .from('transport_routes')\n        .select('*')\n        .eq('id', id)\n        .single();\n\n      if (routeError) {\n        return {\n          success: false,\n          error: `Failed to get transport route: ${routeError.message}`\n        };\n      }\n\n      // Get related data in parallel\n      const [\n        startLocationDetails,\n        endLocationDetails,\n        intermediateStops,\n        transportTypes,\n        sightseeingOptions\n      ] = await Promise.all([\n        this.getLocationDetails(route.start_location),\n        this.getLocationDetails(route.end_location),\n        supabaseAdmin\n          .from('intermediate_stops')\n          .select('*')\n          .eq('route_id', id)\n          .order('stop_order'),\n        supabaseAdmin\n          .from('transport_types')\n          .select('*')\n          .eq('route_id', id),\n        supabaseAdmin\n          .from('sightseeing_options')\n          .select('*')\n          .eq('route_id', id)\n      ]);\n\n      // Enrich intermediate stops with location details\n      const enrichedStops: IntegratedIntermediateStop[] = await Promise.all(\n        (intermediateStops.data || []).map(async (stop) => {\n          const locationDetails = await this.getLocationDetails(stop.location_code);\n          return {\n            ...stop,\n            location_details: locationDetails\n          };\n        })\n      );\n\n      const integratedRoute: IntegratedTransportRoute = {\n        ...route,\n        start_location_details: startLocationDetails,\n        end_location_details: endLocationDetails,\n        intermediate_stops_data: enrichedStops,\n        transport_types_data: transportTypes.data || [],\n        sightseeing_options_data: sightseeingOptions.data || []\n      };\n\n      return {\n        success: true,\n        data: integratedRoute\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\n      };\n    }\n  }\n\n  /**\n   * List transport routes with filtering and related data\n   */\n  async listTransportRoutes(filters?: {\n    country?: string;\n    status?: string;\n    transfer_type?: string;\n    include_related?: boolean;\n  }): Promise<{\n    success: boolean;\n    data?: IntegratedTransportRoute[];\n    error?: string;\n  }> {\n    try {\n      let query = supabaseAdmin.from('transport_routes').select('*');\n\n      // Apply filters\n      if (filters?.country) {\n        query = query.eq('country', filters.country);\n      }\n      if (filters?.status) {\n        query = query.eq('status', filters.status);\n      }\n      if (filters?.transfer_type) {\n        query = query.eq('transfer_type', filters.transfer_type);\n      }\n\n      const { data: routes, error: routesError } = await query;\n\n      if (routesError) {\n        return {\n          success: false,\n          error: `Failed to list transport routes: ${routesError.message}`\n        };\n      }\n\n      // If include_related is false, return basic route data\n      if (!filters?.include_related) {\n        return {\n          success: true,\n          data: routes as IntegratedTransportRoute[]\n        };\n      }\n\n      // Enrich with related data\n      const enrichedRoutes: IntegratedTransportRoute[] = await Promise.all(\n        (routes || []).map(async (route) => {\n          const result = await this.getTransportRoute(route.id);\n          return result.data || route as IntegratedTransportRoute;\n        })\n      );\n\n      return {\n        success: true,\n        data: enrichedRoutes\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\n      };\n    }\n  }\n\n  /**\n   * Update transport route with proper relationship handling\n   */\n  async updateTransportRoute(payload: UpdateTransportRoutePayload): Promise<{\n    success: boolean;\n    data?: IntegratedTransportRoute;\n    error?: string;\n  }> {\n    try {\n      const { id, intermediate_stops, transport_types, sightseeing_options, ...routeData } = payload;\n\n      // Validate location codes if they're being updated\n      const locationCodes: string[] = [];\n      if (routeData.start_location_code) locationCodes.push(routeData.start_location_code);\n      if (routeData.end_location_code) locationCodes.push(routeData.end_location_code);\n      if (intermediate_stops) {\n        locationCodes.push(...intermediate_stops.map(stop => stop.location_code));\n      }\n\n      if (locationCodes.length > 0) {\n        const { invalid } = await this.validateLocationCodes(locationCodes);\n        if (invalid.length > 0) {\n          return {\n            success: false,\n            error: `Invalid location codes: ${invalid.join(', ')}`\n          };\n        }\n      }\n\n      // Update main route\n      // Map start/end location codes to actual columns in live schema\n      const updateBody: Record<string, any> = { ...routeData };\n      // Always bump updated_at timestamp on save\n      updateBody.updated_at = new Date().toISOString();\n      // Ensure notes is a string when updating\n      if (Object.prototype.hasOwnProperty.call(routeData, 'notes')) {\n        updateBody.notes = routeData.notes ?? '';\n      }\n      // Ensure vehicle_types is JSON array when provided\n      if (Object.prototype.hasOwnProperty.call(routeData, 'vehicle_types')) {\n        updateBody.vehicle_types = Array.isArray(routeData.vehicle_types)\n          ? routeData.vehicle_types\n          : [];\n      }\n      // Ensure luggage_capacity is JSON array when provided\n      if (Object.prototype.hasOwnProperty.call(routeData, 'luggage_capacity')) {\n        updateBody.luggage_capacity = Array.isArray(routeData.luggage_capacity)\n          ? routeData.luggage_capacity\n          : [];\n      }\n      if (routeData.start_location_code) {\n        updateBody.start_location = routeData.start_location_code;\n        const startDetails = await this.getLocationDetails(routeData.start_location_code);\n        updateBody.start_location_full_name = startDetails?.full_name || routeData.start_location_code;\n        if (startDetails && startDetails.latitude != null && startDetails.longitude != null) {\n          updateBody.start_coordinates = { lat: startDetails.latitude, lng: startDetails.longitude };\n        } else {\n          updateBody.start_coordinates = null;\n        }\n        // Remove schema-incompatible key before update\n        delete (updateBody as any).start_location_code;\n      }\n      if (routeData.end_location_code) {\n        updateBody.end_location = routeData.end_location_code;\n        const endDetails = await this.getLocationDetails(routeData.end_location_code);\n        updateBody.end_location_full_name = endDetails?.full_name || routeData.end_location_code;\n        if (endDetails && endDetails.latitude != null && endDetails.longitude != null) {\n          updateBody.end_coordinates = { lat: endDetails.latitude, lng: endDetails.longitude };\n        } else {\n          updateBody.end_coordinates = null;\n        }\n        // Remove schema-incompatible key before update\n        delete (updateBody as any).end_location_code;\n      }\n\n      // Sanitize status to allowed literals if provided\n      if (Object.prototype.hasOwnProperty.call(updateBody, 'status')) {\n        const s = updateBody.status;\n        updateBody.status = typeof s === 'boolean' ? (s ? 'active' : 'inactive') : (s === 'inactive' ? 'inactive' : 'active');\n      }\n      // Defensive: sanitize transfer_type to known values if provided\n      if (Object.prototype.hasOwnProperty.call(updateBody, 'transfer_type')) {\n        const allowed = ['One-Way', 'Round-Trip', 'Multi-Stop', 'en route'];\n        updateBody.transfer_type = allowed.includes(updateBody.transfer_type) ? updateBody.transfer_type : 'One-Way';\n      }\n\n      const { data: updatedRoute, error: routeError } = await supabaseAdmin\n        .from('transport_routes')\n        .update(updateBody)\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (routeError) {\n        return {\n          success: false,\n          error: `Failed to update transport route: ${routeError.message}`\n        };\n      }\n\n      // Update intermediate stops if provided\n      if (intermediate_stops !== undefined) {\n        // Delete existing stops\n        await supabaseAdmin\n          .from('intermediate_stops')\n          .delete()\n          .eq('route_id', id);\n\n        // Insert new stops\n        if (intermediate_stops.length > 0) {\n          const stopsToInsert = await Promise.all(\n            intermediate_stops.map(async stop => {\n              const details = await this.getLocationDetails(stop.location_code);\n              const resolvedCoords = (stop.coordinates && typeof stop.coordinates === 'object')\n                ? stop.coordinates\n                : (details && details.latitude != null && details.longitude != null\n                    ? { lat: details.latitude, lng: details.longitude }\n                    : null);\n              return {\n                route_id: id,\n                stop_order: stop.stop_order,\n                location_code: stop.location_code,\n                full_name: details?.full_name || stop.location_code,\n                coordinates: resolvedCoords,\n                transfer_method_notes: stop.transfer_method_notes ?? null\n              };\n            })\n          );\n          await supabaseAdmin\n            .from('intermediate_stops')\n            .insert(stopsToInsert);\n        }\n      }\n\n      // Update transport types if provided\n      if (transport_types !== undefined) {\n        // Delete existing types\n        await supabaseAdmin\n          .from('transport_types')\n          .delete()\n          .eq('route_id', id);\n\n        // Insert new types\n        if (transport_types.length > 0) {\n          await supabaseAdmin\n            .from('transport_types')\n            .insert(\n              transport_types.map(type => ({\n                route_id: id,\n                type: type.type,\n                seating_capacity: type.seating_capacity,\n                luggage_capacity: type.luggage_capacity,\n                duration: type.duration,\n                price: type.price,\n                notes: type.notes\n              }))\n            );\n        }\n      }\n\n      // Update sightseeing options if provided\n      if (sightseeing_options !== undefined) {\n        // Delete existing options\n        await supabaseAdmin\n          .from('sightseeing_options')\n          .delete()\n          .eq('route_id', id);\n\n        // Insert new options\n        if (sightseeing_options.length > 0) {\n          await supabaseAdmin\n            .from('sightseeing_options')\n            .insert(\n              sightseeing_options.map(option => ({\n                route_id: id,\n                location: option.location,\n                description: option.description,\n                adult_price: option.adult_price,\n                child_price: option.child_price,\n                additional_charges: option.additional_charges || 0\n              }))\n            );\n        }\n      }\n\n      // Get the updated route with all related data\n      const result = await this.getTransportRoute(id);\n      return result;\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\n      };\n    }\n  }\n\n  /**\n   * Delete transport route and all related data\n   */\n  async deleteTransportRoute(id: string): Promise<{\n    success: boolean;\n    error?: string;\n  }> {\n    try {\n      // Delete related data first (due to foreign key constraints)\n      await Promise.all([\n        supabaseAdmin.from('intermediate_stops').delete().eq('route_id', id),\n        supabaseAdmin.from('transport_types').delete().eq('route_id', id),\n        supabaseAdmin.from('sightseeing_options').delete().eq('route_id', id)\n      ]);\n\n      // Delete the main route\n      const { error: routeError } = await supabaseAdmin\n        .from('transport_routes')\n        .delete()\n        .eq('id', id);\n\n      if (routeError) {\n        return {\n          success: false,\n          error: `Failed to delete transport route: ${routeError.message}`\n        };\n      }\n\n      return { success: true };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\n      };\n    }\n  }\n\n  /**\n   * Validate data consistency across all tables\n   */\n  async validateDataConsistency(): Promise<{\n    success: boolean;\n    issues?: Array<{\n      type: 'missing_location' | 'orphaned_stop' | 'orphaned_type' | 'orphaned_sightseeing';\n      description: string;\n      route_id?: string;\n      location_code?: string;\n    }>;\n    error?: string;\n  }> {\n    try {\n      const issues: Array<{\n        type: 'missing_location' | 'orphaned_stop' | 'orphaned_type' | 'orphaned_sightseeing';\n        description: string;\n        route_id?: string;\n        location_code?: string;\n      }> = [];\n\n      // Check for routes with invalid location codes\n      const { data: routes } = await supabaseAdmin\n        .from('transport_routes')\n        .select('id, start_location, end_location');\n\n      const { data: locationCodes } = await supabaseAdmin\n        .from('location_codes')\n        .select('code')\n        .eq('status', 'active');\n\n      const validCodes = new Set(locationCodes?.map(lc => lc.code) || []);\n\n      for (const route of routes || []) {\n        if (!validCodes.has(route.start_location)) {\n          issues.push({\n            type: 'missing_location',\n            description: `Route ${route.id} has invalid start_location: ${route.start_location}`,\n            route_id: route.id,\n            location_code: route.start_location\n          });\n        }\n        if (!validCodes.has(route.end_location)) {\n          issues.push({\n            type: 'missing_location',\n            description: `Route ${route.id} has invalid end_location: ${route.end_location}`,\n            route_id: route.id,\n            location_code: route.end_location\n          });\n        }\n      }\n\n      // Check for intermediate stops with invalid location codes\n      const { data: stops } = await supabaseAdmin\n        .from('intermediate_stops')\n        .select('id, route_id, location_code');\n\n      for (const stop of stops || []) {\n        if (!validCodes.has(stop.location_code)) {\n          issues.push({\n            type: 'missing_location',\n            description: `Intermediate stop ${stop.id} has invalid location_code: ${stop.location_code}`,\n            route_id: stop.route_id,\n            location_code: stop.location_code\n          });\n        }\n      }\n\n      // Check for orphaned records\n      const routeIds = new Set(routes?.map(r => r.id) || []);\n\n      // Check orphaned intermediate stops\n      for (const stop of stops || []) {\n        if (!routeIds.has(stop.route_id)) {\n          issues.push({\n            type: 'orphaned_stop',\n            description: `Intermediate stop ${stop.id} references non-existent route: ${stop.route_id}`,\n            route_id: stop.route_id\n          });\n        }\n      }\n\n      return {\n        success: true,\n        issues\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\n      };\n    }\n  }\n}\n\n// Export singleton instance\nexport const integratedTransportService = IntegratedTransportService.getInstance();\n\n// Export convenience functions\nexport const createIntegratedTransportRoute = (payload: CreateTransportRoutePayload) =>\n  integratedTransportService.createTransportRoute(payload);\n\nexport const getIntegratedTransportRoute = (id: string) =>\n  integratedTransportService.getTransportRoute(id);\n\nexport const listIntegratedTransportRoutes = (filters?: Parameters<typeof integratedTransportService.listTransportRoutes>[0]) =>\n  integratedTransportService.listTransportRoutes(filters);\n\nexport const updateIntegratedTransportRoute = (payload: UpdateTransportRoutePayload) =>\n  integratedTransportService.updateTransportRoute(payload);\n\nexport const deleteIntegratedTransportRoute = (id: string) =>\n  integratedTransportService.deleteTransportRoute(id);\n\nexport const validateTransportDataConsistency = () =>\n  integratedTransportService.validateDataConsistency();","import { supabase } from '@/lib/supabaseClient';\n\nexport interface TransportRouteDetails {\n  id: string;\n  route_code?: string | null;\n  route_name?: string | null;\n  country?: string | null;\n  transfer_type?: string | null;\n  start_location?: string | null;\n  start_location_full_name?: string | null;\n  end_location?: string | null;\n  end_location_full_name?: string | null;\n  duration?: string | null;\n  distance?: number | null;\n  notes?: string | null;\n  status?: string | null;\n  vehicleTypes: Array<any>;\n  luggageCapacity: Array<any>;\n  stops: Array<any>;\n  sightseeing: Array<any>;\n  [key: string]: any;\n}\n\n// Safely parse potential JSON arrays (stringified or already arrays)\nfunction parseJsonArraySafely(value: unknown): any[] {\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string' && value.trim().length > 0) {\n    try {\n      const parsed = JSON.parse(value);\n      return Array.isArray(parsed) ? parsed : [];\n    } catch {\n      return [];\n    }\n  }\n  return [];\n}\n\n// Simple in-memory cache for location full names to reduce duplicate lookups\nconst locationNameCache: Record<string, string> = {};\n\nasync function getLocationFullName(code: string | null | undefined): Promise<string | null> {\n  if (!code) return null;\n  const cached = locationNameCache[code];\n  if (cached) return cached;\n  const { data, error } = await supabase\n    .from('location_codes')\n    .select('code, full_name')\n    .eq('code', code)\n    .maybeSingle();\n  if (error) return null;\n  const name = (data?.full_name as string | undefined) || null;\n  if (name) locationNameCache[code] = name;\n  return name;\n}\n\n// Fetch a single transport route with parsed JSON fields and related tables\nexport async function getTransportRouteDetails(route_id: string): Promise<TransportRouteDetails> {\n  // Get main route\n  const { data: routeData, error: routeError } = await supabase\n    .from('transport_routes')\n    .select('*')\n    .eq('id', route_id)\n    .single();\n\n  if (routeError) throw routeError;\n\n  // Parse JSON fields safely, accounting for differing schema keys and TypeScript table typings\n  const raw = (routeData as Record<string, any>) || {};\n  const vehicleTypes = parseJsonArraySafely(\n    raw.vehicle_types ?? raw.transport_types ?? raw.transport_types_data\n  );\n  const luggageCapacity = parseJsonArraySafely(\n    raw.luggage_capacity ?? raw.luggageCapacity\n  );\n\n  // Get intermediate stops ordered by stop_order\n  const { data: stops, error: stopsError } = await supabase\n    .from('intermediate_stops')\n    .select('*')\n    .eq('route_id', route_id)\n    .order('stop_order', { ascending: true });\n\n  if (stopsError) throw stopsError;\n\n  // Get sightseeing options\n  const { data: sightseeing, error: sightseeingError } = await supabase\n    .from('sightseeing_options')\n    .select('*')\n    .eq('route_id', route_id);\n\n  if (sightseeingError) throw sightseeingError;\n\n  // Resolve full names for start and end locations via location_codes\n  const [startFullName, endFullName] = await Promise.all([\n    getLocationFullName(raw.start_location),\n    getLocationFullName(raw.end_location),\n  ]);\n\n  return {\n    ...routeData,\n    start_location_full_name: startFullName ?? null,\n    end_location_full_name: endFullName ?? null,\n    vehicleTypes,\n    luggageCapacity,\n    stops: stops || [],\n    sightseeing: sightseeing || [],\n  } as TransportRouteDetails;\n}","import type { Json } from '@/integrations/supabase/types';\n\nexport type NominatimSearchResult = {\n  place_id: number;\n  osm_type?: string;\n  osm_id?: number;\n  boundingbox?: string[];\n  lat: string;\n  lon: string;\n  display_name: string;\n  class?: string;\n  type?: string;\n  importance?: number;\n  address?: Record<string, string>;\n};\n\nexport type NominatimReverseResult = {\n  place_id: number;\n  licence?: string;\n  osm_type?: string;\n  osm_id?: number;\n  lat: string;\n  lon: string;\n  display_name: string;\n  address?: Record<string, string>;\n};\n\nconst BASE = 'https://nominatim.openstreetmap.org';\n\nasync function getJson<T>(url: string): Promise<T> {\n  const res = await fetch(url, {\n    headers: {\n      'Accept': 'application/json',\n      // Friendly UA per Nominatim policy; replace string if you have app/site\n      'User-Agent': 'TripOex/1.0 (Nominatim integration)'\n    }\n  });\n  if (!res.ok) {\n    throw new Error(`Nominatim request failed: ${res.status} ${res.statusText}`);\n  }\n  return res.json() as Promise<T>;\n}\n\nexport const nominatimService = {\n  async search(query: string, options?: { countrycodes?: string; limit?: number }): Promise<NominatimSearchResult[]> {\n    const params = new URLSearchParams({\n      q: query,\n      format: 'jsonv2',\n      addressdetails: '1',\n      limit: String(options?.limit ?? 5)\n    });\n    if (options?.countrycodes) params.set('countrycodes', options.countrycodes);\n    const url = `${BASE}/search?${params.toString()}`;\n    return getJson<NominatimSearchResult[]>(url);\n  },\n\n  async reverse(lat: number | string, lon: number | string): Promise<NominatimReverseResult> {\n    const params = new URLSearchParams({\n      lat: String(lat),\n      lon: String(lon),\n      format: 'jsonv2',\n      addressdetails: '1'\n    });\n    const url = `${BASE}/reverse?${params.toString()}`;\n    return getJson<NominatimReverseResult>(url);\n  }\n};\n\nexport default nominatimService;","import { supabase } from '@/lib/supabaseClient';\nimport type { Tables, TablesInsert, TablesUpdate, Json } from '@/integrations/supabase/types';\n\n// Type definitions based on Supabase schema\nexport type VisaRow = Tables<'visa'>;\nexport type VisaInsert = TablesInsert<'visa'>;\nexport type VisaUpdate = TablesUpdate<'visa'>;\n\n// Service response interface\nexport interface VisaServiceResponse<T = any> {\n  data: T | null;\n  error: string | null;\n  success: boolean;\n}\n\n// Filter interface for visa queries\nexport interface VisaFilters {\n  search?: string;\n  country?: string;\n  visa_type?: string;\n  status?: 'active' | 'disabled';\n  page?: number;\n  limit?: number;\n}\n\n// Document interface for visa documents (jsonb field)\nexport interface VisaDocument {\n  id: string;\n  name: string;\n  description?: string;\n  required: boolean;\n  format?: string;\n}\n\n// Enhanced visa interface with computed fields\nexport interface EnhancedVisa extends VisaRow {\n  documents_parsed?: VisaDocument[];\n}\n\nexport class VisaService {\n  /**\n   * Get all visas with optional filtering and pagination\n   */\n  static async getAllVisas(filters: VisaFilters = {}): Promise<VisaServiceResponse<{ visas: EnhancedVisa[]; total: number }>> {\n    try {\n      console.log(' Fetching visas from Supabase...', filters);\n\n      let query = supabase\n        .from('visa')\n        .select('*', { count: 'exact' });\n\n      // Apply search filter\n      if (filters.search) {\n        query = query.or(`country.ilike.%${filters.search}%,visa_type.ilike.%${filters.search}%`);\n      }\n\n      // Apply country filter\n      if (filters.country) {\n        query = query.eq('country', filters.country);\n      }\n\n      // Apply visa type filter\n      if (filters.visa_type) {\n        query = query.eq('visa_type', filters.visa_type);\n      }\n\n      // Apply status filter\n      if (filters.status) {\n        query = query.eq('status', filters.status);\n      }\n\n      // Apply pagination\n      if (filters.page && filters.limit) {\n        const from = (filters.page - 1) * filters.limit;\n        const to = from + filters.limit - 1;\n        query = query.range(from, to);\n      }\n\n      // Order by created_at descending\n      query = query.order('created_at', { ascending: false });\n\n      const { data, error, count } = await query;\n\n      if (error) {\n        console.error(' Error fetching visas:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      // Parse documents field for each visa\n      const enhancedVisas: EnhancedVisa[] = (data || []).map(visa => ({\n        ...visa,\n        documents_parsed: this.parseDocuments(visa.documents)\n      }));\n\n      console.log(` Successfully fetched ${enhancedVisas.length} visas`);\n\n      return {\n        data: {\n          visas: enhancedVisas,\n          total: count || 0\n        },\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error fetching visas:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Get a single visa by ID\n   */\n  static async getVisaById(id: string): Promise<VisaServiceResponse<EnhancedVisa>> {\n    try {\n      console.log(' Fetching visa by ID:', id);\n\n      const { data, error } = await supabase\n        .from('visa')\n        .select('*')\n        .eq('id', id)\n        .single();\n\n      if (error) {\n        console.error(' Error fetching visa:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      const enhancedVisa: EnhancedVisa = {\n        ...data,\n        documents_parsed: this.parseDocuments(data.documents)\n      };\n\n      console.log(' Successfully fetched visa:', enhancedVisa.country);\n\n      return {\n        data: enhancedVisa,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error fetching visa:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Create a new visa\n   */\n  static async createVisa(visaData: VisaInsert): Promise<VisaServiceResponse<EnhancedVisa>> {\n    try {\n      console.log(' Creating new visa:', visaData.country);\n\n      const { data, error } = await supabase\n        .from('visa')\n        .insert(visaData)\n        .select('*')\n        .single();\n\n      if (error) {\n        console.error(' Error creating visa:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      const enhancedVisa: EnhancedVisa = {\n        ...data,\n        documents_parsed: this.parseDocuments(data.documents)\n      };\n\n      console.log(' Successfully created visa:', enhancedVisa.country);\n\n      return {\n        data: enhancedVisa,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error creating visa:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Update an existing visa\n   */\n  static async updateVisa(id: string, visaData: VisaUpdate): Promise<VisaServiceResponse<EnhancedVisa>> {\n    try {\n      console.log(' Updating visa:', id);\n\n      const { data, error } = await supabase\n        .from('visa')\n        .update(visaData)\n        .eq('id', id)\n        .select('*')\n        .single();\n\n      if (error) {\n        console.error(' Error updating visa:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      const enhancedVisa: EnhancedVisa = {\n        ...data,\n        documents_parsed: this.parseDocuments(data.documents)\n      };\n\n      console.log(' Successfully updated visa:', enhancedVisa.country);\n\n      return {\n        data: enhancedVisa,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error updating visa:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Delete a visa\n   */\n  static async deleteVisa(id: string): Promise<VisaServiceResponse<boolean>> {\n    try {\n      console.log(' Deleting visa:', id);\n\n      const { error } = await supabase\n        .from('visa')\n        .delete()\n        .eq('id', id);\n\n      if (error) {\n        console.error(' Error deleting visa:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      console.log(' Successfully deleted visa');\n\n      return {\n        data: true,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error deleting visa:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Get unique countries from visas\n   */\n  static async getVisaCountries(): Promise<VisaServiceResponse<string[]>> {\n    try {\n      console.log(' Fetching visa countries...');\n\n      const { data, error } = await supabase\n        .from('visa')\n        .select('country')\n        .eq('status', 'active');\n\n      if (error) {\n        console.error(' Error fetching visa countries:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      const countries = [...new Set(data.map(item => item.country))].sort();\n\n      console.log(' Successfully fetched visa countries:', countries.length);\n\n      return {\n        data: countries,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error fetching visa countries:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Get unique visa types\n   */\n  static async getVisaTypes(): Promise<VisaServiceResponse<string[]>> {\n    try {\n      console.log(' Fetching visa types...');\n\n      const { data, error } = await supabase\n        .from('visa')\n        .select('visa_type')\n        .eq('status', 'active');\n\n      if (error) {\n        console.error(' Error fetching visa types:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      const visaTypes = [...new Set(data.map(item => item.visa_type))].sort();\n\n      console.log(' Successfully fetched visa types:', visaTypes.length);\n\n      return {\n        data: visaTypes,\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error fetching visa types:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n\n  /**\n   * Helper method to parse documents JSON field\n   */\n  private static parseDocuments(documents: Json | null): VisaDocument[] {\n    if (!documents) return [];\n    \n    try {\n      if (Array.isArray(documents)) {\n        return documents as unknown as VisaDocument[];\n      }\n      return [];\n    } catch (error) {\n      console.warn('Failed to parse visa documents:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Helper method to format documents for storage\n   */\n  static formatDocumentsForStorage(documents: VisaDocument[]): Json {\n    return documents as unknown as Json;\n  }\n\n  /**\n   * Get countries from the countries table for visa forms\n   */\n  static async getActiveCountries(): Promise<VisaServiceResponse<Array<{ id: string; name: string; code: string }>>> {\n    try {\n      console.log(' Fetching active countries...');\n\n      const { data, error } = await supabase\n        .from('countries')\n        .select('id, name, code')\n        .eq('status', 'active')\n        .order('name', { ascending: true });\n\n      if (error) {\n        console.error(' Error fetching countries:', error);\n        return {\n          data: null,\n          error: error.message,\n          success: false,\n        };\n      }\n\n      console.log(' Successfully fetched active countries:', data.length);\n\n      return {\n        data: data || [],\n        error: null,\n        success: true,\n      };\n    } catch (error) {\n      console.error(' Unexpected error fetching countries:', error);\n      return {\n        data: null,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n        success: false,\n      };\n    }\n  }\n}","\nimport { Query } from '@/types/query';\nimport { ProposalDay } from '@/components/proposal/DayPlanningInterface';\n\nexport interface EnhancedProposalTemplate {\n  id: string;\n  name: string;\n  description: string;\n  destination: {\n    country: string;\n    cities: string[];\n  };\n  duration: {\n    days: number;\n    nights: number;\n  };\n  category: 'Budget' | 'Standard' | 'Premium' | 'Luxury';\n  dayPlan: ProposalDay[];\n  pricingMatrix: {\n    paxCount: number;\n    basePrice: number;\n    markup: number;\n  }[];\n  metadata: {\n    createdFrom?: string;\n    usageCount: number;\n    averageRating: number;\n    lastUsed: string;\n    isActive: boolean;\n    tags: string[];\n  };\n  createdAt: string;\n  updatedAt: string;\n}\n\nclass ProposalTemplateService {\n  private static instance: ProposalTemplateService;\n  private storageKey = 'proposal_templates_enhanced_v1';\n\n  public static getInstance(): ProposalTemplateService {\n    if (!ProposalTemplateService.instance) {\n      ProposalTemplateService.instance = new ProposalTemplateService();\n    }\n    return ProposalTemplateService.instance;\n  }\n\n  public getAllTemplates(): EnhancedProposalTemplate[] {\n    try {\n      const saved = localStorage.getItem(this.storageKey) || '[]';\n      const templates = JSON.parse(saved);\n      return templates.concat(this.getDefaultTemplates());\n    } catch (error) {\n      console.error('Error loading templates:', error);\n      return this.getDefaultTemplates();\n    }\n  }\n\n  public getTemplatesByDestination(country: string, cities: string[]): EnhancedProposalTemplate[] {\n    const allTemplates = this.getAllTemplates();\n    return allTemplates.filter(template => \n      template.destination.country.toLowerCase() === country.toLowerCase() &&\n      template.destination.cities.some(city => \n        cities.some(queryCity => city.toLowerCase().includes(queryCity.toLowerCase()))\n      )\n    );\n  }\n\n  public getTemplatesByDuration(days: number): EnhancedProposalTemplate[] {\n    const allTemplates = this.getAllTemplates();\n    return allTemplates.filter(template => template.duration.days === days);\n  }\n\n  public getRecommendedTemplates(query: Query): EnhancedProposalTemplate[] {\n    const destinationTemplates = this.getTemplatesByDestination(\n      query.destination.country, \n      query.destination.cities\n    );\n    \n    return destinationTemplates\n      .filter(template => template.metadata.isActive)\n      .sort((a, b) => {\n        // Sort by usage count and rating\n        const scoreA = a.metadata.usageCount * 0.3 + a.metadata.averageRating * 0.7;\n        const scoreB = b.metadata.usageCount * 0.3 + b.metadata.averageRating * 0.7;\n        return scoreB - scoreA;\n      })\n      .slice(0, 6);\n  }\n\n  public saveTemplate(template: Partial<EnhancedProposalTemplate>): string {\n    try {\n      const templates = this.getAllTemplates().filter(t => !t.id.startsWith('default_'));\n      const templateId = template.id || `template_${Date.now()}`;\n      \n      const newTemplate: EnhancedProposalTemplate = {\n        id: templateId,\n        name: template.name || 'Untitled Template',\n        description: template.description || '',\n        destination: template.destination || { country: '', cities: [] },\n        duration: template.duration || { days: 1, nights: 0 },\n        category: template.category || 'Standard',\n        dayPlan: template.dayPlan || [],\n        pricingMatrix: template.pricingMatrix || [],\n        metadata: {\n          createdFrom: template.metadata?.createdFrom,\n          usageCount: template.metadata?.usageCount || 0,\n          averageRating: template.metadata?.averageRating || 4.0,\n          lastUsed: template.metadata?.lastUsed || new Date().toISOString(),\n          isActive: template.metadata?.isActive !== false,\n          tags: template.metadata?.tags || []\n        },\n        createdAt: template.createdAt || new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n\n      const existingIndex = templates.findIndex(t => t.id === templateId);\n      if (existingIndex >= 0) {\n        templates[existingIndex] = newTemplate;\n      } else {\n        templates.push(newTemplate);\n      }\n\n      localStorage.setItem(this.storageKey, JSON.stringify(templates));\n      return templateId;\n    } catch (error) {\n      console.error('Error saving template:', error);\n      throw new Error('Failed to save template');\n    }\n  }\n\n  public saveProposalAsTemplate(\n    proposalDays: ProposalDay[], \n    query: Query,\n    templateName: string,\n    category: EnhancedProposalTemplate['category'] = 'Standard'\n  ): string {\n    const totalCost = proposalDays.reduce((sum, day) => sum + day.totalCost, 0);\n    const totalPax = query.paxDetails.adults + query.paxDetails.children;\n    \n    const template: Partial<EnhancedProposalTemplate> = {\n      name: templateName,\n      description: `Template created from ${query.destination.country} proposal`,\n      destination: {\n        country: query.destination.country,\n        cities: query.destination.cities\n      },\n      duration: {\n        days: proposalDays.length,\n        nights: Math.max(0, proposalDays.length - 1)\n      },\n      category,\n      dayPlan: proposalDays,\n      pricingMatrix: [\n        {\n          paxCount: totalPax,\n          basePrice: totalCost,\n          markup: 0.15 // 15% default markup\n        }\n      ],\n      metadata: {\n        usageCount: 0,\n        averageRating: 4.0,\n        lastUsed: new Date().toISOString(),\n        isActive: true,\n        tags: [query.destination.country.toLowerCase(), `${proposalDays.length}days`]\n      }\n    };\n\n    return this.saveTemplate(template);\n  }\n\n  public incrementUsage(templateId: string): void {\n    try {\n      const templates = this.getAllTemplates().filter(t => !t.id.startsWith('default_'));\n      const templateIndex = templates.findIndex(t => t.id === templateId);\n      \n      if (templateIndex >= 0) {\n        templates[templateIndex].metadata.usageCount += 1;\n        templates[templateIndex].metadata.lastUsed = new Date().toISOString();\n        localStorage.setItem(this.storageKey, JSON.stringify(templates));\n      }\n    } catch (error) {\n      console.error('Error incrementing template usage:', error);\n    }\n  }\n\n  private getDefaultTemplates(): EnhancedProposalTemplate[] {\n    return [\n      {\n        id: 'default_thailand_3d4n',\n        name: 'Thailand Beach Getaway - 3D/4N',\n        description: 'Perfect beach vacation with hotel, transport and activities',\n        destination: { country: 'Thailand', cities: ['Bangkok', 'Phuket'] },\n        duration: { days: 4, nights: 3 },\n        category: 'Standard',\n        dayPlan: [\n          {\n            id: 'day1',\n            dayNumber: 1,\n            date: '',\n            city: 'Bangkok',\n            title: 'Arrival in Bangkok',\n            description: 'Airport transfer and city exploration',\n            activities: [\n              { id: 'act1', name: 'Airport Transfer', price: 25, duration: '1 hour' },\n              { id: 'act2', name: 'City Temple Tour', price: 40, duration: '3 hours' }\n            ],\n            meals: { breakfast: false, lunch: true, dinner: true },\n            totalCost: 165\n          },\n          {\n            id: 'day2',\n            dayNumber: 2,\n            date: '',\n            city: 'Bangkok',\n            title: 'Bangkok Sightseeing',\n            description: 'Full day city tour with cultural sites',\n            activities: [\n              { id: 'act3', name: 'Grand Palace Tour', price: 50, duration: '4 hours' },\n              { id: 'act4', name: 'Floating Market Visit', price: 35, duration: '3 hours' }\n            ],\n            meals: { breakfast: true, lunch: true, dinner: false },\n            totalCost: 185\n          }\n        ],\n        pricingMatrix: [\n          { paxCount: 2, basePrice: 350, markup: 0.15 },\n          { paxCount: 4, basePrice: 650, markup: 0.12 }\n        ],\n        metadata: {\n          usageCount: 15,\n          averageRating: 4.5,\n          lastUsed: new Date().toISOString(),\n          isActive: true,\n          tags: ['thailand', 'beach', 'bangkok', 'phuket', '4days']\n        },\n        createdAt: '2024-01-01T00:00:00.000Z',\n        updatedAt: '2024-01-01T00:00:00.000Z'\n      }\n    ];\n  }\n}\n\nexport default ProposalTemplateService;\n","\nimport { EnhancedStaffMember } from '@/types/staff';\nimport { supabase } from '@/integrations/supabase/client';\nimport { adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\n\n// Fetch staff data from Supabase instead of local storage\nexport const getStoredStaff = async (): Promise<EnhancedStaffMember[]> => {\n  try {\n    const staff = await fetchStaffFromSupabase();\n    return staff;\n  } catch (error) {\n    console.error('getStoredStaff: Error fetching from Supabase:', error);\n    return [];\n  }\n};\n\n// Supabase-only helpers\nexport const fetchStaffFromSupabase = async (): Promise<EnhancedStaffMember[]> => {\n  try {\n    const { data, error } = await supabase\n      .from('profiles')\n      .select('id, name, email, phone, department, role, status, employee_id, created_at, avatar')\n      .eq('role', 'staff');\n\n    if (error) {\n      console.warn('Supabase profiles fetch failed:', error);\n      return [];\n    }\n\n    const today = new Date().toISOString().slice(0, 10);\n    const mapRow = (p: any): EnhancedStaffMember => ({\n      id: p.id,\n      name: p.name || (p.email ? String(p.email).split('@')[0] : 'Staff Member'),\n      email: p.email || '',\n      phone: p.phone || '',\n      department: p.department || 'General',\n      role: p.role || 'staff',\n      status: ['active', 'inactive', 'on-leave'].includes(p?.status) ? p.status : 'active',\n      avatar: p.avatar || undefined,\n      joinDate: (p.created_at ? String(p.created_at).slice(0, 10) : today),\n      dateOfBirth: undefined,\n      skills: [],\n      certifications: [],\n      performance: {\n        daily: { date: today, tasksCompleted: 0, responseTime: 0, customerSatisfaction: 0 },\n        monthly: { month: today.slice(0, 7), totalTasks: 0, averageResponseTime: 0, averageCustomerSatisfaction: 0, targetAchievement: 0 },\n        quarterly: { quarter: `Q${Math.floor((new Date().getMonth() / 3) + 1)}-${new Date().getFullYear()}`, performanceRating: 0, goalsAchieved: 0, totalGoals: 0, growthPercentage: 0 },\n        overall: { totalExperience: '0 years', performanceScore: 0, ranking: 0, badges: [] },\n      },\n      targets: [],\n      permissions: [],\n      workingHours: {\n        monday: { isWorking: true, startTime: '09:00', endTime: '17:00' },\n        tuesday: { isWorking: true, startTime: '09:00', endTime: '17:00' },\n        wednesday: { isWorking: true, startTime: '09:00', endTime: '17:00' },\n        thursday: { isWorking: true, startTime: '09:00', endTime: '17:00' },\n        friday: { isWorking: true, startTime: '09:00', endTime: '17:00' },\n        saturday: { isWorking: false },\n        sunday: { isWorking: false },\n      },\n      reportingManager: undefined,\n      teamMembers: undefined,\n      employeeId: p.employee_id || '',\n      operationalCountries: [],\n      salaryStructure: undefined,\n      leaveBalance: undefined,\n      attendanceRecord: undefined,\n    });\n\n    return (Array.isArray(data) ? data.map(mapRow) : []) as EnhancedStaffMember[];\n  } catch (err) {\n    console.warn('Error fetching staff from Supabase:', err);\n    return [];\n  }\n};\n\nexport const saveStaffMember = (staffMember: EnhancedStaffMember): void => {\n  (async () => {\n    const payload: any = {\n      ...(staffMember.id ? { id: staffMember.id } : {}),\n      name: staffMember.name,\n      email: staffMember.email,\n      phone: staffMember.phone || null,\n      department: staffMember.department || null,\n      role: staffMember.role || 'staff',\n      position: staffMember.position || staffMember.role || null,\n      status: staffMember.status || 'active',\n      employee_id: staffMember.employeeId || null,\n      avatar: staffMember.avatar || null,\n      must_change_password: true,\n    };\n    const { error } = await supabase.from('profiles').insert(payload);\n    if (error) console.error('Error saving staff to Supabase:', error);\n  })().catch(e => console.error('Async error saving staff:', e));\n};\n\nexport const getStaffById = (id: string): EnhancedStaffMember | null => {\n  console.warn('getStaffById: local storage source removed; returning null');\n  return null;\n};\n\nexport const updateStaffMember = (id: string, updates: Partial<EnhancedStaffMember>): void => {\n  (async () => {\n    const payload: any = {};\n    if (updates.name != null) payload.name = updates.name;\n    if (updates.email != null) payload.email = updates.email;\n    if (updates.phone != null) payload.phone = updates.phone;\n    if (updates.department != null) payload.department = updates.department;\n    if (updates.role != null) payload.role = updates.role;\n    if (updates.position != null) payload.position = updates.position;\n    if (updates.status != null) payload.status = updates.status;\n    if (updates.employeeId != null) payload.employee_id = updates.employeeId;\n    if (updates.avatar != null) payload.avatar = updates.avatar;\n    payload.updated_at = new Date().toISOString();\n\n    const { error } = await supabase.from('profiles').update(payload).eq('id', id);\n    if (error) console.error('Error updating staff in Supabase:', error);\n  })().catch(e => console.error('Async error updating staff:', e));\n};\n\n/**\n * Update status in both tables: `profiles.status` and `staff.status` for the same UUID.\n * Returns detailed result so callers can handle partial failures gracefully.\n */\nexport const updateStaffStatusBothTables = async (\n  id: string,\n  status: 'active' | 'inactive' | 'on-leave'\n): Promise<{ profileError: any | null; staffError: any | null }> => {\n  const updated_at = new Date().toISOString();\n  const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\n  // Update profiles.status\n  const { error: profileError } = await client\n    .from('profiles')\n    .update({ status, updated_at })\n    .eq('id', id);\n\n  // Update staff.status (table may not exist in some setups)\n  let staffError: any | null = null;\n  try {\n    const { error } = await client\n      .from('staff' as any)\n      .update({ status, updated_at })\n      .eq('id', id);\n    staffError = error || null;\n  } catch (e: any) {\n    staffError = e;\n  }\n\n  return { profileError, staffError };\n};\n\nexport const deleteStaffMember = (id: string): void => {\n  (async () => {\n    const { error } = await supabase.from('profiles').delete().eq('id', id);\n    if (error) console.error('Error deleting staff from Supabase:', error);\n  })().catch(e => console.error('Async error deleting staff:', e));\n};\n","\nimport { QueryWorkflow, WorkflowEvent, Query } from '@/types/query';\n\nexport interface WorkflowAction {\n  id: string;\n  type: 'assignment' | 'communication' | 'proposal' | 'follow-up' | 'status-change';\n  title: string;\n  description: string;\n  priority: 'low' | 'normal' | 'high';\n  estimatedTime?: string;\n  requiredRole?: string[];\n}\n\nexport interface WorkflowSummary {\n  currentStep: string;\n  completedSteps: string[];\n  nextActions: WorkflowAction[];\n  estimatedCompletion: string;\n}\n\nclass QueryWorkflowService {\n  private workflows: Map<string, QueryWorkflow> = new Map();\n  private eventId = 1;\n\n  // Generate a new event ID\n  private generateEventId(): string {\n    return `event_${this.eventId++}_${Date.now()}`;\n  }\n\n  // Create a new workflow for a query\n  createWorkflow(queryId: string): QueryWorkflow {\n    const workflow: QueryWorkflow = {\n      id: `workflow_${queryId}`,\n      queryId,\n      events: [],\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    \n    this.workflows.set(queryId, workflow);\n    return workflow;\n  }\n\n  // Get workflow for a query\n  getWorkflow(queryId: string): QueryWorkflow | undefined {\n    return this.workflows.get(queryId);\n  }\n\n  // Add an event to a workflow\n  addEvent(queryId: string, event: Omit<WorkflowEvent, 'id'>): WorkflowEvent {\n    let workflow = this.workflows.get(queryId);\n    \n    if (!workflow) {\n      workflow = this.createWorkflow(queryId);\n    }\n\n    const newEvent: WorkflowEvent = {\n      ...event,\n      id: this.generateEventId()\n    };\n\n    workflow.events.push(newEvent);\n    workflow.updatedAt = new Date().toISOString();\n    \n    this.workflows.set(queryId, workflow);\n    return newEvent;\n  }\n\n  // Create query creation event\n  createQueryCreatedEvent(query: Query): WorkflowEvent {\n    return this.addEvent(query.id, {\n      type: 'created',\n      timestamp: query.createdAt,\n      userId: query.agentId.toString(),\n      userName: query.agentName,\n      userRole: 'agent',\n      details: `Query created for ${query.destination.country} (${query.tripDuration.nights} nights)`,\n      metadata: {\n        destination: query.destination.country,\n        duration: query.tripDuration.nights,\n        pax: query.paxDetails.adults + query.paxDetails.children + query.paxDetails.infants,\n        packageType: query.packageType\n      }\n    });\n  }\n\n  // Create assignment event\n  createAssignmentEvent(queryId: string, assignedBy: string, assignedTo: string, assignedToName: string): WorkflowEvent {\n    return this.addEvent(queryId, {\n      type: 'assigned',\n      timestamp: new Date().toISOString(),\n      userId: assignedBy,\n      userName: assignedBy,\n      userRole: 'manager',\n      details: `Query assigned to ${assignedToName}`,\n      metadata: {\n        assignedTo,\n        assignedToName,\n        previousStatus: 'new',\n        newStatus: 'assigned'\n      }\n    });\n  }\n\n  // Create status change event\n  createStatusChangeEvent(queryId: string, userId: string, userName: string, userRole: string, previousStatus: string, newStatus: string, reason?: string): WorkflowEvent {\n    return this.addEvent(queryId, {\n      type: 'status_changed',\n      timestamp: new Date().toISOString(),\n      userId,\n      userName,\n      userRole,\n      details: `Status changed from ${previousStatus} to ${newStatus}${reason ? `: ${reason}` : ''}`,\n      metadata: {\n        previousStatus,\n        newStatus,\n        reason\n      }\n    });\n  }\n\n  // Create proposal creation event\n  createProposalCreatedEvent(queryId: string, userId: string, userName: string, proposalTitle: string): WorkflowEvent {\n    return this.addEvent(queryId, {\n      type: 'proposal_created',\n      timestamp: new Date().toISOString(),\n      userId,\n      userName,\n      userRole: 'staff',\n      details: `Proposal created: ${proposalTitle}`,\n      metadata: {\n        proposalTitle,\n        previousStatus: 'in-progress',\n        newStatus: 'proposal-sent'\n      }\n    });\n  }\n\n  // Create follow-up event\n  createFollowUpEvent(queryId: string, userId: string, userName: string, followUpDate: string, notes?: string): WorkflowEvent {\n    return this.addEvent(queryId, {\n      type: 'follow_up',\n      timestamp: new Date().toISOString(),\n      userId,\n      userName,\n      userRole: 'staff',\n      details: `Follow-up scheduled for ${new Date(followUpDate).toLocaleDateString()}${notes ? `: ${notes}` : ''}`,\n      metadata: {\n        followUpDate,\n        notes\n      }\n    });\n  }\n\n  // Create comment event\n  createCommentEvent(queryId: string, userId: string, userName: string, userRole: string, comment: string): WorkflowEvent {\n    return this.addEvent(queryId, {\n      type: 'comment_added',\n      timestamp: new Date().toISOString(),\n      userId,\n      userName,\n      userRole,\n      details: comment,\n      metadata: {\n        commentType: 'general'\n      }\n    });\n  }\n\n  // Get all events for a query ordered by timestamp\n  getQueryEvents(queryId: string): WorkflowEvent[] {\n    const workflow = this.workflows.get(queryId);\n    if (!workflow) return [];\n    \n    return [...workflow.events].sort((a, b) => \n      new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\n    );\n  }\n\n  // Get available actions for a query\n  getAvailableActions(query: Query): WorkflowAction[] {\n    const actions: WorkflowAction[] = [];\n\n    switch (query.status) {\n      case 'new':\n        actions.push({\n          id: 'assign-staff',\n          type: 'assignment',\n          title: 'Assign to Staff',\n          description: 'Assign this query to a staff member',\n          priority: 'high'\n        });\n        break;\n      case 'assigned':\n        actions.push({\n          id: 'start-working',\n          type: 'status-change',\n          title: 'Start Working',\n          description: 'Change status to in-progress',\n          priority: 'high'\n        });\n        break;\n      case 'in-progress':\n        actions.push({\n          id: 'create-proposal',\n          type: 'proposal',\n          title: 'Create Proposal',\n          description: 'Create a new proposal for this query',\n          priority: 'high'\n        });\n        actions.push({\n          id: 'add-follow-up',\n          type: 'follow-up',\n          title: 'Schedule Follow-up',\n          description: 'Schedule a follow-up for this query',\n          priority: 'normal'\n        });\n        break;\n      case 'proposal-sent':\n        actions.push({\n          id: 'follow-up-proposal',\n          type: 'communication',\n          title: 'Follow up on Proposal',\n          description: 'Contact client about the sent proposal',\n          priority: 'normal'\n        });\n        break;\n    }\n\n    // Add common actions\n    actions.push({\n      id: 'add-comment',\n      type: 'communication',\n      title: 'Add Comment',\n      description: 'Add a comment to this query',\n      priority: 'low'\n    });\n\n    return actions;\n  }\n\n  // Get Thailand-specific actions\n  getThailandSpecificActions(query: Query): WorkflowAction[] {\n    if (query.destination.country.toLowerCase() !== 'thailand') {\n      return [];\n    }\n\n    return [\n      {\n        id: 'visa-check',\n        type: 'communication',\n        title: 'Check Visa Requirements',\n        description: 'Verify visa requirements for Thailand',\n        priority: 'normal'\n      },\n      {\n        id: 'weather-update',\n        type: 'communication',\n        title: 'Check Weather Conditions',\n        description: 'Provide weather update for travel dates',\n        priority: 'low'\n      }\n    ];\n  }\n\n  // Generate workflow summary\n  generateWorkflowSummary(query: Query): WorkflowSummary {\n    const events = this.getQueryEvents(query.id);\n    const statusEvents = events.filter(e => e.type === 'status_changed');\n    \n    const completedSteps: string[] = [];\n    if (events.some(e => e.type === 'created')) completedSteps.push('created');\n    if (events.some(e => e.type === 'assigned')) completedSteps.push('assigned');\n    if (statusEvents.some(e => e.metadata?.newStatus === 'in-progress')) completedSteps.push('in-progress');\n    if (events.some(e => e.type === 'proposal_created')) completedSteps.push('proposal-sent');\n\n    return {\n      currentStep: query.status,\n      completedSteps,\n      nextActions: this.getAvailableActions(query),\n      estimatedCompletion: this.calculateEstimatedCompletion(query)\n    };\n  }\n\n  // Execute an action\n  async executeAction(query: Query, actionId: string): Promise<{ success: boolean; message: string; updatedQuery?: Query }> {\n    try {\n      switch (actionId) {\n        case 'assign-staff':\n          this.createAssignmentEvent(query.id, 'current-user', 'staff-member', 'Staff Member');\n          return { success: true, message: 'Query assigned successfully' };\n        \n        case 'start-working':\n          this.createStatusChangeEvent(query.id, 'current-user', 'Current User', 'staff', query.status, 'in-progress');\n          return { success: true, message: 'Status updated to in-progress' };\n        \n        case 'create-proposal':\n          this.createProposalCreatedEvent(query.id, 'current-user', 'Current User', 'New Proposal');\n          return { success: true, message: 'Proposal created successfully' };\n        \n        case 'add-follow-up':\n          const tomorrow = new Date();\n          tomorrow.setDate(tomorrow.getDate() + 1);\n          this.createFollowUpEvent(query.id, 'current-user', 'Current User', tomorrow.toISOString());\n          return { success: true, message: 'Follow-up scheduled' };\n        \n        case 'add-comment':\n          this.createCommentEvent(query.id, 'current-user', 'Current User', 'staff', 'Comment added via workflow action');\n          return { success: true, message: 'Comment added successfully' };\n        \n        default:\n          return { success: false, message: 'Unknown action' };\n      }\n    } catch (error) {\n      return { success: false, message: 'Failed to execute action' };\n    }\n  }\n\n  // Calculate estimated completion time\n  private calculateEstimatedCompletion(query: Query): string {\n    const daysRemaining = Math.floor((new Date(query.travelDates.from).getTime() - Date.now()) / (1000 * 60 * 60 * 24));\n    \n    switch (query.status) {\n      case 'new':\n        return `${Math.min(daysRemaining - 7, 2)} days`;\n      case 'assigned':\n        return `${Math.min(daysRemaining - 5, 3)} days`;\n      case 'in-progress':\n        return `${Math.min(daysRemaining - 3, 2)} days`;\n      default:\n        return `${Math.max(daysRemaining - 1, 1)} days`;\n    }\n  }\n\n  // Get workflow statistics\n  getWorkflowStats(queryId: string): {\n    totalEvents: number;\n    daysInCurrentStatus: number;\n    timeToFirstProposal?: number;\n    averageResponseTime: number;\n  } {\n    const events = this.getQueryEvents(queryId);\n    const statusChanges = events.filter(e => e.type === 'status_changed');\n    const proposals = events.filter(e => e.type === 'proposal_created');\n    \n    const currentStatusEvent = statusChanges[statusChanges.length - 1];\n    const daysInCurrentStatus = currentStatusEvent \n      ? Math.floor((Date.now() - new Date(currentStatusEvent.timestamp).getTime()) / (1000 * 60 * 60 * 24))\n      : 0;\n\n    const timeToFirstProposal = proposals.length > 0 && events.length > 0\n      ? Math.floor((new Date(proposals[0].timestamp).getTime() - new Date(events[0].timestamp).getTime()) / (1000 * 60 * 60 * 24))\n      : undefined;\n\n    return {\n      totalEvents: events.length,\n      daysInCurrentStatus,\n      timeToFirstProposal,\n      averageResponseTime: 2 // Simulated average response time in days\n    };\n  }\n\n  // Export workflow as structured data\n  exportWorkflow(queryId: string): any {\n    const workflow = this.workflows.get(queryId);\n    if (!workflow) return null;\n\n    return {\n      queryId,\n      exportedAt: new Date().toISOString(),\n      workflow,\n      stats: this.getWorkflowStats(queryId)\n    };\n  }\n\n  // Get workflow summary for dashboard\n  getWorkflowSummary(queryId: string): {\n    currentStatus: string;\n    lastActivity: string;\n    totalEvents: number;\n    daysActive: number;\n  } {\n    const events = this.getQueryEvents(queryId);\n    if (events.length === 0) {\n      return {\n        currentStatus: 'new',\n        lastActivity: 'No activity',\n        totalEvents: 0,\n        daysActive: 0\n      };\n    }\n\n    const lastEvent = events[events.length - 1];\n    const firstEvent = events[0];\n    const statusEvents = events.filter(e => e.type === 'status_changed');\n    const currentStatus = statusEvents.length > 0 \n      ? statusEvents[statusEvents.length - 1].metadata?.newStatus || 'new'\n      : 'new';\n\n    const daysActive = Math.floor(\n      (new Date(lastEvent.timestamp).getTime() - new Date(firstEvent.timestamp).getTime()) \n      / (1000 * 60 * 60 * 24)\n    );\n\n    return {\n      currentStatus,\n      lastActivity: this.formatActivityDescription(lastEvent),\n      totalEvents: events.length,\n      daysActive\n    };\n  }\n\n  private formatActivityDescription(event: WorkflowEvent): string {\n    const timeAgo = this.getTimeAgo(event.timestamp);\n    return `${event.details} (${timeAgo})`;\n  }\n\n  private getTimeAgo(timestamp: string): string {\n    const now = new Date();\n    const eventTime = new Date(timestamp);\n    const diffInHours = Math.floor((now.getTime() - eventTime.getTime()) / (1000 * 60 * 60));\n    \n    if (diffInHours < 1) return 'Just now';\n    if (diffInHours < 24) return `${diffInHours}h ago`;\n    \n    const diffInDays = Math.floor(diffInHours / 24);\n    if (diffInDays < 7) return `${diffInDays}d ago`;\n    \n    const diffInWeeks = Math.floor(diffInDays / 7);\n    return `${diffInWeeks}w ago`;\n  }\n}\n\nexport const queryWorkflowService = new QueryWorkflowService();\n","import { Query, Proposal } from '@/types/query';\nimport { queryWorkflowService } from './queryWorkflowService';\n\nexport type AutomatedProposalStatus = \n  | 'proposal-in-draft'\n  | 'proposal-sent' \n  | 'proposal-viewed'\n  | 'modification-requested'\n  | 'revised-proposal-sent'\n  | 'follow-up-pending'\n  | 'no-response'\n  | 'interested'\n  | 'negotiation'\n  | 'confirmed'\n  | 'advance-received'\n  | 'booking-confirmed';\n\nexport interface ProposalStatusTransition {\n  from: AutomatedProposalStatus | 'assigned' | 'in-progress';\n  to: AutomatedProposalStatus;\n  trigger: 'proposal-created' | 'proposal-sent' | 'proposal-viewed' | 'client-feedback' | 'follow-up-due' | 'no-response-detected' | 'client-interested' | 'negotiation-started' | 'payment-received' | 'booking-completed';\n  conditions?: {\n    daysSinceLastActivity?: number;\n    clientResponseRequired?: boolean;\n    paymentReceived?: boolean;\n    followUpCount?: number;\n  };\n}\n\nexport interface ProposalTrackingData {\n  queryId: string;\n  proposalId: string;\n  currentStatus: AutomatedProposalStatus;\n  statusHistory: {\n    status: AutomatedProposalStatus;\n    timestamp: string;\n    triggeredBy: string;\n    metadata?: Record<string, any>;\n  }[];\n  proposalSentDate?: string;\n  proposalViewedDate?: string;\n  lastClientInteraction?: string;\n  followUpCount: number;\n  lastFollowUpDate?: string;\n  clientResponseCount: number;\n  paymentHistory: {\n    amount: number;\n    date: string;\n    type: 'advance' | 'full-payment';\n  }[];\n}\n\nclass AutomatedProposalStatusService {\n  private proposalTracking: Map<string, ProposalTrackingData> = new Map();\n  private statusTransitionRules: ProposalStatusTransition[] = [\n    // Initial proposal creation flow\n    {\n      from: 'assigned',\n      to: 'proposal-in-draft',\n      trigger: 'proposal-created'\n    },\n    {\n      from: 'in-progress',\n      to: 'proposal-in-draft',\n      trigger: 'proposal-created'\n    },\n    \n    // Proposal sending and viewing flow\n    {\n      from: 'proposal-in-draft',\n      to: 'proposal-sent',\n      trigger: 'proposal-sent'\n    },\n    {\n      from: 'proposal-sent',\n      to: 'proposal-viewed',\n      trigger: 'proposal-viewed'\n    },\n    {\n      from: 'proposal-viewed',\n      to: 'modification-requested',\n      trigger: 'client-feedback',\n      conditions: { clientResponseRequired: true }\n    },\n    {\n      from: 'modification-requested',\n      to: 'revised-proposal-sent',\n      trigger: 'proposal-sent'\n    },\n    \n    // Client engagement flow\n    {\n      from: 'proposal-viewed',\n      to: 'interested',\n      trigger: 'client-interested'\n    },\n    {\n      from: 'interested',\n      to: 'negotiation',\n      trigger: 'negotiation-started'\n    },\n    {\n      from: 'negotiation',\n      to: 'confirmed',\n      trigger: 'client-interested'\n    },\n    \n    // Payment and booking flow\n    {\n      from: 'confirmed',\n      to: 'advance-received',\n      trigger: 'payment-received',\n      conditions: { paymentReceived: true }\n    },\n    {\n      from: 'advance-received',\n      to: 'booking-confirmed',\n      trigger: 'booking-completed'\n    },\n    \n    // Follow-up automation\n    {\n      from: 'proposal-sent',\n      to: 'follow-up-pending',\n      trigger: 'follow-up-due',\n      conditions: { daysSinceLastActivity: 3, followUpCount: 0 }\n    },\n    {\n      from: 'follow-up-pending',\n      to: 'no-response',\n      trigger: 'no-response-detected',\n      conditions: { daysSinceLastActivity: 7, followUpCount: 2 }\n    }\n  ];\n\n  // Initialize tracking for a new proposal\n  initializeProposalTracking(queryId: string, proposalId: string): ProposalTrackingData {\n    const trackingData: ProposalTrackingData = {\n      queryId,\n      proposalId,\n      currentStatus: 'proposal-in-draft',\n      statusHistory: [{\n        status: 'proposal-in-draft',\n        timestamp: new Date().toISOString(),\n        triggeredBy: 'system',\n        metadata: { reason: 'Initial proposal creation' }\n      }],\n      followUpCount: 0,\n      clientResponseCount: 0,\n      paymentHistory: []\n    };\n\n    this.proposalTracking.set(proposalId, trackingData);\n    return trackingData;\n  }\n\n  // Get current tracking data for a proposal\n  getProposalTracking(proposalId: string): ProposalTrackingData | undefined {\n    return this.proposalTracking.get(proposalId);\n  }\n\n  // Get tracking data by query ID\n  getTrackingByQueryId(queryId: string): ProposalTrackingData | undefined {\n    return Array.from(this.proposalTracking.values()).find(tracking => tracking.queryId === queryId);\n  }\n\n  // Automated status transition based on trigger\n  async transitionStatus(\n    proposalId: string, \n    trigger: ProposalStatusTransition['trigger'], \n    metadata?: Record<string, any>\n  ): Promise<boolean> {\n    const trackingData = this.proposalTracking.get(proposalId);\n    if (!trackingData) {\n      console.warn(`No tracking data found for proposal ${proposalId}`);\n      return false;\n    }\n\n    const applicableRules = this.statusTransitionRules.filter(rule => \n      rule.from === trackingData.currentStatus && \n      rule.trigger === trigger\n    );\n\n    if (applicableRules.length === 0) {\n      console.warn(`No applicable transition rules for status ${trackingData.currentStatus} and trigger ${trigger}`);\n      return false;\n    }\n\n    // Check conditions for the first applicable rule\n    const rule = applicableRules[0];\n    if (rule.conditions && !this.checkTransitionConditions(trackingData, rule.conditions)) {\n      console.warn(`Transition conditions not met for rule`, rule);\n      return false;\n    }\n\n    // Execute the transition\n    return this.executeStatusTransition(trackingData, rule.to, trigger, metadata);\n  }\n\n  // Check if transition conditions are met\n  private checkTransitionConditions(\n    trackingData: ProposalTrackingData, \n    conditions: ProposalStatusTransition['conditions']\n  ): boolean {\n    if (!conditions) return true;\n\n    const now = new Date();\n    const lastActivity = trackingData.lastClientInteraction ? new Date(trackingData.lastClientInteraction) : null;\n    \n    // Check days since last activity\n    if (conditions.daysSinceLastActivity && lastActivity) {\n      const daysSince = Math.floor((now.getTime() - lastActivity.getTime()) / (1000 * 60 * 60 * 24));\n      if (daysSince < conditions.daysSinceLastActivity) {\n        return false;\n      }\n    }\n\n    // Check follow-up count\n    if (conditions.followUpCount !== undefined) {\n      if (trackingData.followUpCount < conditions.followUpCount) {\n        return false;\n      }\n    }\n\n    // Check payment received\n    if (conditions.paymentReceived && trackingData.paymentHistory.length === 0) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // Execute the actual status transition\n  private executeStatusTransition(\n    trackingData: ProposalTrackingData,\n    newStatus: AutomatedProposalStatus,\n    trigger: ProposalStatusTransition['trigger'],\n    metadata?: Record<string, any>\n  ): boolean {\n    const oldStatus = trackingData.currentStatus;\n    \n    // Update tracking data\n    trackingData.currentStatus = newStatus;\n    trackingData.statusHistory.push({\n      status: newStatus,\n      timestamp: new Date().toISOString(),\n      triggeredBy: trigger,\n      metadata\n    });\n\n    // Update specific tracking fields based on status\n    switch (newStatus) {\n      case 'proposal-sent':\n        trackingData.proposalSentDate = new Date().toISOString();\n        break;\n      case 'proposal-viewed':\n        trackingData.proposalViewedDate = new Date().toISOString();\n        trackingData.lastClientInteraction = new Date().toISOString();\n        trackingData.clientResponseCount++;\n        break;\n      case 'follow-up-pending':\n        trackingData.followUpCount++;\n        trackingData.lastFollowUpDate = new Date().toISOString();\n        break;\n    }\n\n    // Create workflow event\n    this.createWorkflowEvent(trackingData.queryId, oldStatus, newStatus, trigger, metadata);\n\n    console.log(`Automated status transition: ${oldStatus}  ${newStatus} (trigger: ${trigger})`);\n    return true;\n  }\n\n  // Create workflow event for the transition\n  private createWorkflowEvent(\n    queryId: string,\n    oldStatus: string,\n    newStatus: string,\n    trigger: string,\n    metadata?: Record<string, any>\n  ): void {\n    queryWorkflowService.addEvent(queryId, {\n      type: 'status_changed',\n      timestamp: new Date().toISOString(),\n      userId: 'automated-system',\n      userName: 'Automated System',\n      userRole: 'system',\n      details: `Automated status transition: ${oldStatus}  ${newStatus} (trigger: ${trigger})`,\n      metadata: {\n        previousStatus: oldStatus,\n        newStatus,\n        trigger,\n        automated: true,\n        ...metadata\n      }\n    });\n  }\n\n  // Handle proposal creation\n  async handleProposalCreated(queryId: string, proposalId: string): Promise<void> {\n    const trackingData = this.initializeProposalTracking(queryId, proposalId);\n    \n    // Transition from assigned/in-progress to proposal-in-draft\n    const query = await this.getQueryById(queryId);\n    if (query && (query.status === 'assigned' || query.status === 'in-progress')) {\n      await this.transitionStatus(proposalId, 'proposal-created', {\n        queryStatus: query.status,\n        proposalCreatedAt: new Date().toISOString()\n      });\n    }\n  }\n\n  // Handle proposal sending\n  async handleProposalSent(proposalId: string, sendMethod: 'email' | 'whatsapp' | 'portal'): Promise<void> {\n    await this.transitionStatus(proposalId, 'proposal-sent', {\n      sendMethod,\n      sentAt: new Date().toISOString()\n    });\n  }\n\n  // Handle proposal viewing\n  async handleProposalViewed(proposalId: string, clientId: string, viewSource: 'email' | 'portal'): Promise<void> {\n    await this.transitionStatus(proposalId, 'proposal-viewed', {\n      clientId,\n      viewSource,\n      viewedAt: new Date().toISOString()\n    });\n  }\n\n  // Handle client feedback\n  async handleClientFeedback(proposalId: string, feedbackType: 'interested' | 'modification-requested' | 'negotiation' | 'rejection'): Promise<void> {\n    const triggerMap = {\n      'interested': 'client-interested',\n      'modification-requested': 'client-feedback',\n      'negotiation': 'negotiation-started',\n      'rejection': 'client-rejected'\n    };\n\n    await this.transitionStatus(proposalId, triggerMap[feedbackType], {\n      feedbackType,\n      receivedAt: new Date().toISOString()\n    });\n  }\n\n  // Handle payment received\n  async handlePaymentReceived(proposalId: string, amount: number, paymentType: 'advance' | 'full'): Promise<void> {\n    const trackingData = this.proposalTracking.get(proposalId);\n    if (trackingData) {\n      trackingData.paymentHistory.push({\n        amount,\n        date: new Date().toISOString(),\n        type: paymentType === 'advance' ? 'advance' : 'full-payment'\n      });\n\n      await this.transitionStatus(proposalId, 'payment-received', {\n        amount,\n        paymentType,\n        receivedAt: new Date().toISOString()\n      });\n    }\n  }\n\n  // Automated follow-up check\n  async checkFollowUpRequired(proposalId: string): Promise<boolean> {\n    const trackingData = this.proposalTracking.get(proposalId);\n    if (!trackingData) return false;\n\n    const now = new Date();\n    const lastActivity = trackingData.lastClientInteraction ? new Date(trackingData.lastClientInteraction) : null;\n    const lastFollowUp = trackingData.lastFollowUpDate ? new Date(trackingData.lastFollowUpDate) : null;\n    \n    // Check if follow-up is needed based on current status\n    switch (trackingData.currentStatus) {\n      case 'proposal-sent':\n        // Follow up after 3 days if no response\n        if (lastActivity && Math.floor((now.getTime() - lastActivity.getTime()) / (1000 * 60 * 60 * 24)) >= 3) {\n          return this.transitionStatus(proposalId, 'follow-up-due', {\n            reason: 'No response after 3 days',\n            followUpNumber: trackingData.followUpCount + 1\n          });\n        }\n        break;\n        \n      case 'follow-up-pending':\n        // Mark as no response after 7 days and 2 follow-ups\n        if (trackingData.followUpCount >= 2 && lastFollowUp && \n            Math.floor((now.getTime() - lastFollowUp.getTime()) / (1000 * 60 * 60 * 24)) >= 4) {\n          return this.transitionStatus(proposalId, 'no-response-detected', {\n            reason: 'No response after multiple follow-ups',\n            totalFollowUps: trackingData.followUpCount\n          });\n        }\n        break;\n    }\n\n    return false;\n  }\n\n  // Get all proposals that need follow-up\n  getProposalsNeedingFollowUp(): string[] {\n    const proposalsNeedingFollowUp: string[] = [];\n    \n    for (const [proposalId, trackingData] of this.proposalTracking.entries()) {\n      if (this.shouldFollowUp(trackingData)) {\n        proposalsNeedingFollowUp.push(proposalId);\n      }\n    }\n    \n    return proposalsNeedingFollowUp;\n  }\n\n  // Check if a proposal should be followed up\n  private shouldFollowUp(trackingData: ProposalTrackingData): boolean {\n    const now = new Date();\n    const lastActivity = trackingData.lastClientInteraction ? new Date(trackingData.lastClientInteraction) : null;\n    const lastFollowUp = trackingData.lastFollowUpDate ? new Date(trackingData.lastFollowUpDate) : null;\n    \n    switch (trackingData.currentStatus) {\n      case 'proposal-sent':\n        return lastActivity !== null && Math.floor((now.getTime() - lastActivity.getTime()) / (1000 * 60 * 60 * 24)) >= 3;\n        \n      case 'follow-up-pending':\n        return trackingData.followUpCount < 2 && lastFollowUp !== null && \n               Math.floor((now.getTime() - lastFollowUp.getTime()) / (1000 * 60 * 60 * 24)) >= 2;\n               \n      default:\n        return false;\n    }\n  }\n\n  // Helper method to get query by ID (would be implemented with actual data service)\n  private async getQueryById(queryId: string): Promise<Query | null> {\n    // This would typically call a data service to get the query\n    // For now, returning null as this would be implemented based on your data layer\n    return null;\n  }\n\n  // Get proposal status statistics\n  getProposalStats(): {\n    totalProposals: number;\n    statusDistribution: Record<AutomatedProposalStatus, number>;\n    averageTimeToView: number;\n    conversionRate: number;\n  } {\n    const allTrackingData = Array.from(this.proposalTracking.values());\n    \n    const statusDistribution = allTrackingData.reduce((acc, tracking) => {\n      acc[tracking.currentStatus] = (acc[tracking.currentStatus] || 0) + 1;\n      return acc;\n    }, {} as Record<AutomatedProposalStatus, number>);\n\n    // Calculate average time to view (in hours)\n    const viewedProposals = allTrackingData.filter(t => t.proposalViewedDate && t.proposalSentDate);\n    const averageTimeToView = viewedProposals.length > 0\n      ? viewedProposals.reduce((sum, t) => {\n          const sentTime = new Date(t.proposalSentDate!).getTime();\n          const viewedTime = new Date(t.proposalViewedDate!).getTime();\n          return sum + (viewedTime - sentTime) / (1000 * 60 * 60);\n        }, 0) / viewedProposals.length\n      : 0;\n\n    // Calculate conversion rate (proposals that reached confirmed or beyond)\n    const convertedProposals = allTrackingData.filter(t => \n      ['confirmed', 'advance-received', 'booking-confirmed'].includes(t.currentStatus)\n    );\n    const conversionRate = allTrackingData.length > 0 \n      ? (convertedProposals.length / allTrackingData.length) * 100 \n      : 0;\n\n    return {\n      totalProposals: allTrackingData.length,\n      statusDistribution,\n      averageTimeToView,\n      conversionRate\n    };\n  }\n}\n\nexport const automatedProposalStatusService = new AutomatedProposalStatusService();","import { supabase, adminSupabase, isAdminClientConfigured, authHelpers } from '@/lib/supabaseClient';\nimport { departments as sampleDepartments } from '@/data/departmentData';\nimport type { Department } from '@/types/staff';\n\n// Storage keys for local fallback\nconst STORAGE_KEY = 'departments:storage';\n\n// Allowed roles for write operations\nconst ALLOWED_WRITE_ROLES = ['super_admin', 'manager'];\n\n// Feature flag: allow disabling localStorage fallback entirely\n// Set VITE_USE_DEPARTMENTS_FALLBACK=false in your .env to force DB-only behavior\nconst USE_DEPARTMENTS_FALLBACK = (typeof import.meta !== 'undefined' && (import.meta as any).env)\n  ? String((import.meta as any).env.VITE_USE_DEPARTMENTS_FALLBACK ?? 'true').toLowerCase() !== 'false'\n  : true;\n\n// Utility: read/write local storage fallback\nfunction readDepartmentsFromStorage(): Department[] {\n  try {\n    if (!USE_DEPARTMENTS_FALLBACK) return [];\n    const raw = localStorage.getItem(STORAGE_KEY);\n    if (raw) return JSON.parse(raw);\n  } catch {}\n  return sampleDepartments;\n}\n\nfunction writeDepartmentsToStorage(list: Department[]) {\n  try {\n    if (!USE_DEPARTMENTS_FALLBACK) return;\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(list));\n  } catch {}\n}\n\n// Raw read for legacy migration (ignores fallback flag)\nfunction readLegacyDepartmentsFallback(): Department[] {\n  try {\n    const raw = localStorage.getItem(STORAGE_KEY);\n    if (raw) return JSON.parse(raw);\n  } catch {}\n  return [];\n}\n\nfunction isMissingTableError(error: any): boolean {\n  const msg = (error?.message || '').toLowerCase();\n  const code = error?.code || '';\n  return (\n    msg.includes('does not exist') ||\n    msg.includes('not acceptable') ||\n    msg.includes('permission denied') ||\n    code === '406' ||\n    code === 'PGRST301' ||\n    code === 'PGRST116'\n  );\n}\n\nasync function getCurrentUserRole(): Promise<string | null> {\n  try {\n    const { user } = await authHelpers.getUser();\n    const userId = user?.id;\n    if (!userId) {\n      const { session } = await authHelpers.getSession();\n      if (!session?.user?.id) return null;\n    }\n    // Prefer reading role from profiles table for the current user\n    const { data, error } = await (supabase as any)\n      .from('profiles' as any)\n      .select('role')\n      .eq('id', (userId || (await authHelpers.getSession()).session.user.id))\n      .maybeSingle();\n    if (!error && data && (data as any).role) {\n      return String((data as any).role);\n    }\n    // Fallback: attempt RPC if available\n    try {\n      const { data: rpcData, error: rpcError } = await supabase.rpc('get_current_user_role');\n      if (!rpcError && rpcData) return String(rpcData);\n    } catch {}\n  } catch {}\n  return null;\n}\n\n// Best-effort table existence check (no DDL here; we log guidance when missing)\nasync function checkTableAccessible(): Promise<boolean> {\n  try {\n    const { error } = await (supabase as any)\n      .from('departments' as any)\n      .select('id')\n      .limit(1);\n    return !error;\n  } catch {\n    return false;\n  }\n}\n\n// Recommended SQL to create the table (for operators to run via Supabase SQL editor)\nexport const recommendedDepartmentTableSQL = `\n-- Create departments table\ncreate table if not exists public.departments (\n  id text primary key,\n  name text not null,\n  code text unique not null,\n  description text,\n  staff_count int default 0,\n  features jsonb default '[]'::jsonb,\n  workflow jsonb default '{}'::jsonb,\n  permissions jsonb default '[]'::jsonb,\n  created_at timestamptz default now(),\n  updated_at timestamptz default now()\n);\n\n-- Ensure a relation: profiles.department references departments.id (optional if already text)\n-- alter table public.profiles add column if not exists department text;\n-- You may also add a foreign key if desired:\n-- alter table public.profiles add constraint profiles_department_fkey foreign key (department) references public.departments(id) on update cascade on delete set null;\n\n-- RLS policies (example):\n-- alter table public.departments enable row level security;\n-- create policy \"allow read for all\" on public.departments for select using (true);\n-- create policy \"allow write for admins\" on public.departments for all to authenticated using (exists(select 1 from public.profiles p where p.id = auth.uid() and p.role in ('super_admin','manager'))) with check (exists(select 1 from public.profiles p where p.id = auth.uid() and p.role in ('super_admin','manager')));\n`;\n\nexport const departmentService = {\n  // Load all departments from DB or fallback\n  async getDepartments(): Promise<{ data: Department[]; error: any | null; source: 'db' | 'fallback' }> {\n    try {\n      const { data, error } = await (supabase as any)\n        .from('departments' as any)\n        .select('id,name,code,description,staff_count,features,workflow,permissions')\n        .order('name', { ascending: true });\n\n      if (!error && Array.isArray(data)) {\n        const mapped = (data as any[]).map((row) => ({\n          id: row.id || row.code?.toLowerCase() || String(row.name || '').toLowerCase().replace(/\\s+/g, '-'),\n          name: row.name || '',\n          code: row.code || (row.id || ''),\n          description: row.description || '',\n          staffCount: Number(row.staff_count || 0),\n          features: Array.isArray(row.features) ? row.features : [],\n          workflow: row.workflow || { stages: [], autoAssignment: false, escalationRules: [] },\n          permissions: Array.isArray(row.permissions) ? row.permissions : [],\n        })) as Department[];\n\n        // Persist fallback copy for offline\n        writeDepartmentsToStorage(mapped);\n        return { data: mapped, error: null, source: 'db' };\n      }\n\n      if (error && isMissingTableError(error)) {\n        console.warn('Departments table not accessible. Using local fallback.');\n      } else if (error) {\n        console.warn('Departments fetch error. Using local fallback:', error);\n      }\n    } catch (err) {\n      console.warn('Departments fetch exception. Using local fallback:', err);\n    }\n    if (USE_DEPARTMENTS_FALLBACK) {\n      const fallback = readDepartmentsFromStorage();\n      return { data: fallback, error: null, source: 'fallback' };\n    }\n\n    return { data: [], error: 'Database not accessible and fallback disabled', source: 'db' };\n  },\n\n  // Create a department (DB preferred, fallback to local)\n  async createDepartment(payload: Omit<Department, 'staffCount' | 'features' | 'workflow' | 'permissions'> & Partial<Pick<Department, 'features' | 'workflow' | 'permissions'>>): Promise<{ data: Department | null; error: any | null; source: 'db' | 'fallback' }> {\n    // Role check\n    const role = await getCurrentUserRole();\n    if (!ALLOWED_WRITE_ROLES.includes(String(role || '')) && !isAdminClientConfigured) {\n      return { data: null, error: 'Insufficient permissions', source: 'fallback' };\n    }\n\n    const newDept: Department = {\n      id: payload.id || payload.code?.toLowerCase() || (payload.name || '').toLowerCase().replace(/\\s+/g, '-'),\n      name: payload.name,\n      code: payload.code,\n      description: payload.description || '',\n      staffCount: 0,\n      features: payload.features || [],\n      workflow: payload.workflow || { stages: [], autoAssignment: false, escalationRules: [] },\n      permissions: payload.permissions || []\n    };\n\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { data, error } = await client\n        .from('departments' as any)\n        .insert({\n          id: newDept.id,\n          name: newDept.name,\n          code: newDept.code,\n          description: newDept.description,\n          staff_count: newDept.staffCount,\n          features: newDept.features,\n          workflow: newDept.workflow,\n          permissions: newDept.permissions\n        })\n        .select('*')\n        .maybeSingle();\n\n      if (!error && data) {\n        return { data: newDept, error: null, source: 'db' };\n      }\n\n      if (error && isMissingTableError(error)) {\n        console.warn('Departments table missing; writing to local storage.');\n      } else if (error) {\n        console.warn('Departments insert error; writing to local storage:', error);\n      }\n    } catch (err) {\n      console.warn('Departments insert exception; writing to local storage:', err);\n    }\n    if (USE_DEPARTMENTS_FALLBACK) {\n      const list = readDepartmentsFromStorage();\n      const updated = [...list, newDept];\n      writeDepartmentsToStorage(updated);\n      return { data: newDept, error: null, source: 'fallback' };\n    }\n\n    return { data: null, error: 'Database write failed and fallback disabled', source: 'db' };\n  },\n\n  // Update department\n  async updateDepartment(id: string, updates: Partial<Pick<Department, 'name' | 'code' | 'description' | 'features' | 'workflow' | 'permissions'>>): Promise<{ error: any | null; source: 'db' | 'fallback' }> {\n    const role = await getCurrentUserRole();\n    if (!ALLOWED_WRITE_ROLES.includes(String(role || '')) && !isAdminClientConfigured) {\n      return { error: 'Insufficient permissions', source: 'fallback' };\n    }\n\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { error } = await client\n        .from('departments' as any)\n        .update({\n          name: updates.name,\n          code: updates.code,\n          description: updates.description,\n          features: updates.features,\n          workflow: updates.workflow,\n          permissions: updates.permissions,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n\n      if (!error) {\n        return { error: null, source: 'db' };\n      }\n\n      if (isMissingTableError(error)) {\n        console.warn('Departments table missing; updating local storage.');\n      } else {\n        console.warn('Departments update error; updating local storage:', error);\n      }\n    } catch (err) {\n      console.warn('Departments update exception; updating local storage:', err);\n    }\n    if (USE_DEPARTMENTS_FALLBACK) {\n      const list = readDepartmentsFromStorage();\n      const updatedList = list.map((d) => (d.id === id ? { ...d, ...updates } as Department : d));\n      writeDepartmentsToStorage(updatedList);\n      return { error: null, source: 'fallback' };\n    }\n\n    return { error: 'Database update failed and fallback disabled', source: 'db' };\n  },\n\n  // Initialize department features from sample data when missing\n  async initializeDepartmentFeatures(id: string): Promise<{ error: any | null; source: 'db' | 'fallback' }> {\n    const role = await getCurrentUserRole();\n    if (!ALLOWED_WRITE_ROLES.includes(String(role || '')) && !isAdminClientConfigured) {\n      return { error: 'Insufficient permissions', source: 'fallback' };\n    }\n\n    // Find default features from sample data\n    const sample = sampleDepartments.find((d) => d.id === id);\n    const defaultFeatures = sample?.features || [];\n\n    if (!defaultFeatures || defaultFeatures.length === 0) {\n      // Nothing to initialize\n      return { error: null, source: 'db' };\n    }\n\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { error } = await client\n        .from('departments' as any)\n        .update({\n          features: defaultFeatures,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n\n      if (!error) {\n        // Also update local fallback copy\n        if (USE_DEPARTMENTS_FALLBACK) {\n          const list = readDepartmentsFromStorage();\n          const updatedList = list.map((d) => (d.id === id ? { ...d, features: defaultFeatures } : d));\n          writeDepartmentsToStorage(updatedList as Department[]);\n        }\n        return { error: null, source: 'db' };\n      }\n\n      if (isMissingTableError(error)) {\n        console.warn('Departments table missing; initializing features in local storage.');\n      } else {\n        console.warn('Initialize features error; updating local storage:', error);\n      }\n    } catch (err) {\n      console.warn('Initialize features exception; updating local storage:', err);\n    }\n\n    if (USE_DEPARTMENTS_FALLBACK) {\n      const list = readDepartmentsFromStorage();\n      const updatedList = list.map((d) => (d.id === id ? { ...d, features: defaultFeatures } : d));\n      writeDepartmentsToStorage(updatedList as Department[]);\n      return { error: null, source: 'fallback' };\n    }\n\n    return { error: 'Database update failed and fallback disabled', source: 'db' };\n  },\n\n  // Add or update a single feature in a department\n  async addFeatureToDepartment(id: string, feature: Department['features'][number]): Promise<{ error: any | null; source: 'db' | 'fallback' }> {\n    const role = await getCurrentUserRole();\n    if (!ALLOWED_WRITE_ROLES.includes(String(role || '')) && !isAdminClientConfigured) {\n      return { error: 'Insufficient permissions', source: 'fallback' };\n    }\n\n    // Fetch current features\n    let currentFeatures: Department['features'] = [];\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { data, error } = await client\n        .from('departments' as any)\n        .select('features')\n        .eq('id', id)\n        .maybeSingle();\n\n      if (!error && data) {\n        currentFeatures = Array.isArray((data as any).features) ? (data as any).features : [];\n      } else if (error && !isMissingTableError(error)) {\n        console.warn('Read features error before add:', error);\n      }\n    } catch (err) {\n      console.warn('Read features exception before add:', err);\n    }\n\n    // If DB read failed or table missing, try local fallback\n    if (currentFeatures.length === 0 && USE_DEPARTMENTS_FALLBACK) {\n      const list = readDepartmentsFromStorage();\n      const target = list.find((d) => d.id === id);\n      currentFeatures = target?.features || [];\n    }\n\n    // Upsert feature by id\n    const idx = currentFeatures.findIndex((f) => String(f.id) === String(feature.id));\n    let updatedFeatures: Department['features'] = [];\n    if (idx >= 0) {\n      updatedFeatures = currentFeatures.map((f, i) => (i === idx ? { ...f, ...feature } : f));\n    } else {\n      updatedFeatures = [...currentFeatures, feature];\n    }\n\n    // Write to DB\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { error } = await client\n        .from('departments' as any)\n        .update({\n          features: updatedFeatures,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n\n      if (!error) {\n        // Mirror to local fallback\n        if (USE_DEPARTMENTS_FALLBACK) {\n          const list = readDepartmentsFromStorage();\n          const updatedList = list.map((d) => (d.id === id ? { ...d, features: updatedFeatures } : d));\n          writeDepartmentsToStorage(updatedList as Department[]);\n        }\n        return { error: null, source: 'db' };\n      }\n\n      if (isMissingTableError(error)) {\n        console.warn('Departments table missing; adding feature in local storage.');\n      } else {\n        console.warn('Add feature error; updating local storage:', error);\n      }\n    } catch (err) {\n      console.warn('Add feature exception; updating local storage:', err);\n    }\n\n    // Fallback write\n    if (USE_DEPARTMENTS_FALLBACK) {\n      const list = readDepartmentsFromStorage();\n      const updatedList = list.map((d) => (d.id === id ? { ...d, features: updatedFeatures } : d));\n      writeDepartmentsToStorage(updatedList as Department[]);\n      return { error: null, source: 'fallback' };\n    }\n\n    return { error: 'Database update failed and fallback disabled', source: 'db' };\n  },\n\n  // Remove a single feature from a department\n  async removeFeatureFromDepartment(id: string, featureId: string): Promise<{ error: any | null; source: 'db' | 'fallback' }> {\n    const role = await getCurrentUserRole();\n    if (!ALLOWED_WRITE_ROLES.includes(String(role || '')) && !isAdminClientConfigured) {\n      return { error: 'Insufficient permissions', source: 'fallback' };\n    }\n\n    // Fetch current features\n    let currentFeatures: Department['features'] = [];\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { data, error } = await client\n        .from('departments' as any)\n        .select('features')\n        .eq('id', id)\n        .maybeSingle();\n\n      if (!error && data) {\n        currentFeatures = Array.isArray((data as any).features) ? (data as any).features : [];\n      } else if (error && !isMissingTableError(error)) {\n        console.warn('Read features error before remove:', error);\n      }\n    } catch (err) {\n      console.warn('Read features exception before remove:', err);\n    }\n\n    // If DB read failed or table missing, try local fallback\n    if (currentFeatures.length === 0 && USE_DEPARTMENTS_FALLBACK) {\n      const list = readDepartmentsFromStorage();\n      const target = list.find((d) => d.id === id);\n      currentFeatures = target?.features || [];\n    }\n\n    // Filter out the feature by id\n    const updatedFeatures: Department['features'] = (currentFeatures || []).filter((f) => String(f.id) !== String(featureId));\n\n    // Write to DB\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { error } = await client\n        .from('departments' as any)\n        .update({\n          features: updatedFeatures,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n\n      if (!error) {\n        // Mirror to local fallback\n        if (USE_DEPARTMENTS_FALLBACK) {\n          const list = readDepartmentsFromStorage();\n          const updatedList = list.map((d) => (d.id === id ? { ...d, features: updatedFeatures } : d));\n          writeDepartmentsToStorage(updatedList as Department[]);\n        }\n        return { error: null, source: 'db' };\n      }\n\n      if (isMissingTableError(error)) {\n        console.warn('Departments table missing; removing feature in local storage.');\n      } else {\n        console.warn('Remove feature error; updating local storage:', error);\n      }\n    } catch (err) {\n      console.warn('Remove feature exception; updating local storage:', err);\n    }\n\n    // Fallback write\n    if (USE_DEPARTMENTS_FALLBACK) {\n      const list = readDepartmentsFromStorage();\n      const updatedList = list.map((d) => (d.id === id ? { ...d, features: updatedFeatures } : d));\n      writeDepartmentsToStorage(updatedList as Department[]);\n      return { error: null, source: 'fallback' };\n    }\n\n    return { error: 'Database update failed and fallback disabled', source: 'db' };\n  },\n\n  // Delete department (prevent deletion if staff assigned)\n  async deleteDepartment(id: string): Promise<{ error: any | null; source: 'db' | 'fallback' }> {\n    const role = await getCurrentUserRole();\n    if (!ALLOWED_WRITE_ROLES.includes(String(role || '')) && !isAdminClientConfigured) {\n      return { error: 'Insufficient permissions', source: 'fallback' };\n    }\n\n    // Check assigned staff in profiles\n    try {\n      const { data: staffCountData, error: countError } = await (supabase as any)\n        .from('profiles' as any)\n        .select('id', { count: 'exact', head: true })\n        .eq('department', id);\n\n      const assignedCount = (staffCountData as any)?.length || 0; // Some clients return array; count with head:true often is in response.count\n      const count = (countError ? 0 : ((staffCountData as any)?.count ?? assignedCount));\n      if (!countError && Number(count) > 0) {\n        return { error: `Department has ${count} staff assigned`, source: 'db' };\n      }\n    } catch {}\n\n    // Try DB delete\n    try {\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      const { error } = await client\n        .from('departments' as any)\n        .delete()\n        .eq('id', id);\n\n      if (!error) {\n        return { error: null, source: 'db' };\n      }\n\n      if (isMissingTableError(error)) {\n        console.warn('Departments table missing; deleting in local storage.');\n      } else {\n        console.warn('Departments delete error; deleting in local storage:', error);\n      }\n    } catch (err) {\n      console.warn('Departments delete exception; deleting in local storage:', err);\n    }\n    if (USE_DEPARTMENTS_FALLBACK) {\n      const list = readDepartmentsFromStorage();\n      const updatedList = list.filter((d) => d.id !== id);\n      writeDepartmentsToStorage(updatedList);\n      return { error: null, source: 'fallback' };\n    }\n\n    return { error: 'Database delete failed and fallback disabled', source: 'db' };\n  },\n\n  // One-time migration: push localStorage fallback departments into Supabase\n  async migrateDepartmentsFallbackToSupabase(): Promise<{ migrated: number; error: any | null }> {\n    try {\n      const legacy = readLegacyDepartmentsFallback();\n      if (!Array.isArray(legacy) || legacy.length === 0) {\n        return { migrated: 0, error: null };\n      }\n\n      // Verify table is accessible before attempting upserts\n      const accessible = await checkTableAccessible();\n      if (!accessible) {\n        return { migrated: 0, error: 'Departments table not accessible. Please create it and configure RLS.' };\n      }\n\n      const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n      let migrated = 0;\n      for (const d of legacy) {\n        const payload: any = {\n          id: d.id,\n          name: d.name,\n          code: d.code,\n          description: d.description ?? null,\n          staff_count: Number(d.staffCount || 0),\n          features: Array.isArray(d.features) ? d.features : [],\n          workflow: d.workflow || { stages: [], autoAssignment: false, escalationRules: [] },\n          permissions: Array.isArray(d.permissions) ? d.permissions : []\n        };\n        const { error } = await client\n          .from('departments' as any)\n          .upsert(payload, { onConflict: 'id' } as any);\n        if (error) {\n          return { migrated, error };\n        }\n        migrated += 1;\n      }\n\n      return { migrated, error: null };\n    } catch (error) {\n      return { migrated: 0, error };\n    }\n  },\n\n  // Staff count map by department from profiles table (best-effort)\n  async getStaffCountsByDepartment(): Promise<Record<string, number>> {\n    const map: Record<string, number> = {};\n    try {\n      const { data, error } = await (supabase as any)\n        .from('profiles' as any)\n        .select('department', { count: 'exact' });\n\n      if (!error && Array.isArray(data)) {\n        for (const row of data as any[]) {\n          const dept = String(row.department || '').trim();\n          if (!dept) continue;\n          map[dept] = (map[dept] || 0) + 1;\n        }\n      }\n    } catch {}\n    return map;\n  }\n};\n\nexport default departmentService;","\nimport { User } from '@/types/User';\nimport { EnhancedStaffMember } from '@/types/staff';\nimport { AuthService } from '@/services/authService';\nimport { supabase, adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\n\n// Local credential storage has been removed in favor of Supabase-only auth.\n// The following types and functions are retained as no-ops for backward compatibility\n// and will be removed in a future cleanup.\ninterface StaffCredentials {\n  id: string;\n  staffId: string;\n  username: string;\n  password: string;\n  temporaryPassword: boolean;\n  mustChangePassword: boolean;\n  createdAt: string;\n  lastPasswordChange?: string;\n}\n\nexport const saveStaffCredentials = (_credentials: StaffCredentials): void => {\n  console.warn('saveStaffCredentials is deprecated. Local storage has been removed; rely on Supabase auth only.');\n};\n\nexport const getStoredCredentials = (): StaffCredentials[] => {\n  console.warn('getStoredCredentials is deprecated. Local storage has been removed; returning empty list.');\n  return [];\n};\n\nexport const createUserFromStaff = (\n  staff: EnhancedStaffMember, \n  username: string, \n  password: string,\n  mustChangePassword: boolean = false\n): User => {\n  const user: User = {\n    id: staff.id,\n    name: staff.name,\n    email: staff.email,\n    avatar: staff.avatar || `/avatars/avatar-${Math.floor(Math.random() * 5) + 1}.png`,\n    role: mapStaffRoleToUserRole(staff.role, staff.department),\n    department: staff.department,\n    phone: staff.phone,\n    status: staff.status === 'active' ? 'active' : 'inactive',\n    position: staff.position || staff.role,\n    workLocation: 'Head Office',\n    employeeId: staff.employeeId,\n    joinDate: staff.joinDate,\n    reportingManager: staff.reportingManager,\n    lastLogin: undefined,\n    skills: staff.skills,\n    certifications: staff.certifications,\n    permissions: mapDepartmentToPermissions(staff.department, staff.role),\n    languageAccess: true,\n    preferredLanguage: 'en'\n  };\n\n  return user;\n};\n\nconst mapStaffRoleToUserRole = (role: string, department: string): string => {\n  const normalized = (role || '').trim().toLowerCase();\n\n  // Preserve explicit UI roles; only collapse legacy/variants\n  const shortCodeMap: { [key: string]: string } = {\n    // Managerial roles\n    'manager': 'manager',\n    'hr_manager': 'hr_manager',\n    'finance_manager': 'manager',\n\n    // Staff/agent roles\n    'staff': 'staff',\n    'agent': 'agent',\n    'sales_agent': 'agent',\n    'senior agent': 'agent',\n    'executive': 'agent',\n  };\n\n  if (shortCodeMap[normalized]) return shortCodeMap[normalized];\n\n  // Legacy labels support\n  const legacyMap: { [key: string]: string } = {\n    'Manager': 'manager',\n    'Senior Agent': 'agent',\n    'Agent': 'agent',\n    'Executive': 'agent',\n    'HR Manager': 'hr_manager',\n    'Finance Manager': 'manager',\n    'Staff': 'staff'\n  };\n\n  return legacyMap[role] || 'agent';\n};\n\nconst mapDepartmentToPermissions = (department: string, role: string): string[] => {\n  const basePermissions: { [key: string]: string[] } = {\n    'Sales': ['queries.view', 'queries.create', 'bookings.view', 'bookings.create'],\n    'Operations': ['bookings.*', 'inventory.view', 'vendors.*'],\n    'Customer Support': ['agents.*', 'tickets.*', 'communication.*'],\n    'Human Resources': ['staff.*', 'hr.*', 'attendance.*', 'payroll.*'],\n    'Finance': ['finance.*', 'reports.*', 'commission.*', 'billing.*'],\n    'Field Sales': ['leads.*', 'agents.create', 'agents.view', 'territory.*'],\n    'Marketing': ['inventory.view', 'queries.view']\n  };\n\n  const roleBonus: { [key: string]: string[] } = {\n    'Manager': ['manage_staff', 'view_reports', 'manage_queries'],\n    'Senior Agent': ['create_proposals', 'view_analytics']\n  };\n\n  const permissions = basePermissions[department] || ['queries.view'];\n  const additionalPermissions = roleBonus[role] || [];\n\n  return [...permissions, ...additionalPermissions];\n};\n\nexport const syncStaffWithAuthSystem = async (\n  staff: EnhancedStaffMember,\n  username: string,\n  password: string,\n  mustChangePassword: boolean = true\n): Promise<string | null> => {\n  try {\n    console.log(' Syncing staff with auth system:', { name: staff.name, username, email: staff.email });\n\n    // Attempt Supabase sign-up to create real auth user and profile\n    // Use UI dropdown role exactly for public.profiles: staff | manager | hr_manager\n    const uiRole = (staff.role || '').trim().toLowerCase();\n    const roleForProfile = ['staff','manager','hr_manager'].includes(uiRole) ? uiRole : 'staff';\n    const { user: remoteUser, error } = await AuthService.signUp(staff.email, password, {\n      name: staff.name,\n      role: roleForProfile,\n      department: staff.department,\n      phone: staff.phone,\n      position: staff.position || staff.role,\n      employee_id: staff.employeeId,\n      must_change_password: mustChangePassword,\n    });\n\n    if (error) {\n      console.warn(' Supabase signup failed:', error);\n    }\n\n    // Verify and hard-sync profiles/staff tables when remote user exists\n    if (remoteUser && remoteUser.id) {\n      try {\n        const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n\n        const expectedRole = roleForProfile;\n        const expectedDepartment = staff.department;\n\n        const { data: profileRow, error: profileErr } = await client\n          .from('profiles' as any)\n          .select('id, role, department, position, must_change_password')\n          .eq('id', remoteUser.id)\n          .maybeSingle();\n\n        if (!profileErr && profileRow) {\n          const profileUpdates: any = {};\n          const currRole = String((profileRow as any)?.role || '').toLowerCase();\n          const currDept = String((profileRow as any)?.department || '');\n          const currPos = String((profileRow as any)?.position || '');\n          const currMustChange = Boolean((profileRow as any)?.must_change_password === true);\n          if (currRole !== expectedRole) profileUpdates.role = expectedRole;\n          if (currDept !== expectedDepartment) profileUpdates.department = expectedDepartment;\n          const desiredPosition = staff.position || staff.role;\n          if (desiredPosition && currPos !== desiredPosition) profileUpdates.position = desiredPosition;\n          if (!currMustChange) profileUpdates.must_change_password = true;\n          if (Object.keys(profileUpdates).length > 0) {\n            await client\n              .from('profiles' as any)\n              .update({ ...profileUpdates, updated_at: new Date().toISOString() })\n              .eq('id', remoteUser.id);\n          }\n        }\n\n        const { data: staffRow, error: staffErr } = await client\n          .from('staff' as any)\n          .select('id, role, department, join_date, date_of_birth, reporting_manager, operational_countries')\n          .eq('id', remoteUser.id)\n          .maybeSingle();\n\n        if (staffErr || !staffRow) {\n          await client\n            .from('staff' as any)\n            .upsert({\n              id: remoteUser.id,\n              name: staff.name,\n              email: staff.email,\n              phone: staff.phone,\n              department: expectedDepartment,\n              role: expectedRole,\n              status: 'active',\n              employee_id: staff.employeeId,\n              join_date: staff.joinDate,\n              reporting_manager: staff.reportingManager ?? null,\n              date_of_birth: staff.dateOfBirth ?? null,\n              operational_countries: Array.isArray(staff.operationalCountries) ? staff.operationalCountries : null,\n              updated_at: new Date().toISOString()\n            }, { onConflict: 'id' });\n        } else {\n          const sRole = String((staffRow as any)?.role || '').toLowerCase();\n          const sDept = String((staffRow as any)?.department || '');\n          const staffUpdates: any = {};\n          if (sRole !== expectedRole) staffUpdates.role = expectedRole;\n          if (sDept !== expectedDepartment) staffUpdates.department = expectedDepartment;\n          // Ensure extended fields are up-to-date\n          const sJoin = String((staffRow as any)?.join_date || '');\n          const sDob = String((staffRow as any)?.date_of_birth || '');\n          const sMgr = String((staffRow as any)?.reporting_manager || '');\n          const sCountries = Array.isArray((staffRow as any)?.operational_countries) ? (staffRow as any)?.operational_countries : [];\n          if (staff.joinDate && staff.joinDate !== sJoin) staffUpdates.join_date = staff.joinDate;\n          if (staff.dateOfBirth && staff.dateOfBirth !== sDob) staffUpdates.date_of_birth = staff.dateOfBirth;\n          if (staff.reportingManager && staff.reportingManager !== sMgr) staffUpdates.reporting_manager = staff.reportingManager;\n          if (Array.isArray(staff.operationalCountries)) {\n            const incoming = staff.operationalCountries;\n            const eq = Array.isArray(sCountries) && incoming.length === sCountries.length && incoming.every((c: any, idx: number) => String(c) === String(sCountries[idx]));\n            if (!eq) staffUpdates.operational_countries = incoming;\n          }\n          if (Object.keys(staffUpdates).length > 0) {\n            await client\n              .from('staff' as any)\n              .update({ ...staffUpdates, updated_at: new Date().toISOString() })\n              .eq('id', remoteUser.id);\n          }\n        }\n      } catch (verifyErr) {\n        console.warn(' Verification sync failed (non-blocking):', verifyErr);\n      }\n    }\n\n    console.log(' Staff synced with auth system successfully:', {\n      staff: staff.name,\n      username,\n      email: staff.email,\n      canLoginWith: ['username', 'email'],\n      userId: remoteUser?.id || null,\n      status: remoteUser?.status\n    });\n    return remoteUser?.id || null;\n  } catch (error) {\n    console.error(' Error syncing staff with auth system:', error);\n    return null;\n  }\n};\n\nexport const getCredentialsByStaffId = (staffId: string): StaffCredentials | null => {\n  console.warn('getCredentialsByStaffId is deprecated. Local storage has been removed; returning null.');\n  return null;\n};\n","import { supabase } from '@/integrations/supabase/client';\n// The generated Supabase types may not yet include newly added tables.\n// Use a lightly-typed alias to avoid overload/type narrowing issues during CRUD.\nconst sb = supabase as any;\n\nexport type WorkingShift = {\n  id?: string;\n  startTime: string;\n  endTime: string;\n  breakStart?: string;\n  breakEnd?: string;\n  label?: string;\n};\n\nexport type WorkingHoursUI = Record<string, { isWorking: boolean; shifts: WorkingShift[] }>;\n\nconst dayKeyToIndex: Record<string, number> = {\n  monday: 0,\n  tuesday: 1,\n  wednesday: 2,\n  thursday: 3,\n  friday: 4,\n  saturday: 5,\n  sunday: 6,\n};\n\nconst indexToDayKey = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n\nconst normalizeUIHours = (ui: any): WorkingHoursUI => {\n  const result: WorkingHoursUI = {} as any;\n  indexToDayKey.forEach((day) => {\n    const v = ui?.[day];\n    if (v && Array.isArray(v.shifts)) {\n      result[day] = { isWorking: !!v.isWorking, shifts: v.shifts as WorkingShift[] };\n    } else {\n      result[day] = { isWorking: !!v?.isWorking, shifts: [] };\n    }\n  });\n  return result;\n};\n\nconst mapUIToRows = (staffId: string, ui: WorkingHoursUI, timezone?: string) => {\n  return Object.entries(ui).map(([day, data]) => ({\n    staff_id: staffId,\n    day_of_week: dayKeyToIndex[day] ?? 0,\n    is_working: !!data.isWorking,\n    shifts: data.shifts ? JSON.parse(JSON.stringify(data.shifts)) : [],\n    timezone: timezone,\n  }));\n};\n\nconst mapRowsToUI = (rows: any[]): WorkingHoursUI => {\n  const base: WorkingHoursUI = normalizeUIHours({});\n  rows.forEach((r) => {\n    const key = indexToDayKey[r.day_of_week ?? 0] ?? 'monday';\n    base[key] = {\n      isWorking: !!r.is_working,\n      shifts: Array.isArray(r.shifts) ? r.shifts : [],\n    };\n  });\n  return base;\n};\n\nexport const staffWorkingHoursService = {\n  async getWorkingHoursByStaff(staffId: string) {\n    const { data, error } = await sb\n      .from('staff_working_hours')\n      .select('day_of_week, is_working, shifts, timezone')\n      .eq('staff_id', staffId)\n      .order('day_of_week', { ascending: true });\n    if (error) {\n      console.warn('Failed to load working hours', error);\n      return { data: normalizeUIHours({}), error };\n    }\n    return { data: mapRowsToUI(((data || []) as any[])), error: null };\n  },\n\n  async getTimezoneByStaff(staffId: string) {\n    const { data, error } = await sb\n      .from('staff_working_hours')\n      .select('timezone')\n      .eq('staff_id', staffId)\n      .limit(1);\n    if (error) {\n      console.warn('Failed to load staff timezone', error);\n      return { timezone: null as string | null, error } as any;\n    }\n    const tz = Array.isArray(data) && data.length > 0 ? (data[0]?.timezone || null) : null;\n    return { timezone: tz, error: null } as any;\n  },\n\n  async upsertWorkingHours(staffId: string, uiHours: any, timezone?: string) {\n    const normalized = normalizeUIHours(uiHours);\n    const rows = mapUIToRows(staffId, normalized, timezone);\n    // Simple replace strategy: delete then insert to keep unique(day) invariant cleanly\n    const del = await sb.from('staff_working_hours').delete().eq('staff_id', staffId);\n    if (del.error) {\n      console.warn('Failed to delete prior working hours', del.error);\n      return { data: null, error: del.error };\n    }\n    const { data, error } = await sb.from('staff_working_hours').insert(rows as any).select();\n    if (error) {\n      console.warn('Failed to insert working hours', error);\n      return { data: null, error };\n    }\n    return { data, error: null };\n  },\n\n  async deleteWorkingHoursForStaff(staffId: string) {\n    const { error } = await sb.from('staff_working_hours').delete().eq('staff_id', staffId);\n    return { error };\n  },\n\n  async setWorkingDay(\n    staffId: string,\n    dayKey: keyof WorkingHoursUI,\n    payload: { isWorking: boolean; shifts: WorkingShift[]; timezone?: string }\n  ) {\n    const dayIndex = dayKeyToIndex[String(dayKey)];\n    if (dayIndex == null) return { error: 'Invalid day' } as any;\n    const row = {\n      staff_id: staffId,\n      day_of_week: dayIndex,\n      is_working: !!payload.isWorking,\n      shifts: payload.shifts ?? [],\n      timezone: payload.timezone,\n    };\n    // Upsert via delete+insert for simplicity\n    const del = await sb\n      .from('staff_working_hours')\n      .delete()\n      .eq('staff_id', staffId)\n      .eq('day_of_week', dayIndex);\n    if (del.error) return { error: del.error };\n    const { data, error } = await sb.from('staff_working_hours').insert(row as any).select().single();\n    return { data, error };\n  },\n};","import { supabase } from '@/integrations/supabase/client';\nimport { Target as UITarget } from '@/types/staff';\n\n// The generated Supabase types don't yet include the new tables.\n// Use a lightly-typed client to avoid union-narrowing errors while we wire functionality.\nconst sb = supabase as any;\n\nexport type StaffTargetRow = {\n  id: string;\n  staff_id: string;\n  name: string;\n  type: string;\n  value: number;\n  achieved: number;\n  period: 'daily' | 'weekly' | 'monthly' | 'quarterly';\n  start_date: string; // yyyy-mm-dd\n  end_date: string;   // yyyy-mm-dd\n  status: 'active' | 'completed' | 'overdue';\n  created_at?: string;\n  updated_at?: string;\n};\n\nconst mapUIToRow = (staffId: string, t: UITarget): Omit<StaffTargetRow, 'id'> => ({\n  staff_id: staffId,\n  name: t.name ?? 'Target',\n  type: t.type ?? 'revenue',\n  value: Number(t.value ?? 0),\n  achieved: Number(t.achieved ?? 0),\n  period: (t.period as any) ?? 'monthly',\n  start_date: t.startDate ?? new Date().toISOString().slice(0, 10),\n  end_date: t.endDate ?? new Date().toISOString().slice(0, 10),\n  status: (t.status as any) ?? 'active',\n});\n\nconst mapRowToUI = (r: StaffTargetRow): UITarget => ({\n  id: r.id,\n  name: r.name,\n  type: r.type as any,\n  value: r.value,\n  achieved: r.achieved,\n  period: r.period as any,\n  startDate: r.start_date,\n  endDate: r.end_date,\n  status: r.status as any,\n});\n\nexport const staffTargetService = {\n  async listTargetsByStaff(staffId: string) {\n    const { data, error } = await sb\n      .from('staff_targets')\n      .select('*')\n      .eq('staff_id', staffId)\n      .order('start_date', { ascending: true });\n    if (error) {\n      console.warn('Failed to load targets', error);\n      return { data: [] as UITarget[], error };\n    }\n    return { data: ((data || []) as StaffTargetRow[]).map(mapRowToUI), error: null };\n  },\n\n  async replaceTargetsForStaff(staffId: string, targets: UITarget[]) {\n    // Replace strategy: delete all then insert current list\n    const del = await sb.from('staff_targets').delete().eq('staff_id', staffId);\n    if (del.error) {\n      console.warn('Failed to delete prior targets', del.error);\n      return { data: null, error: del.error };\n    }\n    if (!targets || targets.length === 0) return { data: [], error: null };\n    const rows = targets.map((t) => mapUIToRow(staffId, t));\n    const { data, error } = await sb.from('staff_targets').insert(rows).select();\n    if (error) {\n      console.warn('Failed to insert targets', error);\n      return { data: null, error };\n    }\n    return { data, error: null };\n  },\n\n  async createTarget(staffId: string, target: UITarget) {\n    const row = mapUIToRow(staffId, target);\n    const { data, error } = await sb.from('staff_targets').insert(row).select().single();\n    return { data, error };\n  },\n\n  async updateTarget(id: string, updates: Partial<UITarget>) {\n    const normalized: any = {};\n    if (updates.name != null) normalized.name = updates.name;\n    if (updates.type != null) normalized.type = updates.type;\n    if (updates.value != null) normalized.value = updates.value;\n    if (updates.achieved != null) normalized.achieved = updates.achieved;\n    if (updates.period != null) normalized.period = updates.period;\n    if (updates.startDate != null) normalized.start_date = updates.startDate;\n    if (updates.endDate != null) normalized.end_date = updates.endDate;\n    if (updates.status != null) normalized.status = updates.status;\n    const { data, error } = await sb.from('staff_targets').update(normalized).eq('id', id).select().single();\n    return { data, error };\n  },\n\n  async deleteTarget(id: string) {\n    const { error } = await sb.from('staff_targets').delete().eq('id', id);\n    return { error };\n  },\n};","import { supabase, adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\nimport { StaffDocument } from '@/types/staff';\n\nconst BUCKET = 'staff_docs';\n\nfunction toStaffDocument(row: any): StaffDocument {\n  return {\n    id: row.id,\n    staffId: row.staff_id,\n    docType: row.doc_type,\n    fileName: row.file_name,\n    fileExt: row.file_ext || undefined,\n    mimeType: row.mime_type || undefined,\n    sizeBytes: row.size_bytes || undefined,\n    storagePath: row.storage_path,\n    sha256: row.sha256 || undefined,\n    status: row.status,\n    verifiedBy: row.verified_by || undefined,\n    verifiedAt: row.verified_at || undefined,\n    notes: row.notes || undefined,\n    createdAt: row.created_at,\n    updatedAt: row.updated_at,\n  };\n}\n\nfunction slugify(name: string): string {\n  return (name || '')\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/(^-|-$)/g, '')\n    .slice(0, 64);\n}\n\nexport async function listDocuments(staffId: string): Promise<StaffDocument[]> {\n  const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n  const { data, error } = await client\n    .from('staff_documents' as any)\n    .select('*')\n    .eq('staff_id', staffId)\n    .order('created_at', { ascending: false });\n  if (error) throw new Error(error.message);\n  return (data || []).map(toStaffDocument);\n}\n\nexport async function getSignedUrl(storagePath: string, expiresInSeconds: number = 3600): Promise<string | null> {\n  const { data, error } = await supabase.storage.from(BUCKET).createSignedUrl(storagePath, expiresInSeconds);\n  if (error) return null;\n  return data?.signedUrl || null;\n}\n\nexport async function uploadDocument(\n  staffId: string,\n  file: File,\n  docType: string,\n  notes?: string\n): Promise<StaffDocument> {\n  const ext = (file.name.split('.').pop() || '').toLowerCase();\n  const base = slugify(file.name.replace(/\\.[^.]+$/, ''));\n  const unique = crypto.randomUUID();\n  const storagePath = `staff/${staffId}/documents/${unique}_${base}${ext ? '.' + ext : ''}`;\n\n  const { error: uploadErr } = await supabase.storage.from(BUCKET).upload(storagePath, file, {\n    upsert: true,\n    cacheControl: '3600',\n  });\n  if (uploadErr) throw new Error(uploadErr.message);\n\n  const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n  const { data, error } = await client\n    .from('staff_documents' as any)\n    .insert({\n      staff_id: staffId,\n      doc_type: docType,\n      file_name: file.name,\n      file_ext: ext || null,\n      mime_type: file.type || null,\n      size_bytes: (file as any).size || null,\n      storage_path: storagePath,\n      status: 'pending',\n      notes: notes || null,\n    })\n    .select('*')\n    .single();\n\n  if (error) throw new Error(error.message);\n  return toStaffDocument(data);\n}\n\nexport async function approveDocument(documentId: string): Promise<void> {\n  const { error } = await supabase\n    .from('staff_documents' as any)\n    .update({ status: 'approved' })\n    .eq('id', documentId);\n  if (error) throw new Error(error.message);\n}\n\nexport async function rejectDocument(documentId: string, notes?: string): Promise<void> {\n  const { error } = await supabase\n    .from('staff_documents' as any)\n    .update({ status: 'rejected', notes: notes || null })\n    .eq('id', documentId);\n  if (error) throw new Error(error.message);\n}\n\nexport async function deleteDocument(doc: StaffDocument): Promise<void> {\n  // Remove storage object first\n  const { error: delErr } = await supabase.storage.from(BUCKET).remove([doc.storagePath]);\n  if (delErr) throw new Error(delErr.message);\n\n  const { error } = await supabase\n    .from('staff_documents' as any)\n    .delete()\n    .eq('id', doc.id);\n  if (error) throw new Error(error.message);\n}","import { supabase, adminSupabase, isAdminClientConfigured } from '@/lib/supabaseClient';\nimport { StaffBankAccount, BankVerificationStatus } from '@/types/staff';\n\nfunction toBank(row: any): StaffBankAccount {\n  return {\n    id: row.id,\n    staffId: row.staff_id,\n    bankName: row.bank_name,\n    accountHolderName: row.account_holder_name,\n    accountNumberLast4: row.account_number_last4,\n    country: row.country || undefined,\n    ifscOrSwift: row.ifsc_or_swift || undefined,\n    branch: row.branch || undefined,\n    verifiedStatus: row.verified_status,\n    verifiedBy: row.verified_by || undefined,\n    verifiedAt: row.verified_at || undefined,\n    createdAt: row.created_at,\n    updatedAt: row.updated_at,\n  };\n}\n\nexport interface BankAccountInput {\n  bankName: string;\n  accountHolderName: string;\n  accountNumber: string; // plaintext for encryption in RPC\n  country?: string;\n  ifscOrSwift?: string;\n  branch?: string;\n}\n\nexport async function getBankAccount(staffId: string): Promise<StaffBankAccount | null> {\n  const client: any = (isAdminClientConfigured && adminSupabase) ? adminSupabase : supabase;\n  const { data, error } = await client\n    .from('staff_bank_accounts' as any)\n    .select('*')\n    .eq('staff_id', staffId)\n    .maybeSingle();\n  if (error) throw new Error(error.message);\n  if (!data) return null;\n  return toBank(data);\n}\n\nexport async function upsertBankAccount(staffId: string, input: BankAccountInput): Promise<StaffBankAccount> {\n  const { data, error } = await (supabase as any).rpc('upsert_staff_bank_account', {\n    p_staff_id: staffId,\n    p_bank_name: input.bankName,\n    p_account_holder_name: input.accountHolderName,\n    p_account_number_plain: input.accountNumber,\n    p_ifsc_or_swift: input.ifscOrSwift || null,\n    p_country: input.country || null,\n    p_branch: input.branch || null,\n  });\n  if (error) throw new Error(error.message);\n  return toBank(data);\n}\n\nexport async function updateBankVerificationStatus(accountId: string, status: BankVerificationStatus): Promise<void> {\n  const { error } = await supabase\n    .from('staff_bank_accounts' as any)\n    .update({ verified_status: status })\n    .eq('id', accountId);\n  if (error) throw new Error(error.message);\n}\n\nexport async function deleteBankAccount(accountId: string): Promise<void> {\n  const { error } = await supabase\n    .from('staff_bank_accounts' as any)\n    .delete()\n    .eq('id', accountId);\n  if (error) throw new Error(error.message);\n}","/*\n * Meta WhatsApp Settings Service\n * Handles Meta WhatsApp Business API configuration management\n */\n\nimport { z } from 'zod';\nimport { adminSupabase } from '@/lib/supabaseClient';\n\n// Validation schemas\nconst metaSettingsSchema = z.object({\n  waba_id: z.string().min(1, 'WhatsApp Business Account ID is required'),\n  phone_id: z.string().min(1, 'Phone Number ID is required'),\n  token: z.string().min(1, 'Access token is required'),\n  template_name: z.string().min(1, 'Template name is required').default('otp_verification'),\n  business_name: z.string().min(1, 'Business name is required'),\n  is_active: z.boolean().optional().default(true)\n});\n\nconst testMessageSchema = z.object({\n  phone: z.string().min(10, 'Phone number is required').max(15, 'Phone number too long'),\n  message: z.string().min(1, 'Message is required').max(1000, 'Message too long')\n});\n\nexport interface MetaSettings {\n  id?: string;\n  waba_id: string;\n  phone_id: string;\n  token: string;\n  template_name: string;\n  business_name: string;\n  is_active: boolean;\n  created_at?: string;\n  updated_at?: string;\n}\n\nexport interface TestMessageResult {\n  success: boolean;\n  message_id?: string;\n  error?: string;\n}\n\n/**\n * Get current Meta WhatsApp settings\n */\nexport async function getMetaSettings(): Promise<{ success: boolean; data?: MetaSettings; error?: string }> {\n  try {\n    const { data, error } = await adminSupabase\n      .from('meta_settings')\n      .select('*')\n      .eq('is_active', true)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return { success: false, error: 'No Meta WhatsApp configuration found' };\n      }\n      throw new Error(`Database error: ${error.message}`);\n    }\n\n    return { success: true, data };\n  } catch (error) {\n    console.error(' Error fetching Meta settings:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n/**\n * Update Meta WhatsApp settings\n */\nexport async function updateMetaSettings(settings: MetaSettings): Promise<{ success: boolean; data?: MetaSettings; error?: string }> {\n  try {\n    // Validate input\n    const validatedData = metaSettingsSchema.parse(settings);\n\n    // Check if settings exist\n    const existing = await getMetaSettings();\n    \n    let result;\n    if (existing.success && existing.data) {\n      // Update existing settings\n      const { data, error } = await adminSupabase\n        .from('meta_settings')\n        .update({\n          ...validatedData,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', existing.data.id)\n        .select()\n        .single();\n\n      if (error) throw new Error(`Update failed: ${error.message}`);\n      result = data;\n    } else {\n      // Create new settings (ensure only one active configuration)\n      await adminSupabase\n        .from('meta_settings')\n        .update({ is_active: false })\n        .neq('id', '00000000-0000-0000-0000-000000000000');\n\n      // Insert new settings\n      const { data, error } = await adminSupabase\n        .from('meta_settings')\n        .insert({\n          ...validatedData,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        })\n        .select()\n        .single();\n\n      if (error) throw new Error(`Insert failed: ${error.message}`);\n      result = data;\n    }\n\n    return { success: true, data: result };\n  } catch (error) {\n    console.error(' Error updating Meta settings:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n/**\n * Test WhatsApp connection by sending a test message\n */\nexport async function testWhatsAppConnection(phone: string, message: string): Promise<TestMessageResult> {\n  try {\n    // Validate input\n    const validatedData = testMessageSchema.parse({ phone, message });\n    \n    // Get Meta settings\n    const settings = await getMetaSettings();\n    if (!settings.success || !settings.data) {\n      return { success: false, error: 'Meta WhatsApp not configured' };\n    }\n\n    const config = settings.data;\n    \n    // First, verify the phone number ID exists and is accessible\n    const phoneCheckResponse = await fetch(\n      `https://graph.facebook.com/v18.0/${config.phone_id}?access_token=${config.token}`,\n      { method: 'GET' }\n    );\n\n    if (!phoneCheckResponse.ok) {\n      const phoneError = await phoneCheckResponse.json();\n      let errorMessage = 'WhatsApp API error: ';\n      \n      if (phoneError.error?.code === 100) {\n        errorMessage += 'Phone number ID not found. Please verify your Phone Number ID is correct and registered with WhatsApp Business.';\n      } else if (phoneError.error?.code === 190) {\n        errorMessage += 'Access token is invalid or expired. Please generate a new token from Meta Business Manager.';\n      } else if (phoneError.error?.message?.includes('does not exist')) {\n        errorMessage += 'The specified phone number ID does not exist. Please check your WhatsApp Business configuration.';\n      } else if (phoneError.error?.message?.includes('permissions')) {\n        errorMessage += 'Missing permissions. Please ensure your app has WhatsApp Business API permissions enabled.';\n      } else {\n        errorMessage += phoneError.error?.message || 'Failed to verify phone number ID';\n      }\n      \n      return { \n        success: false, \n        error: errorMessage\n      };\n    }\n\n    // Format phone number\n    const formattedPhone = validatedData.phone.startsWith('+') \n      ? validatedData.phone \n      : `+${validatedData.phone}`;\n\n    // Prepare test message\n    const testMessage = {\n      messaging_product: 'whatsapp',\n      to: formattedPhone,\n      type: 'text',\n      text: {\n        body: validatedData.message\n      }\n    };\n\n    // Send message via Meta API\n    const response = await fetch(\n      `https://graph.facebook.com/v18.0/${config.phone_id}/messages`,\n      {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${config.token}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(testMessage)\n      }\n    );\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      let errorMessage = 'WhatsApp API error: ';\n      \n      // Handle specific error codes\n      if (errorData.error?.code === 100) {\n        errorMessage += 'Unsupported request. Please verify your phone number is properly registered with WhatsApp Business.';\n      } else if (errorData.error?.code === 200) {\n        errorMessage += 'Permissions error. Please ensure your app has the necessary WhatsApp Business API permissions.';\n      } else if (errorData.error?.code === 190) {\n        errorMessage += 'Access token expired or invalid. Please generate a new token.';\n      } else if (errorData.error?.type === 'OAuthException') {\n        errorMessage += 'Authentication failed. Please check your access token and app permissions.';\n      } else if (errorData.error?.message?.includes('does not exist')) {\n        errorMessage += 'The specified object does not exist. Please check your WhatsApp Business configuration.';\n      } else {\n        errorMessage += errorData.error?.message || 'Failed to send WhatsApp message';\n      }\n      \n      return { \n        success: false, \n        error: errorMessage\n      };\n    }\n\n    const result = await response.json();\n    \n    console.log(' Test WhatsApp message sent:', {\n      phone: formattedPhone,\n      messageId: result.messages?.[0]?.id\n    });\n\n    return {\n      success: true,\n      message_id: result.messages?.[0]?.id\n    };\n  } catch (error) {\n    console.error(' Test WhatsApp message failed:', error);\n    return { \n      success: false, \n      error: error.message \n    };\n  }\n}\n\n/**\n * Validate WhatsApp Business Account ID format\n */\nexport function validateWabaId(wabaId: string): boolean {\n  // WhatsApp Business Account ID format: typically starts with a number\n  const wabaRegex = /^\\d{10,}$/;\n  return wabaRegex.test(wabaId);\n}\n\n/**\n * Validate Phone Number ID format\n */\nexport function validatePhoneId(phoneId: string): boolean {\n  // Phone Number ID format: typically starts with a number\n  const phoneIdRegex = /^\\d{10,}$/;\n  return phoneIdRegex.test(phoneId);\n}\n\n/**\n * Validate Meta access token format\n */\nexport function validateAccessToken(token: string): boolean {\n  // Meta access token format: typically starts with 'EAA' or similar\n  const tokenRegex = /^[A-Za-z0-9]{100,}$/;\n  return tokenRegex.test(token) && token.length >= 100;\n}\n\n/**\n * Check if access token might be expired based on format\n */\nexport function checkTokenExpirationRisk(token: string): { isValid: boolean; riskLevel: 'low' | 'medium' | 'high'; message: string } {\n  if (!token || token.length < 50) {\n    return {\n      isValid: false,\n      riskLevel: 'high',\n      message: 'Token appears to be invalid or too short'\n    };\n  }\n\n  if (!token.startsWith('EAA')) {\n    return {\n      isValid: false,\n      riskLevel: 'high',\n      message: 'Token should start with \"EAA\" for Meta Business API'\n    };\n  }\n\n  // Check if token contains common expired token patterns\n  const expiredPatterns = ['expired', 'invalid', 'session'];\n  const hasExpiredPattern = expiredPatterns.some(pattern => token.toLowerCase().includes(pattern));\n  \n  if (hasExpiredPattern) {\n    return {\n      isValid: true,\n      riskLevel: 'high',\n      message: 'Token may be expired or invalid'\n    };\n  }\n\n  return {\n    isValid: true,\n    riskLevel: 'low',\n    message: 'Token format appears valid'\n  };\n}\n\n/**\n * Mask sensitive token data for display\n */\nexport function maskToken(token: string): string {\n  if (!token || token.length < 8) return '***';\n  return `${token.substring(0, 4)}...${token.substring(token.length - 4)}`;\n}\n\n/**\n * Get connection status\n */\nexport async function getConnectionStatus(): Promise<'connected' | 'disconnected' | 'error'> {\n  try {\n    const settings = await getMetaSettings();\n    if (!settings.success || !settings.data) {\n      return 'disconnected';\n    }\n\n    // Test connection with a simple API call\n    const config = settings.data;\n    const response = await fetch(\n      `https://graph.facebook.com/v18.0/${config.phone_id}?access_token=${config.token}`,\n      { method: 'GET' }\n    );\n\n    if (response.ok) {\n      return 'connected';\n    } else {\n      return 'error';\n    }\n  } catch (error) {\n    console.error(' Connection status check failed:', error);\n    return 'error';\n  }\n}","export interface ActivityEvent {\n  id: string;\n  staffId: string;\n  timestamp: string;\n  type: 'page_view' | 'action' | 'idle' | 'active' | 'break' | 'login' | 'logout';\n  details: {\n    page?: string;\n    action?: string;\n    duration?: number;\n    url?: string;\n    element?: string;\n    coordinates?: { x: number; y: number };\n  };\n}\n\nexport interface ProductivityMetrics {\n  totalActiveTime: number;\n  totalIdleTime: number;\n  pageViews: number;\n  actionsPerformed: number;\n  averageSessionDuration: number;\n  productivityScore: number;\n  breakTime: number;\n  focusTime: number;\n  mostVisitedPages: Array<{ page: string; count: number; duration: number }>;\n  hourlyActivity: Array<{ hour: number; activity: number }>;\n}\n\nexport class ActivityTrackingService {\n  private idleTimer: NodeJS.Timeout | null = null;\n  private isTracking = false;\n  private currentStaffId: string | null = null;\n  private lastActivity: Date = new Date();\n  private idleThreshold = 5 * 60 * 1000; // 5 minutes\n  private currentSession: string | null = null;\n  private activities: ActivityEvent[] = [];\n  private listeners: Array<() => void> = [];\n\n  constructor() {\n    this.loadActivities();\n  }\n\n  private loadActivities(): void {\n    try {\n      const stored = localStorage.getItem('activity_tracking_data');\n      if (stored) {\n        this.activities = JSON.parse(stored);\n      }\n    } catch (error) {\n      console.error('Error loading activity data:', error);\n      this.activities = [];\n    }\n  }\n\n  private saveActivities(): void {\n    try {\n      localStorage.setItem('activity_tracking_data', JSON.stringify(this.activities));\n    } catch (error) {\n      console.error('Error saving activity data:', error);\n    }\n  }\n\n  startTracking(staffId: string): void {\n    if (this.isTracking) {\n      this.stopTracking();\n    }\n\n    this.isTracking = true;\n    this.currentStaffId = staffId;\n    this.currentSession = `session_${Date.now()}`;\n    this.lastActivity = new Date();\n\n    // Record login activity\n    this.recordActivity(staffId, {\n      type: 'login',\n      details: {\n        page: window.location.pathname,\n        url: window.location.href\n      }\n    });\n\n    // Set up activity listeners\n    this.setupActivityListeners();\n    this.startIdleMonitoring();\n\n    console.log(`Activity tracking started for staff: ${staffId}`);\n  }\n\n  stopTracking(): void {\n    if (!this.isTracking || !this.currentStaffId) return;\n\n    // Record logout activity\n    this.recordActivity(this.currentStaffId, {\n      type: 'logout',\n      details: {\n        page: window.location.pathname,\n        duration: Date.now() - new Date(this.lastActivity).getTime()\n      }\n    });\n\n    this.isTracking = false;\n    this.removeActivityListeners();\n    this.stopIdleMonitoring();\n    this.currentStaffId = null;\n    this.currentSession = null;\n\n    console.log('Activity tracking stopped');\n  }\n\n  private setupActivityListeners(): void {\n    // Mouse movement tracking\n    const handleMouseMove = (event: MouseEvent) => {\n      this.updateLastActivity();\n      this.recordActivity(this.currentStaffId!, {\n        type: 'active',\n        details: {\n          action: 'mouse_move',\n          coordinates: { x: event.clientX, y: event.clientY },\n          page: window.location.pathname\n        }\n      });\n    };\n\n    // Keyboard activity tracking\n    const handleKeyPress = (event: KeyboardEvent) => {\n      this.updateLastActivity();\n      this.recordActivity(this.currentStaffId!, {\n        type: 'active',\n        details: {\n          action: 'key_press',\n          element: (event.target as HTMLElement)?.tagName || 'unknown',\n          page: window.location.pathname\n        }\n      });\n    };\n\n    // Click tracking\n    const handleClick = (event: MouseEvent) => {\n      this.updateLastActivity();\n      const target = event.target as HTMLElement;\n      this.recordActivity(this.currentStaffId!, {\n        type: 'action',\n        details: {\n          action: 'click',\n          element: target.tagName,\n          coordinates: { x: event.clientX, y: event.clientY },\n          page: window.location.pathname\n        }\n      });\n    };\n\n    // Page navigation tracking\n    const handlePageChange = () => {\n      this.recordActivity(this.currentStaffId!, {\n        type: 'page_view',\n        details: {\n          page: window.location.pathname,\n          url: window.location.href\n        }\n      });\n    };\n\n    // Scroll tracking\n    const handleScroll = () => {\n      this.updateLastActivity();\n      this.recordActivity(this.currentStaffId!, {\n        type: 'active',\n        details: {\n          action: 'scroll',\n          page: window.location.pathname\n        }\n      });\n    };\n\n    // Add event listeners\n    document.addEventListener('mousemove', handleMouseMove, { passive: true });\n    document.addEventListener('keypress', handleKeyPress, { passive: true });\n    document.addEventListener('click', handleClick, { passive: true });\n    document.addEventListener('scroll', handleScroll, { passive: true });\n    window.addEventListener('popstate', handlePageChange);\n\n    // Store listeners for cleanup\n    this.listeners = [\n      () => document.removeEventListener('mousemove', handleMouseMove),\n      () => document.removeEventListener('keypress', handleKeyPress),\n      () => document.removeEventListener('click', handleClick),\n      () => document.removeEventListener('scroll', handleScroll),\n      () => window.removeEventListener('popstate', handlePageChange)\n    ];\n\n    // Track initial page view\n    handlePageChange();\n  }\n\n  private removeActivityListeners(): void {\n    this.listeners.forEach(removeListener => removeListener());\n    this.listeners = [];\n  }\n\n  private updateLastActivity(): void {\n    this.lastActivity = new Date();\n    \n    // Reset idle timer\n    if (this.idleTimer) {\n      clearTimeout(this.idleTimer);\n    }\n    this.startIdleMonitoring();\n  }\n\n  private startIdleMonitoring(): void {\n    this.idleTimer = setTimeout(() => {\n      if (this.isTracking && this.currentStaffId) {\n        this.recordActivity(this.currentStaffId, {\n          type: 'idle',\n          details: {\n            duration: this.idleThreshold,\n            page: window.location.pathname\n          }\n        });\n      }\n    }, this.idleThreshold);\n  }\n\n  private stopIdleMonitoring(): void {\n    if (this.idleTimer) {\n      clearTimeout(this.idleTimer);\n      this.idleTimer = null;\n    }\n  }\n\n  recordActivity(staffId: string, activity: Partial<ActivityEvent>): void {\n    if (!this.isTracking && activity.type !== 'login' && activity.type !== 'logout') {\n      return;\n    }\n\n    const activityEvent: ActivityEvent = {\n      id: `activity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      staffId,\n      timestamp: new Date().toISOString(),\n      type: activity.type || 'action',\n      details: activity.details || {}\n    };\n\n    this.activities.push(activityEvent);\n    this.saveActivities();\n\n    // Limit stored activities to prevent memory issues\n    if (this.activities.length > 10000) {\n      this.activities = this.activities.slice(-5000);\n      this.saveActivities();\n    }\n  }\n\n  recordBreak(staffId: string, duration: number): void {\n    this.recordActivity(staffId, {\n      type: 'break',\n      details: {\n        duration,\n        page: window.location.pathname\n      }\n    });\n  }\n\n  getActivities(staffId: string, dateRange?: [Date, Date]): ActivityEvent[] {\n    let filtered = this.activities.filter(activity => activity.staffId === staffId);\n\n    if (dateRange) {\n      const [start, end] = dateRange;\n      filtered = filtered.filter(activity => {\n        const activityDate = new Date(activity.timestamp);\n        return activityDate >= start && activityDate <= end;\n      });\n    }\n\n    return filtered.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n  }\n\n  generateProductivityReport(staffId: string, dateRange: [Date, Date]): ProductivityMetrics {\n    const activities = this.getActivities(staffId, dateRange);\n    \n    if (activities.length === 0) {\n      return {\n        totalActiveTime: 0,\n        totalIdleTime: 0,\n        pageViews: 0,\n        actionsPerformed: 0,\n        averageSessionDuration: 0,\n        productivityScore: 0,\n        breakTime: 0,\n        focusTime: 0,\n        mostVisitedPages: [],\n        hourlyActivity: Array.from({ length: 24 }, (_, i) => ({ hour: i, activity: 0 }))\n      };\n    }\n\n    // Calculate metrics\n    const activeActivities = activities.filter(a => a.type === 'active' || a.type === 'action');\n    const idleActivities = activities.filter(a => a.type === 'idle');\n    const pageViews = activities.filter(a => a.type === 'page_view');\n    const breakActivities = activities.filter(a => a.type === 'break');\n\n    const totalActiveTime = activeActivities.length * 1000; // Approximate active time\n    const totalIdleTime = idleActivities.reduce((sum, activity) => \n      sum + (activity.details.duration || 0), 0);\n    const breakTime = breakActivities.reduce((sum, activity) => \n      sum + (activity.details.duration || 0), 0);\n\n    // Calculate page visit statistics\n    const pageStats = new Map<string, { count: number; duration: number }>();\n    pageViews.forEach(activity => {\n      const page = activity.details.page || 'unknown';\n      const current = pageStats.get(page) || { count: 0, duration: 0 };\n      pageStats.set(page, {\n        count: current.count + 1,\n        duration: current.duration + 60000 // Approximate 1 minute per page view\n      });\n    });\n\n    const mostVisitedPages = Array.from(pageStats.entries())\n      .map(([page, stats]) => ({ page, ...stats }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    // Calculate hourly activity\n    const hourlyActivity = Array.from({ length: 24 }, (_, hour) => {\n      const hourActivities = activities.filter(activity => {\n        const activityHour = new Date(activity.timestamp).getHours();\n        return activityHour === hour;\n      });\n      return { hour, activity: hourActivities.length };\n    });\n\n    // Calculate productivity score (0-100)\n    const totalTime = totalActiveTime + totalIdleTime;\n    const productivityScore = totalTime > 0 \n      ? Math.round((totalActiveTime / totalTime) * 100) \n      : 0;\n\n    // Calculate focus time (active time without breaks)\n    const focusTime = Math.max(0, totalActiveTime - breakTime);\n\n    // Calculate average session duration\n    const sessions = this.groupActivitiesBySessions(activities);\n    const averageSessionDuration = sessions.length > 0\n      ? sessions.reduce((sum, session) => sum + session.duration, 0) / sessions.length\n      : 0;\n\n    return {\n      totalActiveTime,\n      totalIdleTime,\n      pageViews: pageViews.length,\n      actionsPerformed: activeActivities.length,\n      averageSessionDuration,\n      productivityScore,\n      breakTime,\n      focusTime,\n      mostVisitedPages,\n      hourlyActivity\n    };\n  }\n\n  private groupActivitiesBySessions(activities: ActivityEvent[]): Array<{ start: Date; end: Date; duration: number }> {\n    const sessions: Array<{ start: Date; end: Date; duration: number }> = [];\n    let currentSession: { start: Date; end: Date } | null = null;\n\n    activities.forEach(activity => {\n      const activityTime = new Date(activity.timestamp);\n\n      if (activity.type === 'login' || !currentSession) {\n        currentSession = { start: activityTime, end: activityTime };\n      } else if (activity.type === 'logout') {\n        if (currentSession) {\n          sessions.push({\n            ...currentSession,\n            end: activityTime,\n            duration: activityTime.getTime() - currentSession.start.getTime()\n          });\n          currentSession = null;\n        }\n      } else {\n        if (currentSession) {\n          currentSession.end = activityTime;\n        }\n      }\n    });\n\n    // Handle unclosed sessions\n    if (currentSession) {\n      sessions.push({\n        ...currentSession,\n        duration: currentSession.end.getTime() - currentSession.start.getTime()\n      });\n    }\n\n    return sessions;\n  }\n\n  getDailyProductivityTrend(staffId: string, days: number = 30): Array<{ date: string; score: number }> {\n    const endDate = new Date();\n    const startDate = new Date();\n    startDate.setDate(endDate.getDate() - days);\n\n    const trend: Array<{ date: string; score: number }> = [];\n\n    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {\n      const dayStart = new Date(d);\n      dayStart.setHours(0, 0, 0, 0);\n      const dayEnd = new Date(d);\n      dayEnd.setHours(23, 59, 59, 999);\n\n      const dayMetrics = this.generateProductivityReport(staffId, [dayStart, dayEnd]);\n      trend.push({\n        date: d.toISOString().split('T')[0],\n        score: dayMetrics.productivityScore\n      });\n    }\n\n    return trend;\n  }\n\n  clearActivityData(staffId?: string): void {\n    if (staffId) {\n      this.activities = this.activities.filter(activity => activity.staffId !== staffId);\n    } else {\n      this.activities = [];\n    }\n    this.saveActivities();\n  }\n\n  exportActivityData(staffId: string, dateRange?: [Date, Date]): string {\n    const activities = this.getActivities(staffId, dateRange);\n    return JSON.stringify(activities, null, 2);\n  }\n\n  isCurrentlyTracking(): boolean {\n    return this.isTracking;\n  }\n\n  getCurrentStaffId(): string | null {\n    return this.currentStaffId;\n  }\n}\n\n// Singleton instance\nexport const activityTracker = new ActivityTrackingService();","import jsPDF from 'jspdf';\nimport html2canvas from 'html2canvas';\nimport { format } from 'date-fns';\n\nexport interface PDFTemplate {\n  id: string;\n  name: string;\n  type: 'report' | 'invoice' | 'proposal' | 'activity' | 'custom';\n  layout: 'portrait' | 'landscape';\n  sections: PDFSection[];\n  styles: PDFStyles;\n  metadata: {\n    author?: string;\n    title?: string;\n    subject?: string;\n    keywords?: string[];\n  };\n}\n\nexport interface PDFSection {\n  id: string;\n  type: 'header' | 'footer' | 'content' | 'chart' | 'table' | 'image' | 'text';\n  position: { x: number; y: number; width: number; height: number };\n  content: any;\n  styles?: Partial<PDFStyles>;\n}\n\nexport interface PDFStyles {\n  fontSize: number;\n  fontFamily: string;\n  textColor: string;\n  backgroundColor: string;\n  borderColor: string;\n  borderWidth: number;\n  padding: number;\n  margin: number;\n  alignment: 'left' | 'center' | 'right' | 'justify';\n}\n\nexport interface ChartConfig {\n  type: 'line' | 'bar' | 'pie' | 'area';\n  data: any[];\n  options: {\n    title?: string;\n    xAxis?: string;\n    yAxis?: string;\n    colors?: string[];\n    showLegend?: boolean;\n    showGrid?: boolean;\n  };\n}\n\nexport interface ExportOptions {\n  format: 'pdf' | 'png' | 'jpeg' | 'svg';\n  quality?: number;\n  compression?: boolean;\n  password?: string;\n  watermark?: {\n    text: string;\n    opacity: number;\n    position: 'center' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  };\n}\n\nexport class UniversalPDFService {\n  private templates: Map<string, PDFTemplate> = new Map();\n  private defaultStyles: PDFStyles = {\n    fontSize: 12,\n    fontFamily: 'helvetica',\n    textColor: '#000000',\n    backgroundColor: '#ffffff',\n    borderColor: '#cccccc',\n    borderWidth: 1,\n    padding: 10,\n    margin: 10,\n    alignment: 'left'\n  };\n\n  constructor() {\n    this.initializeDefaultTemplates();\n  }\n\n  private initializeDefaultTemplates(): void {\n    // Activity Report Template\n    const activityTemplate: PDFTemplate = {\n      id: 'activity-report',\n      name: 'Activity Report',\n      type: 'activity',\n      layout: 'portrait',\n      sections: [\n        {\n          id: 'header',\n          type: 'header',\n          position: { x: 0, y: 0, width: 100, height: 15 },\n          content: {\n            title: 'Employee Activity Report',\n            logo: null,\n            date: true\n          }\n        },\n        {\n          id: 'summary',\n          type: 'content',\n          position: { x: 0, y: 20, width: 100, height: 30 },\n          content: {\n            type: 'summary',\n            fields: ['totalActiveTime', 'productivityScore', 'pageViews', 'breakTime']\n          }\n        },\n        {\n          id: 'chart',\n          type: 'chart',\n          position: { x: 0, y: 55, width: 100, height: 35 },\n          content: {\n            type: 'productivity-trend'\n          }\n        }\n      ],\n      styles: this.defaultStyles,\n      metadata: {\n        title: 'Employee Activity Report',\n        subject: 'Productivity and Activity Analysis'\n      }\n    };\n\n    // Proposal Template\n    const proposalTemplate: PDFTemplate = {\n      id: 'business-proposal',\n      name: 'Business Proposal',\n      type: 'proposal',\n      layout: 'portrait',\n      sections: [\n        {\n          id: 'cover',\n          type: 'header',\n          position: { x: 0, y: 0, width: 100, height: 25 },\n          content: {\n            title: 'Business Proposal',\n            subtitle: 'Professional Services',\n            logo: null\n          }\n        },\n        {\n          id: 'executive-summary',\n          type: 'content',\n          position: { x: 0, y: 30, width: 100, height: 20 },\n          content: {\n            type: 'text',\n            title: 'Executive Summary'\n          }\n        },\n        {\n          id: 'services',\n          type: 'table',\n          position: { x: 0, y: 55, width: 100, height: 30 },\n          content: {\n            type: 'services-table'\n          }\n        }\n      ],\n      styles: this.defaultStyles,\n      metadata: {\n        title: 'Business Proposal',\n        subject: 'Service Proposal Document'\n      }\n    };\n\n    this.templates.set(activityTemplate.id, activityTemplate);\n    this.templates.set(proposalTemplate.id, proposalTemplate);\n  }\n\n  async generatePDF(templateId: string, data: any, options: ExportOptions = { format: 'pdf' }): Promise<Blob> {\n    const template = this.templates.get(templateId);\n    if (!template) {\n      throw new Error(`Template ${templateId} not found`);\n    }\n\n    const pdf = new jsPDF({\n      orientation: template.layout === 'landscape' ? 'l' : 'p',\n      unit: 'mm',\n      format: 'a4'\n    });\n\n    // Set metadata\n    if (template.metadata.title) pdf.setProperties({ title: template.metadata.title });\n    if (template.metadata.author) pdf.setProperties({ author: template.metadata.author });\n    if (template.metadata.subject) pdf.setProperties({ subject: template.metadata.subject });\n\n    // Process sections\n    for (const section of template.sections) {\n      await this.renderSection(pdf, section, data, template);\n    }\n\n    // Add watermark if specified\n    if (options.watermark) {\n      this.addWatermark(pdf, options.watermark);\n    }\n\n    // Return based on format\n    switch (options.format) {\n      case 'pdf':\n        return new Blob([pdf.output('blob')], { type: 'application/pdf' });\n      case 'png':\n      case 'jpeg':\n        return await this.convertToImage(pdf, options.format, options.quality);\n      default:\n        return new Blob([pdf.output('blob')], { type: 'application/pdf' });\n    }\n  }\n\n  private async renderSection(pdf: jsPDF, section: PDFSection, data: any, template: PDFTemplate): Promise<void> {\n    const pageWidth = pdf.internal.pageSize.getWidth();\n    const pageHeight = pdf.internal.pageSize.getHeight();\n    \n    const x = (section.position.x / 100) * pageWidth;\n    const y = (section.position.y / 100) * pageHeight;\n    const width = (section.position.width / 100) * pageWidth;\n    const height = (section.position.height / 100) * pageHeight;\n\n    const styles = { ...template.styles, ...section.styles };\n\n    switch (section.type) {\n      case 'header':\n        await this.renderHeader(pdf, section.content, x, y, width, height, styles);\n        break;\n      case 'content':\n        await this.renderContent(pdf, section.content, data, x, y, width, height, styles);\n        break;\n      case 'chart':\n        await this.renderChart(pdf, section.content, data, x, y, width, height);\n        break;\n      case 'table':\n        await this.renderTable(pdf, section.content, data, x, y, width, height, styles);\n        break;\n      case 'text':\n        this.renderText(pdf, section.content, x, y, width, height, styles);\n        break;\n      case 'image':\n        await this.renderImage(pdf, section.content, x, y, width, height);\n        break;\n    }\n  }\n\n  private async renderHeader(pdf: jsPDF, content: any, x: number, y: number, width: number, height: number, styles: PDFStyles): Promise<void> {\n    pdf.setFontSize(20);\n    pdf.setFont(styles.fontFamily, 'bold');\n    \n    if (content.title) {\n      pdf.text(content.title, x + width / 2, y + 15, { align: 'center' });\n    }\n    \n    if (content.subtitle) {\n      pdf.setFontSize(14);\n      pdf.setFont(styles.fontFamily, 'normal');\n      pdf.text(content.subtitle, x + width / 2, y + 25, { align: 'center' });\n    }\n    \n    if (content.date) {\n      pdf.setFontSize(10);\n      pdf.text(`Generated: ${format(new Date(), 'PPP')}`, x + width - 5, y + 10, { align: 'right' });\n    }\n\n    // Add border\n    pdf.setDrawColor(styles.borderColor);\n    pdf.setLineWidth(styles.borderWidth);\n    pdf.rect(x, y, width, height);\n  }\n\n  private async renderContent(pdf: jsPDF, content: any, data: any, x: number, y: number, width: number, height: number, styles: PDFStyles): Promise<void> {\n    pdf.setFontSize(styles.fontSize);\n    pdf.setFont(styles.fontFamily);\n\n    if (content.type === 'summary' && data.metrics) {\n      const metrics = data.metrics;\n      let currentY = y + 10;\n\n      pdf.setFontSize(16);\n      pdf.setFont(styles.fontFamily, 'bold');\n      pdf.text('Productivity Summary', x + 10, currentY);\n      currentY += 15;\n\n      pdf.setFontSize(12);\n      pdf.setFont(styles.fontFamily, 'normal');\n\n      const summaryItems = [\n        { label: 'Productivity Score', value: `${metrics.productivityScore}%` },\n        { label: 'Total Active Time', value: this.formatDuration(metrics.totalActiveTime) },\n        { label: 'Page Views', value: metrics.pageViews.toString() },\n        { label: 'Break Time', value: this.formatDuration(metrics.breakTime) },\n        { label: 'Actions Performed', value: metrics.actionsPerformed.toString() }\n      ];\n\n      summaryItems.forEach(item => {\n        pdf.text(`${item.label}:`, x + 10, currentY);\n        pdf.text(item.value, x + width - 10, currentY, { align: 'right' });\n        currentY += 8;\n      });\n    }\n  }\n\n  private async renderChart(pdf: jsPDF, content: any, data: any, x: number, y: number, width: number, height: number): Promise<void> {\n    if (content.type === 'productivity-trend' && data.productivityTrend) {\n      // Create a simple chart representation\n      const chartData = data.productivityTrend.slice(-7); // Last 7 days\n      const maxScore = Math.max(...chartData.map((d: any) => d.score));\n      const chartWidth = width - 20;\n      const chartHeight = height - 30;\n\n      // Draw chart background\n      pdf.setFillColor(245, 245, 245);\n      pdf.rect(x + 10, y + 20, chartWidth, chartHeight, 'F');\n\n      // Draw chart title\n      pdf.setFontSize(14);\n      pdf.setFont('helvetica', 'bold');\n      pdf.text('7-Day Productivity Trend', x + width / 2, y + 15, { align: 'center' });\n\n      // Draw chart lines\n      pdf.setDrawColor(59, 130, 246);\n      pdf.setLineWidth(2);\n\n      for (let i = 0; i < chartData.length - 1; i++) {\n        const x1 = x + 10 + (i / (chartData.length - 1)) * chartWidth;\n        const y1 = y + 20 + chartHeight - (chartData[i].score / 100) * chartHeight;\n        const x2 = x + 10 + ((i + 1) / (chartData.length - 1)) * chartWidth;\n        const y2 = y + 20 + chartHeight - (chartData[i + 1].score / 100) * chartHeight;\n        \n        pdf.line(x1, y1, x2, y2);\n      }\n\n      // Draw data points\n      pdf.setFillColor(59, 130, 246);\n      chartData.forEach((point: any, index: number) => {\n        const pointX = x + 10 + (index / (chartData.length - 1)) * chartWidth;\n        const pointY = y + 20 + chartHeight - (point.score / 100) * chartHeight;\n        pdf.circle(pointX, pointY, 2, 'F');\n      });\n    }\n  }\n\n  private async renderTable(pdf: jsPDF, content: any, data: any, x: number, y: number, width: number, height: number, styles: PDFStyles): Promise<void> {\n    if (content.type === 'services-table' && data.services) {\n      const services = data.services;\n      const rowHeight = 8;\n      const colWidths = [width * 0.5, width * 0.25, width * 0.25];\n      let currentY = y + 10;\n\n      // Table header\n      pdf.setFontSize(12);\n      pdf.setFont(styles.fontFamily, 'bold');\n      pdf.setFillColor(240, 240, 240);\n      pdf.rect(x, currentY, width, rowHeight, 'F');\n      \n      pdf.text('Service', x + 5, currentY + 5);\n      pdf.text('Quantity', x + colWidths[0] + 5, currentY + 5);\n      pdf.text('Price', x + colWidths[0] + colWidths[1] + 5, currentY + 5);\n      currentY += rowHeight;\n\n      // Table rows\n      pdf.setFont(styles.fontFamily, 'normal');\n      services.forEach((service: any) => {\n        pdf.text(service.name, x + 5, currentY + 5);\n        pdf.text(service.quantity.toString(), x + colWidths[0] + 5, currentY + 5);\n        pdf.text(`$${service.price}`, x + colWidths[0] + colWidths[1] + 5, currentY + 5);\n        currentY += rowHeight;\n      });\n\n      // Table border\n      pdf.setDrawColor(styles.borderColor);\n      pdf.setLineWidth(styles.borderWidth);\n      pdf.rect(x, y + 10, width, currentY - y - 10);\n    }\n  }\n\n  private renderText(pdf: jsPDF, content: any, x: number, y: number, width: number, height: number, styles: PDFStyles): void {\n    pdf.setFontSize(styles.fontSize);\n    pdf.setFont(styles.fontFamily);\n    \n    if (content.title) {\n      pdf.setFont(styles.fontFamily, 'bold');\n      pdf.text(content.title, x + 10, y + 15);\n    }\n    \n    if (content.text) {\n      pdf.setFont(styles.fontFamily, 'normal');\n      const lines = pdf.splitTextToSize(content.text, width - 20);\n      pdf.text(lines, x + 10, y + (content.title ? 25 : 15));\n    }\n  }\n\n  private async renderImage(pdf: jsPDF, content: any, x: number, y: number, width: number, height: number): Promise<void> {\n    if (content.src) {\n      try {\n        pdf.addImage(content.src, 'JPEG', x, y, width, height);\n      } catch (error) {\n        console.error('Error adding image to PDF:', error);\n      }\n    }\n  }\n\n  private addWatermark(pdf: jsPDF, watermark: { text: string; opacity: number; position: string }): void {\n    const pageWidth = pdf.internal.pageSize.getWidth();\n    const pageHeight = pdf.internal.pageSize.getHeight();\n    \n    pdf.setGState(new pdf.GState({ opacity: watermark.opacity }));\n    pdf.setFontSize(50);\n    pdf.setTextColor(200, 200, 200);\n    \n    let x = pageWidth / 2;\n    let y = pageHeight / 2;\n    \n    switch (watermark.position) {\n      case 'top-left':\n        x = 50; y = 50;\n        break;\n      case 'top-right':\n        x = pageWidth - 50; y = 50;\n        break;\n      case 'bottom-left':\n        x = 50; y = pageHeight - 50;\n        break;\n      case 'bottom-right':\n        x = pageWidth - 50; y = pageHeight - 50;\n        break;\n    }\n    \n    pdf.text(watermark.text, x, y, { \n      align: 'center',\n      angle: 45\n    });\n  }\n\n  private async convertToImage(pdf: jsPDF, format: 'png' | 'jpeg', quality: number = 0.8): Promise<Blob> {\n    const canvas = await html2canvas(document.createElement('div'));\n    \n    return new Promise((resolve) => {\n      canvas.toBlob((blob) => {\n        resolve(blob!);\n      }, `image/${format}`, quality);\n    });\n  }\n\n  private formatDuration(milliseconds: number): string {\n    const hours = Math.floor(milliseconds / (1000 * 60 * 60));\n    const minutes = Math.floor((milliseconds % (1000 * 60 * 60)) / (1000 * 60));\n    return `${hours}h ${minutes}m`;\n  }\n\n  // Template management methods\n  createTemplate(template: PDFTemplate): void {\n    this.templates.set(template.id, template);\n  }\n\n  updateTemplate(templateId: string, updates: Partial<PDFTemplate>): void {\n    const existing = this.templates.get(templateId);\n    if (existing) {\n      this.templates.set(templateId, { ...existing, ...updates });\n    }\n  }\n\n  deleteTemplate(templateId: string): void {\n    this.templates.delete(templateId);\n  }\n\n  getTemplate(templateId: string): PDFTemplate | undefined {\n    return this.templates.get(templateId);\n  }\n\n  getAllTemplates(): PDFTemplate[] {\n    return Array.from(this.templates.values());\n  }\n\n  // Batch processing\n  async generateBatchPDFs(requests: Array<{ templateId: string; data: any; filename: string }>): Promise<Blob[]> {\n    const results: Blob[] = [];\n    \n    for (const request of requests) {\n      try {\n        const pdf = await this.generatePDF(request.templateId, request.data);\n        results.push(pdf);\n      } catch (error) {\n        console.error(`Error generating PDF for ${request.filename}:`, error);\n        results.push(new Blob()); // Empty blob for failed generation\n      }\n    }\n    \n    return results;\n  }\n\n  // Advanced features\n  async generateActivityReport(staffId: string, metrics: any, activities: any[]): Promise<Blob> {\n    const data = {\n      staffId,\n      metrics,\n      activities,\n      productivityTrend: metrics.productivityTrend || []\n    };\n    \n    return this.generatePDF('activity-report', data);\n  }\n\n  async generateProposalPDF(proposalData: any): Promise<Blob> {\n    return this.generatePDF('business-proposal', proposalData);\n  }\n\n  // Export utilities\n  downloadPDF(blob: Blob, filename: string): void {\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n\n  async emailPDF(blob: Blob, emailData: { to: string; subject: string; body: string }): Promise<void> {\n    // This would integrate with your email service\n    console.log('Email PDF functionality would be implemented here', { blob, emailData });\n  }\n}\n\n// Singleton instance\nexport const universalPDFService = new UniversalPDFService();","import type { Tables } from '@/integrations/supabase/types';\nimport type { ValidationError, ValidationResult } from './transportRouteValidationService';\n\n// Error severity levels\nexport type ErrorSeverity = 'critical' | 'error' | 'warning' | 'info' | 'debug';\n\n// Error categories\nexport type ErrorCategory = \n  | 'validation' \n  | 'database' \n  | 'network' \n  | 'authentication' \n  | 'authorization' \n  | 'business_logic' \n  | 'data_integrity' \n  | 'synchronization'\n  | 'user_input';\n\n// Error context for better debugging\nexport interface ErrorContext {\n  userId?: string;\n  routeId?: string;\n  operation: string;\n  timestamp: Date;\n  userAgent?: string;\n  sessionId?: string;\n  additionalData?: Record<string, any>;\n}\n\n// Structured error log entry\nexport interface ErrorLogEntry {\n  id: string;\n  severity: ErrorSeverity;\n  category: ErrorCategory;\n  code: string;\n  message: string;\n  details?: any;\n  context: ErrorContext;\n  stackTrace?: string;\n  resolved: boolean;\n  resolvedAt?: Date;\n  resolvedBy?: string;\n  tags: string[];\n}\n\n// User feedback interface\nexport interface UserFeedback {\n  type: 'success' | 'error' | 'warning' | 'info';\n  title: string;\n  message: string;\n  details?: string;\n  actions?: Array<{\n    label: string;\n    action: () => void;\n    variant?: 'primary' | 'secondary' | 'destructive';\n  }>;\n  duration?: number; // Auto-dismiss duration in ms\n  persistent?: boolean; // Don't auto-dismiss\n}\n\n// Error statistics for monitoring\nexport interface ErrorStatistics {\n  totalErrors: number;\n  errorsByCategory: Record<ErrorCategory, number>;\n  errorsBySeverity: Record<ErrorSeverity, number>;\n  recentErrors: ErrorLogEntry[];\n  topErrors: Array<{ code: string; count: number; lastOccurred: Date }>;\n  errorRate: number; // Errors per hour\n  resolutionRate: number; // Percentage of resolved errors\n}\n\nexport class TransportRouteErrorService {\n  private static instance: TransportRouteErrorService;\n  private errorLog: ErrorLogEntry[] = [];\n  private errorCallbacks: Array<(error: ErrorLogEntry) => void> = [];\n  private feedbackCallbacks: Array<(feedback: UserFeedback) => void> = [];\n\n  static getInstance(): TransportRouteErrorService {\n    if (!TransportRouteErrorService.instance) {\n      TransportRouteErrorService.instance = new TransportRouteErrorService();\n    }\n    return TransportRouteErrorService.instance;\n  }\n\n  /**\n   * Log an error with full context\n   */\n  logError(\n    severity: ErrorSeverity,\n    category: ErrorCategory,\n    code: string,\n    message: string,\n    context: Partial<ErrorContext>,\n    details?: any,\n    error?: Error\n  ): string {\n    const errorId = this.generateErrorId();\n    \n    const logEntry: ErrorLogEntry = {\n      id: errorId,\n      severity,\n      category,\n      code,\n      message,\n      details,\n      context: {\n        operation: context.operation || 'unknown',\n        timestamp: new Date(),\n        ...context\n      },\n      stackTrace: error?.stack,\n      resolved: false,\n      tags: this.generateTags(category, code, severity)\n    };\n\n    this.errorLog.push(logEntry);\n    \n    // Trigger callbacks\n    this.errorCallbacks.forEach(callback => {\n      try {\n        callback(logEntry);\n      } catch (callbackError) {\n        console.error('Error in error callback:', callbackError);\n      }\n    });\n\n    // Console logging for development\n    if (process.env.NODE_ENV === 'development') {\n      const logMethod = this.getConsoleMethod(severity);\n      logMethod(`[${category.toUpperCase()}] ${code}: ${message}`, {\n        details,\n        context,\n        error\n      });\n    }\n\n    // Persist to localStorage for debugging\n    this.persistErrorLog();\n\n    return errorId;\n  }\n\n  /**\n   * Log validation errors\n   */\n  logValidationErrors(\n    validationResult: ValidationResult,\n    context: Partial<ErrorContext>\n  ): string[] {\n    const errorIds: string[] = [];\n\n    validationResult.errors.forEach(error => {\n      const errorId = this.logError(\n        'error',\n        'validation',\n        error.code,\n        error.message,\n        {\n          ...context,\n          operation: context.operation || 'validation'\n        },\n        {\n          field: error.field,\n          validationDetails: error.details\n        }\n      );\n      errorIds.push(errorId);\n    });\n\n    validationResult.warnings.forEach(warning => {\n      const errorId = this.logError(\n        'warning',\n        'validation',\n        warning.code,\n        warning.message,\n        {\n          ...context,\n          operation: context.operation || 'validation'\n        },\n        {\n          field: warning.field,\n          validationDetails: warning.details\n        }\n      );\n      errorIds.push(errorId);\n    });\n\n    return errorIds;\n  }\n\n  /**\n   * Log database operation errors\n   */\n  logDatabaseError(\n    operation: string,\n    error: Error,\n    context: Partial<ErrorContext>,\n    additionalDetails?: any\n  ): string {\n    return this.logError(\n      'error',\n      'database',\n      this.getDatabaseErrorCode(error),\n      `Database ${operation} failed: ${error.message}`,\n      {\n        ...context,\n        operation: `database_${operation}`\n      },\n      {\n        originalError: error.message,\n        ...additionalDetails\n      },\n      error\n    );\n  }\n\n  /**\n   * Log synchronization errors\n   */\n  logSynchronizationError(\n    syncType: string,\n    error: Error,\n    context: Partial<ErrorContext>,\n    failedData?: any\n  ): string {\n    return this.logError(\n      'error',\n      'synchronization',\n      'SYNC_FAILED',\n      `${syncType} synchronization failed: ${error.message}`,\n      {\n        ...context,\n        operation: `sync_${syncType}`\n      },\n      {\n        syncType,\n        failedData,\n        originalError: error.message\n      },\n      error\n    );\n  }\n\n  /**\n   * Show user feedback\n   */\n  showUserFeedback(feedback: UserFeedback): void {\n    this.feedbackCallbacks.forEach(callback => {\n      try {\n        callback(feedback);\n      } catch (error) {\n        console.error('Error in feedback callback:', error);\n      }\n    });\n  }\n\n  /**\n   * Show validation feedback to user\n   */\n  showValidationFeedback(\n    validationResult: ValidationResult,\n    routeName?: string\n  ): void {\n    if (validationResult.errors.length > 0) {\n      this.showUserFeedback({\n        type: 'error',\n        title: 'Validation Failed',\n        message: `${routeName ? `Route \"${routeName}\"` : 'Route'} has ${validationResult.errors.length} error(s) that must be fixed`,\n        details: validationResult.errors.map(e => ` ${e.message}`).join('\\n'),\n        persistent: true,\n        actions: [{\n          label: 'View Details',\n          action: () => this.showDetailedValidationErrors(validationResult.errors),\n          variant: 'secondary'\n        }]\n      });\n    } else if (validationResult.warnings.length > 0) {\n      this.showUserFeedback({\n        type: 'warning',\n        title: 'Validation Warnings',\n        message: `${routeName ? `Route \"${routeName}\"` : 'Route'} has ${validationResult.warnings.length} warning(s)`,\n        details: validationResult.warnings.map(w => ` ${w.message}`).join('\\n'),\n        duration: 8000,\n        actions: [{\n          label: 'Continue Anyway',\n          action: () => {},\n          variant: 'primary'\n        }, {\n          label: 'Review Warnings',\n          action: () => this.showDetailedValidationErrors(validationResult.warnings),\n          variant: 'secondary'\n        }]\n      });\n    } else {\n      this.showUserFeedback({\n        type: 'success',\n        title: 'Validation Passed',\n        message: `${routeName ? `Route \"${routeName}\"` : 'Route'} validation completed successfully`,\n        duration: 3000\n      });\n    }\n  }\n\n  /**\n   * Show database operation feedback\n   */\n  showDatabaseFeedback(\n    operation: string,\n    success: boolean,\n    routeName?: string,\n    error?: Error\n  ): void {\n    if (success) {\n      this.showUserFeedback({\n        type: 'success',\n        title: 'Operation Successful',\n        message: `${routeName ? `Route \"${routeName}\"` : 'Route'} ${operation} completed successfully`,\n        duration: 3000\n      });\n    } else {\n      this.showUserFeedback({\n        type: 'error',\n        title: 'Operation Failed',\n        message: `Failed to ${operation} ${routeName ? `route \"${routeName}\"` : 'route'}`,\n        details: error?.message || 'Unknown error occurred',\n        persistent: true,\n        actions: [{\n          label: 'Retry',\n          action: () => {}, // Will be overridden by caller\n          variant: 'primary'\n        }, {\n          label: 'View Error Details',\n          action: () => this.showErrorDetails(error),\n          variant: 'secondary'\n        }]\n      });\n    }\n  }\n\n  /**\n   * Show synchronization feedback\n   */\n  showSynchronizationFeedback(\n    syncType: string,\n    success: boolean,\n    syncedCount?: number,\n    failedCount?: number,\n    errors?: Error[]\n  ): void {\n    if (success) {\n      this.showUserFeedback({\n        type: 'success',\n        title: 'Synchronization Complete',\n        message: `${syncType} synchronization completed${syncedCount ? ` (${syncedCount} items)` : ''}`,\n        duration: 3000\n      });\n    } else {\n      this.showUserFeedback({\n        type: 'error',\n        title: 'Synchronization Failed',\n        message: `${syncType} synchronization failed${failedCount ? ` (${failedCount} items failed)` : ''}`,\n        details: errors?.map(e => ` ${e.message}`).join('\\n'),\n        persistent: true,\n        actions: [{\n          label: 'Retry Sync',\n          action: () => {}, // Will be overridden by caller\n          variant: 'primary'\n        }, {\n          label: 'View Error Log',\n          action: () => this.showRecentErrors(),\n          variant: 'secondary'\n        }]\n      });\n    }\n  }\n\n  /**\n   * Register error callback\n   */\n  onError(callback: (error: ErrorLogEntry) => void): () => void {\n    this.errorCallbacks.push(callback);\n    return () => {\n      const index = this.errorCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.errorCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Register feedback callback\n   */\n  onFeedback(callback: (feedback: UserFeedback) => void): () => void {\n    this.feedbackCallbacks.push(callback);\n    return () => {\n      const index = this.feedbackCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.feedbackCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Get error statistics\n   */\n  getErrorStatistics(timeRange?: { start: Date; end: Date }): ErrorStatistics {\n    let filteredErrors = this.errorLog;\n    \n    if (timeRange) {\n      filteredErrors = this.errorLog.filter(error => \n        error.context.timestamp >= timeRange.start && \n        error.context.timestamp <= timeRange.end\n      );\n    }\n\n    const errorsByCategory = {} as Record<ErrorCategory, number>;\n    const errorsBySeverity = {} as Record<ErrorSeverity, number>;\n    const errorCounts = new Map<string, number>();\n\n    filteredErrors.forEach(error => {\n      errorsByCategory[error.category] = (errorsByCategory[error.category] || 0) + 1;\n      errorsBySeverity[error.severity] = (errorsBySeverity[error.severity] || 0) + 1;\n      errorCounts.set(error.code, (errorCounts.get(error.code) || 0) + 1);\n    });\n\n    const topErrors = Array.from(errorCounts.entries())\n      .map(([code, count]) => ({\n        code,\n        count,\n        lastOccurred: filteredErrors\n          .filter(e => e.code === code)\n          .sort((a, b) => b.context.timestamp.getTime() - a.context.timestamp.getTime())[0]\n          ?.context.timestamp || new Date()\n      }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    const recentErrors = filteredErrors\n      .sort((a, b) => b.context.timestamp.getTime() - a.context.timestamp.getTime())\n      .slice(0, 20);\n\n    const resolvedErrors = filteredErrors.filter(e => e.resolved).length;\n    const resolutionRate = filteredErrors.length > 0 ? (resolvedErrors / filteredErrors.length) * 100 : 100;\n\n    // Calculate error rate (errors per hour)\n    const timeSpan = timeRange \n      ? timeRange.end.getTime() - timeRange.start.getTime()\n      : 24 * 60 * 60 * 1000; // Default to 24 hours\n    const hours = timeSpan / (1000 * 60 * 60);\n    const errorRate = filteredErrors.length / hours;\n\n    return {\n      totalErrors: filteredErrors.length,\n      errorsByCategory,\n      errorsBySeverity,\n      recentErrors,\n      topErrors,\n      errorRate,\n      resolutionRate\n    };\n  }\n\n  /**\n   * Mark error as resolved\n   */\n  resolveError(errorId: string, resolvedBy?: string): boolean {\n    const error = this.errorLog.find(e => e.id === errorId);\n    if (error) {\n      error.resolved = true;\n      error.resolvedAt = new Date();\n      error.resolvedBy = resolvedBy;\n      this.persistErrorLog();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Clear old errors\n   */\n  clearOldErrors(olderThan: Date): number {\n    const initialCount = this.errorLog.length;\n    this.errorLog = this.errorLog.filter(error => \n      error.context.timestamp >= olderThan\n    );\n    this.persistErrorLog();\n    return initialCount - this.errorLog.length;\n  }\n\n  /**\n   * Export error log for analysis\n   */\n  exportErrorLog(format: 'json' | 'csv' = 'json'): string {\n    if (format === 'csv') {\n      const headers = ['ID', 'Timestamp', 'Severity', 'Category', 'Code', 'Message', 'Operation', 'Resolved'];\n      const rows = this.errorLog.map(error => [\n        error.id,\n        error.context.timestamp.toISOString(),\n        error.severity,\n        error.category,\n        error.code,\n        error.message,\n        error.context.operation,\n        error.resolved.toString()\n      ]);\n      \n      return [headers, ...rows].map(row => row.join(',')).join('\\n');\n    }\n    \n    return JSON.stringify(this.errorLog, null, 2);\n  }\n\n  // Private helper methods\n  private generateErrorId(): string {\n    return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateTags(category: ErrorCategory, code: string, severity: ErrorSeverity): string[] {\n    const tags = [category, severity];\n    \n    // Add specific tags based on error code\n    if (code.includes('VALIDATION')) tags.push('validation');\n    if (code.includes('DATABASE')) tags.push('database');\n    if (code.includes('NETWORK')) tags.push('network');\n    if (code.includes('SYNC')) tags.push('synchronization');\n    \n    return tags;\n  }\n\n  private getConsoleMethod(severity: ErrorSeverity): typeof console.log {\n    switch (severity) {\n      case 'critical':\n      case 'error':\n        return console.error;\n      case 'warning':\n        return console.warn;\n      case 'info':\n        return console.info;\n      case 'debug':\n        return console.debug;\n      default:\n        return console.log;\n    }\n  }\n\n  private getDatabaseErrorCode(error: Error): string {\n    const message = error.message.toLowerCase();\n    \n    if (message.includes('connection')) return 'DB_CONNECTION_ERROR';\n    if (message.includes('timeout')) return 'DB_TIMEOUT';\n    if (message.includes('constraint')) return 'DB_CONSTRAINT_VIOLATION';\n    if (message.includes('duplicate')) return 'DB_DUPLICATE_KEY';\n    if (message.includes('not found')) return 'DB_RECORD_NOT_FOUND';\n    if (message.includes('permission')) return 'DB_PERMISSION_DENIED';\n    \n    return 'DB_UNKNOWN_ERROR';\n  }\n\n  private persistErrorLog(): void {\n    try {\n      // Keep only last 1000 errors in localStorage\n      const recentErrors = this.errorLog.slice(-1000);\n      localStorage.setItem('transport_route_errors', JSON.stringify(recentErrors));\n    } catch (error) {\n      console.warn('Failed to persist error log:', error);\n    }\n  }\n\n  private showDetailedValidationErrors(errors: ValidationError[]): void {\n    const details = errors.map(error => \n      `Field: ${error.field}\\nCode: ${error.code}\\nMessage: ${error.message}${\n        error.details ? `\\nDetails: ${JSON.stringify(error.details, null, 2)}` : ''\n      }`\n    ).join('\\n\\n');\n\n    this.showUserFeedback({\n      type: 'info',\n      title: 'Validation Error Details',\n      message: `Found ${errors.length} validation issue(s):`,\n      details,\n      persistent: true\n    });\n  }\n\n  private showErrorDetails(error?: Error): void {\n    if (!error) return;\n\n    this.showUserFeedback({\n      type: 'info',\n      title: 'Error Details',\n      message: error.message,\n      details: error.stack,\n      persistent: true\n    });\n  }\n\n  private showRecentErrors(): void {\n    const recentErrors = this.errorLog\n      .slice(-10)\n      .reverse()\n      .map(error => `${error.context.timestamp.toLocaleString()}: ${error.message}`)\n      .join('\\n');\n\n    this.showUserFeedback({\n      type: 'info',\n      title: 'Recent Errors',\n      message: 'Last 10 errors:',\n      details: recentErrors,\n      persistent: true\n    });\n  }\n}\n\n// Export singleton instance\nexport const transportRouteErrorService = TransportRouteErrorService.getInstance();","import { Agent } from '@/types/agent';\n\nexport class AgentApiService {\n  private static baseUrl = '/api/agents';\n\n  static async fetchAgents(): Promise<Agent[]> {\n    try {\n      // For now, simulate API call since we don't have a real backend\n      // In a real implementation, this would be:\n      // const response = await fetch(this.baseUrl);\n      // return response.json();\n      \n      console.log('Fetching agents from API...');\n      \n      // Simulate API response with delay\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Return mock data that would come from the API\n      return [\n        {\n          id: 1001,\n          name: \"API Agent One\",\n          email: \"api.agent1@example.com\",\n          country: \"Thailand\",\n          city: \"Bangkok\",\n          type: \"company\",\n          status: \"active\",\n          commissionType: \"percentage\",\n          commissionValue: \"10%\",\n          contact: {\n            email: \"api.agent1@example.com\",\n            phone: \"+66-1234-5678\",\n            website: \"https://apiacent1.com\"\n          },\n          joinDate: \"2024-01-15\",\n          createdAt: \"2024-01-15T08:00:00Z\",\n          stats: {\n            totalQueries: 45,\n            totalBookings: 32,\n            conversionRate: 18,\n            revenueGenerated: 125000,\n            averageBookingValue: 3900,\n            activeCustomers: 28\n          },\n          recentActivity: []\n        },\n        {\n          id: 1002,\n          name: \"API Agent Two\",\n          email: \"api.agent2@example.com\",\n          country: \"India\",\n          city: \"Mumbai\",\n          type: \"individual\",\n          status: \"active\",\n          commissionType: \"flat\",\n          commissionValue: \"500\",\n          contact: {\n            email: \"api.agent2@example.com\",\n            phone: \"+91-9876-543210\"\n          },\n          joinDate: \"2024-02-20\",\n          createdAt: \"2024-02-20T10:30:00Z\",\n          stats: {\n            totalQueries: 38,\n            totalBookings: 25,\n            conversionRate: 22,\n            revenueGenerated: 98000,\n            averageBookingValue: 3920,\n            activeCustomers: 22\n          },\n          recentActivity: []\n        }\n      ];\n    } catch (error) {\n      console.error('Failed to fetch agents from API:', error);\n      return [];\n    }\n  }\n\n  static async fetchAgentById(id: number): Promise<Agent | null> {\n    try {\n      const agents = await this.fetchAgents();\n      return agents.find(agent => agent.id === id) || null;\n    } catch (error) {\n      console.error('Failed to fetch agent by ID:', error);\n      return null;\n    }\n  }\n\n  static async searchAgents(query: string): Promise<Agent[]> {\n    try {\n      const agents = await this.fetchAgents();\n      const searchTerm = query.toLowerCase();\n      \n      return agents.filter(agent => \n        agent.name.toLowerCase().includes(searchTerm) ||\n        agent.email.toLowerCase().includes(searchTerm) ||\n        agent.city.toLowerCase().includes(searchTerm) ||\n        agent.country.toLowerCase().includes(searchTerm)\n      );\n    } catch (error) {\n      console.error('Failed to search agents:', error);\n      return [];\n    }\n  }\n}"],"file":"app-services-DsmZ_6Od.js"}