{"version":3,"sources":["../src/server.ts","../package.json","../src/util.ts"],"names":["version","ensureTrailingSlash","url"],"mappings":"AAAA,ipBAAuB,6DAMhB,kDACgC,0BACrB,qDACc,ICP9BA,CAAAA,CAAW,OAAA,CCCN,SAASC,CAAAA,CAAoBC,CAAAA,CAAa,CAC/C,OAAOA,CAAAA,CAAI,QAAA,CAAS,GAAG,CAAA,CAAIA,CAAAA,CAAM,CAAA,EAAA","file":"/Users/grichardson/Documents/dev/supabase/mcp-server-supabase/packages/mcp-server-postgrest/dist/chunk-NOXTM46O.cjs","sourcesContent":["import { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport {\n  CallToolRequestSchema,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  ReadResourceRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { processSql, renderHttp } from '@supabase/sql-to-rest';\nimport { z } from 'zod';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport { version } from '../package.json';\nimport { ensureNoTrailingSlash, ensureTrailingSlash } from './util.js';\n\nexport type PostgrestMcpServerOptions = {\n  apiUrl: string;\n  apiKey?: string;\n  schema: string;\n};\n\nexport default class PostgrestMcpServer extends Server {\n  readonly #apiUrl: string;\n  readonly #apiKey?: string;\n  readonly #schema: string;\n  readonly #tools = {\n    postgrestRequest: {\n      description: 'Performs HTTP request against the PostgREST API',\n      parameters: z.object({\n        method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']),\n        path: z.string(),\n        body: z.record(z.unknown()).optional(),\n      }),\n      execute: async <Body>({\n        method,\n        path,\n        body,\n      }: {\n        method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n        path: string;\n        body?: Body;\n      }) => {\n        const url = new URL(`${this.#apiUrl}${path}`);\n\n        const response = await fetch(url, {\n          method,\n          headers: this.#getHeaders(method),\n          body: body ? JSON.stringify(body) : undefined,\n        });\n\n        return await response.json();\n      },\n    },\n    sqlToRest: {\n      description:\n        'Converts SQL query to a PostgREST API request (method, path)',\n      parameters: z.object({\n        sql: z.string(),\n      }),\n      execute: async ({ sql }: { sql: string }) => {\n        const statement = await processSql(sql);\n        const request = await renderHttp(statement);\n\n        return {\n          method: request.method,\n          path: request.fullPath,\n        };\n      },\n    },\n  };\n\n  constructor(options: PostgrestMcpServerOptions) {\n    super(\n      {\n        name: 'supabase/postgrest',\n        version,\n      },\n      {\n        capabilities: {\n          resources: {},\n          tools: {},\n        },\n      }\n    );\n\n    this.#apiUrl = ensureNoTrailingSlash(options.apiUrl);\n    this.#apiKey = options.apiKey;\n    this.#schema = options.schema;\n\n    this.setRequestHandler(ListResourcesRequestSchema, async () => {\n      const openApiSpec = await this.#fetchOpenApiSpec();\n\n      const resources = Object.keys(openApiSpec.paths)\n        .filter((path) => path !== '/')\n        .map((path) => {\n          const name = path.split('/').pop();\n          const pathValue = openApiSpec.paths[path];\n          const description = pathValue.get?.summary;\n\n          return {\n            uri: new URL(`${path}/spec`, `postgrest://${this.#schema}`).href,\n            name: `\"${name}\" OpenAPI path spec`,\n            description,\n            mimeType: 'application/json',\n          };\n        });\n\n      return {\n        resources,\n      };\n    });\n\n    this.setRequestHandler(ReadResourceRequestSchema, async (request) => {\n      const openApiSpec = await this.#fetchOpenApiSpec();\n\n      const resourceUrl = new URL(request.params.uri);\n\n      const pathComponents = resourceUrl.pathname.split('/');\n      const specLiteral = pathComponents.pop();\n      const pathName = pathComponents.pop();\n\n      if (specLiteral !== 'spec') {\n        throw new Error('invalid resource uri');\n      }\n\n      const pathSpec = openApiSpec.paths[`/${pathName}`];\n\n      if (!pathSpec) {\n        throw new Error('path not found');\n      }\n\n      return {\n        contents: [\n          {\n            uri: request.params.uri,\n            mimeType: 'application/json',\n            text: JSON.stringify(pathSpec),\n          },\n        ],\n      };\n    });\n\n    this.setRequestHandler(ListToolsRequestSchema, async () => {\n      const tools = Object.entries(this.#tools).map(\n        ([name, { description, parameters }]) => {\n          return {\n            name,\n            description,\n            inputSchema: zodToJsonSchema(parameters),\n          };\n        }\n      );\n\n      return {\n        tools,\n      };\n    });\n\n    this.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const tools = this.#tools;\n      const toolName = request.params.name as keyof typeof tools;\n\n      if (!(toolName in this.#tools)) {\n        throw new Error('tool not found');\n      }\n\n      const tool = this.#tools[toolName];\n      const args = tool.parameters.parse(request.params.arguments);\n\n      if (!args) {\n        throw new Error('missing arguments');\n      }\n\n      const result = await tool.execute(args as any);\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(result),\n          },\n        ],\n      };\n    });\n  }\n\n  async #fetchOpenApiSpec() {\n    const response = await fetch(ensureTrailingSlash(this.#apiUrl), {\n      headers: this.#getHeaders(),\n    });\n\n    return (await response.json()) as any;\n  }\n\n  #getHeaders(method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' = 'GET') {\n    const schemaHeader =\n      method === 'GET' ? 'accept-profile' : 'content-profile';\n\n    const headers: HeadersInit = {\n      'content-type': 'application/json',\n      prefer: 'return=representation',\n      [schemaHeader]: this.#schema,\n    };\n\n    if (this.#apiKey) {\n      headers.apikey = this.#apiKey;\n      headers.authorization = `Bearer ${this.#apiKey}`;\n    }\n\n    return headers;\n  }\n}\n","{\n  \"name\": \"@supabase/mcp-server-postgrest\",\n  \"version\": \"0.1.0\",\n  \"description\": \"MCP server for PostgREST\",\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.cjs\",\n  \"types\": \"dist/index.d.ts\",\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"build\": \"tsup --clean\",\n    \"prepublishOnly\": \"npm run build\",\n    \"test\": \"vitest\"\n  },\n  \"files\": [\n    \"dist/**/*\"\n  ],\n  \"bin\": {\n    \"mcp-server-postgrest\": \"./dist/stdio.js\"\n  },\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\",\n      \"default\": \"./dist/index.cjs\"\n    }\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.0.4\",\n    \"@supabase/sql-to-rest\": \"^0.1.6\",\n    \"zod\": \"^3.24.1\",\n    \"zod-to-json-schema\": \"^3.24.1\"\n  },\n  \"devDependencies\": {\n    \"@supabase/mcp-utils\": \"*\",\n    \"@total-typescript/tsconfig\": \"^1.0.4\",\n    \"@types/node\": \"^22.8.6\",\n    \"prettier\": \"^3.3.3\",\n    \"tsup\": \"^8.3.5\",\n    \"tsx\": \"^4.19.2\",\n    \"typescript\": \"^5.6.3\",\n    \"vitest\": \"^2.1.4\"\n  }\n}\n","/**\n * Ensures that a URL has a trailing slash.\n */\nexport function ensureTrailingSlash(url: string) {\n  return url.endsWith('/') ? url : `${url}/`;\n}\n\n/**\n * Ensures that a URL does not have a trailing slash.\n */\nexport function ensureNoTrailingSlash(url: string) {\n  return url.endsWith('/') ? url.slice(0, -1) : url;\n}\n"]}