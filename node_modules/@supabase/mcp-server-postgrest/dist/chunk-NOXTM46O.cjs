"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var _indexjs = require('@modelcontextprotocol/sdk/server/index.js');var _typesjs = require('@modelcontextprotocol/sdk/types.js');var _sqltorest = require('@supabase/sql-to-rest');var _zod = require('zod');var _zodtojsonschema = require('zod-to-json-schema');var h="0.1.0";function l(o){return o.endsWith("/")?o:`${o}/`}function d(o){return o.endsWith("/")?o.slice(0,-1):o}var c=class extends _indexjs.Server{#s;#e;#r;#t={postgrestRequest:{description:"Performs HTTP request against the PostgREST API",parameters:_zod.z.object({method:_zod.z.enum(["GET","POST","PUT","PATCH","DELETE"]),path:_zod.z.string(),body:_zod.z.record(_zod.z.unknown()).optional()}),execute:async({method:r,path:t,body:e})=>{let s=new URL(`${this.#s}${t}`);return await(await fetch(s,{method:r,headers:this.#o(r),body:e?JSON.stringify(e):void 0})).json()}},sqlToRest:{description:"Converts SQL query to a PostgREST API request (method, path)",parameters:_zod.z.object({sql:_zod.z.string()}),execute:async({sql:r})=>{let t=await _sqltorest.processSql.call(void 0, r),e=await _sqltorest.renderHttp.call(void 0, t);return{method:e.method,path:e.fullPath}}}};constructor(r){super({name:"supabase/postgrest",version:h},{capabilities:{resources:{},tools:{}}}),this.#s=d(r.apiUrl),this.#e=r.apiKey,this.#r=r.schema,this.setRequestHandler(_typesjs.ListResourcesRequestSchema,async()=>{let t=await this.#n();return{resources:Object.keys(t.paths).filter(s=>s!=="/").map(s=>{let n=s.split("/").pop(),p=_optionalChain([t, 'access', _ => _.paths, 'access', _2 => _2[s], 'access', _3 => _3.get, 'optionalAccess', _4 => _4.summary]);return{uri:new URL(`${s}/spec`,`postgrest://${this.#r}`).href,name:`"${n}" OpenAPI path spec`,description:p,mimeType:"application/json"}})}}),this.setRequestHandler(_typesjs.ReadResourceRequestSchema,async t=>{let e=await this.#n(),n=new URL(t.params.uri).pathname.split("/"),a=n.pop(),p=n.pop();if(a!=="spec")throw new Error("invalid resource uri");let u=e.paths[`/${p}`];if(!u)throw new Error("path not found");return{contents:[{uri:t.params.uri,mimeType:"application/json",text:JSON.stringify(u)}]}}),this.setRequestHandler(_typesjs.ListToolsRequestSchema,async()=>({tools:Object.entries(this.#t).map(([e,{description:s,parameters:n}])=>({name:e,description:s,inputSchema:_zodtojsonschema.zodToJsonSchema.call(void 0, n)}))})),this.setRequestHandler(_typesjs.CallToolRequestSchema,async t=>{let e=this.#t,s=t.params.name;if(!(s in this.#t))throw new Error("tool not found");let n=this.#t[s],a=n.parameters.parse(t.params.arguments);if(!a)throw new Error("missing arguments");let p=await n.execute(a);return{content:[{type:"text",text:JSON.stringify(p)}]}})}async#n(){return await(await fetch(l(this.#s),{headers:this.#o()})).json()}#o(r="GET"){let e={"content-type":"application/json",prefer:"return=representation",[r==="GET"?"accept-profile":"content-profile"]:this.#r};return this.#e&&(e.apikey=this.#e,e.authorization=`Bearer ${this.#e}`),e}};exports.a = c;
//# sourceMappingURL=chunk-NOXTM46O.cjs.map