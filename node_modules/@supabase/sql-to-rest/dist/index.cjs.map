{"version":3,"sources":["../src/index.ts","../src/errors.ts","../src/processor/index.ts","../src/processor/util.ts","../src/processor/aggregate.ts","../src/processor/filter.ts","../src/processor/limit.ts","../src/processor/sort.ts","../src/processor/select.ts","../node_modules/common-tags/src/TemplateTag/TemplateTag.js","../node_modules/common-tags/src/trimResultTransformer/trimResultTransformer.js","../node_modules/common-tags/src/stripIndentTransformer/stripIndentTransformer.js","../node_modules/common-tags/src/replaceResultTransformer/replaceResultTransformer.js","../node_modules/common-tags/src/replaceSubstitutionTransformer/replaceSubstitutionTransformer.js","../node_modules/common-tags/src/inlineArrayTransformer/inlineArrayTransformer.js","../node_modules/common-tags/src/splitStringTransformer/splitStringTransformer.js","../node_modules/common-tags/src/removeNonPrintingValuesTransformer/removeNonPrintingValuesTransformer.js","../node_modules/common-tags/src/commaLists/commaLists.js","../node_modules/common-tags/src/commaListsAnd/commaListsAnd.js","../node_modules/common-tags/src/commaListsOr/commaListsOr.js","../node_modules/common-tags/src/html/html.js","../node_modules/common-tags/src/safeHtml/safeHtml.js","../node_modules/common-tags/src/oneLine/oneLine.js","../node_modules/common-tags/src/oneLineTrim/oneLineTrim.js","../node_modules/common-tags/src/oneLineCommaLists/oneLineCommaLists.js","../node_modules/common-tags/src/oneLineCommaListsOr/oneLineCommaListsOr.js","../node_modules/common-tags/src/oneLineCommaListsAnd/oneLineCommaListsAnd.js","../node_modules/common-tags/src/inlineLists/inlineLists.js","../node_modules/common-tags/src/oneLineInlineLists/oneLineInlineLists.js","../node_modules/common-tags/src/stripIndent/stripIndent.js","../node_modules/common-tags/src/stripIndents/stripIndents.js","../src/renderers/util.ts","../src/renderers/http.ts","../src/renderers/supabase-js.ts"],"sourcesContent":["export * from './errors.js'\nexport * from './processor/index.js'\nexport * from './renderers/http.js'\nexport * from './renderers/supabase-js.js'\n","export class ParsingError extends Error {\n  override name = 'ParsingError'\n\n  constructor(\n    message: string,\n    public hint?: string\n  ) {\n    super(sentenceCase(message))\n  }\n}\n\nexport class UnimplementedError extends Error {\n  override name = 'UnimplementedError'\n}\n\nexport class UnsupportedError extends Error {\n  override name = 'UnsupportedError'\n\n  constructor(\n    message: string,\n    public hint?: string\n  ) {\n    super(message)\n  }\n}\n\nexport class RenderError extends Error {\n  override name = 'RenderError'\n\n  constructor(\n    message: string,\n    public renderer: 'http' | 'supabase-js'\n  ) {\n    super(message)\n  }\n}\n\nexport function sentenceCase(value: string) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Expected a string')\n  }\n\n  if (value.length === 0) {\n    return value\n  }\n\n  return value[0]!.toUpperCase() + value.slice(1)\n}\n\n/**\n * Returns hints for common parsing errors.\n */\nexport function getParsingErrorHint(message: string) {\n  switch (message) {\n    case 'syntax error at or near \"from\"':\n      return 'Did you leave a trailing comma in the select target list?'\n    case 'syntax error at or near \"where\"':\n      return 'Do you have an incomplete join in the FROM clause?'\n    default:\n      undefined\n  }\n}\n","import { PgParser, unwrapParseResult } from '@supabase/pg-parser'\nimport type { RawStmt } from '@supabase/pg-parser/17/types'\nimport {\n  ParsingError,\n  UnimplementedError,\n  UnsupportedError,\n  getParsingErrorHint,\n} from '../errors.js'\nimport { processSelectStatement } from './select.js'\nimport type { Statement } from './types.js'\n\nexport { supportedAggregateFunctions } from './select.js'\nexport * from './types.js'\nexport { everyTarget, flattenTargets, someFilter, someTarget } from './util.js'\n\nconst parser = new PgParser()\n\n/**\n * Coverts SQL into a PostgREST-compatible `Statement`.\n *\n * Expects SQL to contain only one statement.\n *\n * @returns An intermediate `Statement` object that\n * can be rendered to various targets (HTTP, supabase-js, etc).\n */\nexport async function processSql(sql: string): Promise<Statement> {\n  try {\n    const result = await unwrapParseResult(parser.parse(sql))\n\n    if (!result.stmts || result.stmts.length === 0) {\n      throw new UnsupportedError('Expected a statement, but received none')\n    }\n\n    if (result.stmts.length > 1) {\n      throw new UnsupportedError('Expected a single statement, but received multiple')\n    }\n\n    const [statement] = result.stmts.map((stmt) => {\n      if (!stmt) {\n        throw new UnsupportedError('Expected a statement, but received an empty one')\n      }\n\n      return processStatement(stmt)\n    })\n\n    return statement!\n  } catch (err) {\n    if (err instanceof Error && 'cursorPosition' in err) {\n      const hint = getParsingErrorHint(err.message)\n      const parsingError = new ParsingError(err.message, hint)\n\n      Object.assign(parsingError, err)\n      throw parsingError\n    } else {\n      throw err\n    }\n  }\n}\n\n/**\n * Converts a pg-query `Stmt` into a PostgREST-compatible `Statement`.\n */\nfunction processStatement({ stmt }: RawStmt): Statement {\n  if (!stmt) {\n    throw new UnsupportedError('Expected a statement, but received an empty one')\n  }\n\n  if ('SelectStmt' in stmt) {\n    return processSelectStatement(stmt.SelectStmt)\n  } else if ('InsertStmt' in stmt) {\n    throw new UnimplementedError(`Insert statements are not yet implemented by the translator`)\n  } else if ('UpdateStmt' in stmt) {\n    throw new UnimplementedError(`Update statements are not yet implemented by the translator`)\n  } else if ('DeleteStmt' in stmt) {\n    throw new UnimplementedError(`Delete statements are not yet implemented by the translator`)\n  } else if ('ExplainStmt' in stmt) {\n    throw new UnimplementedError(`Explain statements are not yet implemented by the translator`)\n  } else {\n    const [stmtType] = Object.keys(stmt)\n    if (!stmtType) {\n      throw new UnsupportedError('Expected a statement, but received an empty one')\n    }\n    const statementType = stmtType.replace(/Stmt$/, '')\n    throw new UnsupportedError(`${statementType} statements are not supported`)\n  }\n}\n","import type { A_Const, A_Expr, Node, String } from '@supabase/pg-parser/17/types'\nimport { UnsupportedError } from '../errors.js'\nimport type {\n  AggregateTarget,\n  ColumnFilter,\n  ColumnTarget,\n  EmbeddedTarget,\n  Filter,\n  Relations,\n  Target,\n} from './types.js'\n\nexport function processJsonTarget(expression: A_Expr, relations: Relations): ColumnTarget {\n  if (!expression.name || expression.name.length === 0) {\n    throw new UnsupportedError('JSON operator must have a name')\n  }\n\n  if (expression.name.length > 1) {\n    throw new UnsupportedError('Only one operator name supported per expression')\n  }\n\n  const [name] = expression.name\n\n  if (!('String' in name!)) {\n    throw new UnsupportedError('JSON operator name must be a string')\n  }\n\n  const operator = name.String.sval\n\n  if (!operator) {\n    throw new UnsupportedError('JSON operator name cannot be empty')\n  }\n\n  if (!['->', '->>'].includes(operator)) {\n    throw new UnsupportedError(`Invalid JSON operator`)\n  }\n\n  let cast: string | undefined = undefined\n  let left: string | number\n  let right: string | number\n\n  if (!expression.lexpr) {\n    throw new UnsupportedError('JSON path must have a left expression')\n  }\n\n  if ('A_Const' in expression.lexpr) {\n    // JSON path cannot contain a float\n    if ('fval' in expression.lexpr.A_Const) {\n      throw new UnsupportedError('Invalid JSON path')\n    }\n    left = parseConstant(expression.lexpr.A_Const)\n  } else if ('A_Expr' in expression.lexpr) {\n    const { column } = processJsonTarget(expression.lexpr.A_Expr, relations)\n    left = column\n  } else if ('ColumnRef' in expression.lexpr) {\n    if (!expression.lexpr.ColumnRef.fields) {\n      throw new UnsupportedError('JSON path must have a column reference')\n    }\n    left = renderFields(expression.lexpr.ColumnRef.fields, relations)\n  } else {\n    throw new UnsupportedError('Invalid JSON path')\n  }\n\n  if (!expression.rexpr || !expression.rexpr) {\n    throw new UnsupportedError('JSON path must have a right expression')\n  }\n\n  if ('A_Const' in expression.rexpr) {\n    // JSON path cannot contain a float\n    if ('fval' in expression.rexpr.A_Const) {\n      throw new UnsupportedError('Invalid JSON path')\n    }\n    right = parseConstant(expression.rexpr.A_Const)\n  } else if ('TypeCast' in expression.rexpr) {\n    if (!expression.rexpr.TypeCast.typeName?.names) {\n      throw new UnsupportedError('Type cast must have a name')\n    }\n    cast = renderDataType(\n      expression.rexpr.TypeCast.typeName.names.map((n) => {\n        if (!('String' in n)) {\n          throw new UnsupportedError('Type cast name must be a string')\n        }\n        return n.String\n      })\n    )\n\n    if (!expression.rexpr.TypeCast.arg) {\n      throw new UnsupportedError('Type cast must have an argument')\n    }\n\n    if ('A_Const' in expression.rexpr.TypeCast.arg) {\n      if ('sval' in expression.rexpr.TypeCast.arg.A_Const) {\n        if (!expression.rexpr.TypeCast.arg.A_Const.sval?.sval) {\n          throw new UnsupportedError('Type cast argument cannot be empty')\n        }\n        right = expression.rexpr.TypeCast.arg.A_Const.sval.sval\n      } else {\n        throw new UnsupportedError('Invalid JSON path')\n      }\n    } else {\n      throw new UnsupportedError('Invalid JSON path')\n    }\n  } else {\n    throw new UnsupportedError('Invalid JSON path')\n  }\n\n  return {\n    type: 'column-target',\n    column: `${left}${operator}${right}`,\n    cast,\n  }\n}\n\nexport function renderFields(\n  fields: Node[],\n  relations: Relations,\n  syntax: 'dot' | 'parenthesis' = 'dot'\n): string {\n  // Get qualified column name segments, eg. `author.name` -> ['author', 'name']\n  const nameSegments = fields.map((field) => {\n    if ('String' in field) {\n      return field.String.sval\n    } else if ('A_Star' in field) {\n      return '*'\n    } else {\n      const [internalType] = Object.keys(field)\n      throw new UnsupportedError(`Unsupported internal type '${internalType}' for data type names`)\n    }\n  })\n\n  // Relation and column names are last two parts of the qualified name\n  const [relationOrAliasName] = nameSegments.slice(-2, -1)\n  const [columnName] = nameSegments.slice(-1)\n\n  const joinedRelation = relations.joined.find(\n    (t) => (t.alias ?? t.relation) === relationOrAliasName\n  )\n\n  // If the column is prefixed with the primary relation, strip the prefix\n  if (!relationOrAliasName || relationOrAliasName === relations.primary.reference) {\n    if (!columnName) {\n      throw new UnsupportedError('Column name cannot be empty')\n    }\n    return columnName\n  }\n  // If it's prefixed with a joined relation in the FROM clause, keep the relation prefix\n  else if (joinedRelation) {\n    // Joined relations that are spread don't support aliases, so we will\n    // convert the alias back to the original relation name in this case\n    const joinedRelationName = joinedRelation.flatten\n      ? joinedRelation.relation\n      : relationOrAliasName\n\n    if (syntax === 'dot') {\n      return [joinedRelationName, columnName].join('.')\n    } else if (syntax === 'parenthesis') {\n      return `${joinedRelationName}(${columnName})`\n    } else {\n      throw new Error(`Unknown render syntax '${syntax}'`)\n    }\n  }\n  // If it's prefixed with an unknown relation, throw an error\n  else {\n    const qualifiedName = [relationOrAliasName, columnName].join('.')\n\n    throw new UnsupportedError(\n      `Found foreign column '${qualifiedName}' without a join to that relation`,\n      'Did you forget to join that relation or alias it to something else?'\n    )\n  }\n}\n\nexport function renderDataType(names: String[]) {\n  const [first, ...rest] = names\n\n  if (!first) {\n    throw new UnsupportedError('Data type must have a name')\n  }\n\n  if (first.sval === 'pg_catalog' && rest.length === 1) {\n    const [name] = rest\n\n    if (!name) {\n      throw new UnsupportedError('Data type must have a name')\n    }\n\n    // The PG parser converts some data types, eg. int -> pg_catalog.int4\n    // so we'll map those back\n    switch (name.sval) {\n      case 'int2':\n        return 'smallint'\n      case 'int4':\n        return 'int'\n      case 'int8':\n        return 'bigint'\n      case 'float8':\n        return 'float'\n      default:\n        return name.sval\n    }\n  } else if (rest.length > 0) {\n    throw new UnsupportedError(\n      `Casts can only reference data types by their unqualified name (not schema-qualified)`\n    )\n  } else {\n    return first.sval\n  }\n}\n\nexport function parseConstant(constant: A_Const) {\n  if ('sval' in constant) {\n    if (constant.sval?.sval === undefined) {\n      throw new UnsupportedError('Constant value cannot be empty')\n    }\n    return constant.sval.sval\n  } else if ('ival' in constant) {\n    if (constant.ival === undefined) {\n      throw new UnsupportedError('Constant value cannot be undefined')\n    }\n    // The PG parser turns 0 into undefined, so convert it back here\n    return constant.ival.ival ?? 0\n  } else if ('fval' in constant) {\n    if (constant.fval?.fval === undefined) {\n      throw new UnsupportedError('Constant value cannot be undefined')\n    }\n    return parseFloat(constant.fval.fval)\n  } else {\n    throw new UnsupportedError(`Constant values must be a string, integer, or float`)\n  }\n}\n\n/**\n * Recursively flattens PostgREST embedded targets.\n */\nexport function flattenTargets(targets: Target[]): Target[] {\n  return targets.flatMap((target) => {\n    const { type } = target\n    if (type === 'column-target' || type === 'aggregate-target') {\n      return target\n    } else if (type === 'embedded-target') {\n      return [target, ...flattenTargets(target.targets)]\n    } else {\n      throw new UnsupportedError(`Unknown target type '${type}'`)\n    }\n  })\n}\n\n/**\n * Recursively iterates through PostgREST filters and checks if the predicate\n * matches any of them (ie. `some()`).\n */\nexport function someFilter(filter: Filter, predicate: (filter: ColumnFilter) => boolean): boolean {\n  const { type } = filter\n\n  if (type === 'column') {\n    return predicate(filter)\n  } else if (type === 'logical') {\n    return filter.values.some((f) => someFilter(f, predicate))\n  } else {\n    throw new UnsupportedError(`Unknown filter type '${type}'`)\n  }\n}\n\n/**\n * Recursively iterates through a PostgREST target list and checks if the predicate\n * matches every one of them (ie. `some()`).\n */\nexport function everyTarget(\n  targets: Target[],\n  predicate: (target: ColumnTarget | AggregateTarget, parent?: EmbeddedTarget) => boolean,\n  parent?: EmbeddedTarget\n): boolean {\n  return targets.every((target) => {\n    const { type } = target\n\n    if (type === 'column-target' || type === 'aggregate-target') {\n      return predicate(target, parent)\n    } else if (type === 'embedded-target') {\n      return everyTarget(target.targets, predicate, target)\n    } else {\n      throw new UnsupportedError(`Unknown target type '${type}'`)\n    }\n  })\n}\n\n/**\n * Recursively iterates through a PostgREST target list and checks if the predicate\n * matches any of them (ie. `some()`).\n */\nexport function someTarget(\n  targets: Target[],\n  predicate: (target: ColumnTarget | AggregateTarget, parent?: EmbeddedTarget) => boolean,\n  parent?: EmbeddedTarget\n): boolean {\n  return targets.some((target) => {\n    const { type } = target\n\n    if (type === 'column-target' || type === 'aggregate-target') {\n      return predicate(target, parent)\n    } else if (type === 'embedded-target') {\n      return someTarget(target.targets, predicate, target)\n    } else {\n      throw new UnsupportedError(`Unknown target type '${type}'`)\n    }\n  })\n}\n","import type { ColumnRef } from '@supabase/pg-parser/17/types'\nimport { UnsupportedError } from '../errors.js'\nimport type { Relations, Target } from './types.js'\nimport { everyTarget, renderFields, someTarget } from './util.js'\n\nexport function validateGroupClause(\n  groupClause: ColumnRef[],\n  targets: Target[],\n  relations: Relations\n) {\n  const groupByColumns = groupClause.map((columnRef) => {\n    if (!columnRef.fields) {\n      throw new UnsupportedError('Group by clause must contain at least one column')\n    }\n    return renderFields(columnRef.fields, relations) ?? []\n  })\n\n  if (\n    !groupByColumns.every((column) =>\n      someTarget(targets, (target, parent) => {\n        // The `count()` special case aggregate has no column attached\n        if (!('column' in target)) {\n          return false\n        }\n\n        const path = parent\n          ? // joined columns have to be prefixed with their relation\n            [parent.alias && !parent.flatten ? parent.alias : parent.relation, target.column]\n          : // top-level columns will have no prefix\n            [target.column]\n\n        const qualifiedName = path.join('.')\n        return qualifiedName === column\n      })\n    )\n  ) {\n    throw new UnsupportedError(`Every group by column must also exist as a select target`)\n  }\n\n  if (\n    someTarget(targets, (target) => target.type === 'aggregate-target') &&\n    !everyTarget(targets, (target, parent) => {\n      if (target.type === 'aggregate-target') {\n        return true\n      }\n\n      const path = parent\n        ? // joined columns have to be prefixed with their relation\n          [parent.alias && !parent.flatten ? parent.alias : parent.relation, target.column]\n        : // top-level columns will have no prefix\n          [target.column]\n\n      const qualifiedName = path.join('.')\n\n      return groupByColumns.some((column) => qualifiedName === column)\n    })\n  ) {\n    throw new UnsupportedError(\n      `Every non-aggregate select target must also exist in a group by clause`\n    )\n  }\n\n  if (\n    groupByColumns.length > 0 &&\n    !someTarget(targets, (target) => target.type === 'aggregate-target')\n  ) {\n    throw new UnsupportedError(\n      `There must be at least one aggregate function in the select target list when using group by`\n    )\n  }\n}\n","import type { A_Expr_Kind, Node } from '@supabase/pg-parser/17/types'\nimport { UnsupportedError } from '../errors.js'\nimport type { ColumnFilter, Filter, Relations } from './types.js'\nimport { parseConstant, processJsonTarget, renderFields } from './util.js'\n\nexport function processWhereClause(expression: Node, relations: Relations): Filter {\n  if ('A_Expr' in expression) {\n    let column: string\n\n    if (!expression.A_Expr.name || expression.A_Expr.name.length > 1) {\n      throw new UnsupportedError('Only one operator name supported per expression')\n    }\n\n    const kind = expression.A_Expr.kind\n\n    if (!kind) {\n      throw new UnsupportedError('WHERE clause must have an operator kind')\n    }\n\n    const [name] = expression.A_Expr.name\n\n    if (!name) {\n      throw new UnsupportedError('WHERE clause must have an operator name')\n    }\n\n    if (!('String' in name)) {\n      throw new UnsupportedError('WHERE clause operator name must be a string')\n    }\n\n    if (!name.String.sval) {\n      throw new UnsupportedError('WHERE clause operator name cannot be empty')\n    }\n\n    const operatorSymbol = name.String.sval.toLowerCase()\n    const operator = mapOperatorSymbol(kind, operatorSymbol)\n\n    if (!expression.A_Expr.lexpr) {\n      throw new UnsupportedError('Left side of WHERE clause must be a column or expression')\n    }\n\n    if ('A_Expr' in expression.A_Expr.lexpr) {\n      try {\n        const target = processJsonTarget(expression.A_Expr.lexpr.A_Expr, relations)\n        column = target.column\n      } catch (err) {\n        throw new UnsupportedError(`Left side of WHERE clause must be a column`)\n      }\n    } else if ('ColumnRef' in expression.A_Expr.lexpr) {\n      const { fields } = expression.A_Expr.lexpr.ColumnRef\n      if (!fields || fields.length === 0) {\n        throw new UnsupportedError(`Left side of WHERE clause must reference a column`)\n      }\n      column = renderFields(fields, relations)\n    } else if ('TypeCast' in expression.A_Expr.lexpr) {\n      throw new UnsupportedError('Casting is not supported in the WHERE clause')\n    } else if ('FuncCall' in expression.A_Expr.lexpr) {\n      if (!expression.A_Expr.lexpr.FuncCall.funcname) {\n        throw new UnsupportedError(`Left side of WHERE clause must reference a column`)\n      }\n      const functionName = renderFields(expression.A_Expr.lexpr.FuncCall.funcname, relations)\n\n      // Only 'to_tsvector' function is supported on left side of WHERE clause (when using FTS `@@` operator))\n      if (operator === 'fts') {\n        if (functionName === 'to_tsvector') {\n          if (\n            !expression.A_Expr.lexpr.FuncCall.args ||\n            expression.A_Expr.lexpr.FuncCall.args.length !== 1\n          ) {\n            throw new UnsupportedError(`${functionName} requires 1 column argument`)\n          }\n\n          // We grab the column passed to `to_tsvector` and discard the `to_tsvector` function\n          // We can do this because Postgres will implicitly wrap text columns in `to_tsvector` at query time\n          const [arg] = expression.A_Expr.lexpr.FuncCall.args\n\n          if (!arg) {\n            throw new UnsupportedError(`${functionName} requires a column argument`)\n          }\n\n          if ('A_Expr' in arg) {\n            try {\n              const target = processJsonTarget(arg.A_Expr, relations)\n              column = target.column\n            } catch (err) {\n              throw new UnsupportedError(`${functionName} requires a column argument`)\n            }\n          } else if ('ColumnRef' in arg) {\n            const { fields } = arg.ColumnRef\n            if (!fields) {\n              throw new UnsupportedError(`${functionName} requires a column argument`)\n            }\n            column = renderFields(fields, relations)\n          } else if ('TypeCast' in arg) {\n            throw new UnsupportedError('Casting is not supported in the WHERE clause')\n          } else {\n            throw new UnsupportedError(`${functionName} requires a column argument`)\n          }\n        } else {\n          throw new UnsupportedError(\n            `Only 'to_tsvector' function allowed on left side of text search operator`\n          )\n        }\n      } else {\n        throw new UnsupportedError(`Left side of WHERE clause must be a column`)\n      }\n    } else {\n      throw new UnsupportedError(`Left side of WHERE clause must be a column`)\n    }\n\n    if (\n      operator === 'eq' ||\n      operator === 'neq' ||\n      operator === 'gt' ||\n      operator === 'gte' ||\n      operator === 'lt' ||\n      operator === 'lte'\n    ) {\n      if (!expression.A_Expr.rexpr) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must be present`\n        )\n      }\n\n      if (!('A_Const' in expression.A_Expr.rexpr)) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must be a constant`,\n          `Did you forget to wrap your value in single quotes?`\n        )\n      }\n\n      const value = parseConstant(expression.A_Expr.rexpr.A_Const)\n      return {\n        type: 'column',\n        column,\n        operator,\n        negate: false,\n        value,\n      }\n    }\n    // Between is not supported by PostgREST, but we can generate the equivalent using '>=' and '<='\n    else if (\n      operator === 'between' ||\n      operator === 'between symmetric' ||\n      operator === 'not between' ||\n      operator === 'not between symmetric'\n    ) {\n      if (!expression.A_Expr.rexpr) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must be present`\n        )\n      }\n\n      if (\n        !('List' in expression.A_Expr.rexpr) ||\n        expression.A_Expr.rexpr.List.items?.length !== 2\n      ) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must contain two constants`\n        )\n      }\n\n      let [leftValue, rightValue] = expression.A_Expr.rexpr.List.items.map((item) => {\n        if (!('A_Const' in item)) {\n          throw new UnsupportedError(\n            `Right side of WHERE clause '${operatorSymbol}' expression must contain two constants`\n          )\n        }\n        return parseConstant(item.A_Const)\n      })\n\n      // 'between symmetric' doesn't care which argument comes first order-wise,\n      // ie. it auto swaps the arguments if the left value is greater than the right value\n      if (operator.includes('symmetric')) {\n        // We can only implement the symmetric logic if the values are numbers\n        // If they're strings, they could be dates, text columns, etc which we can't sort here\n        if (typeof leftValue !== 'number' || typeof rightValue !== 'number') {\n          throw new UnsupportedError(`BETWEEN SYMMETRIC is only supported with number values`)\n        }\n\n        // If the left value is greater than the right, swap them\n        if (leftValue > rightValue) {\n          const temp = rightValue\n          rightValue = leftValue\n          leftValue = temp\n        }\n      }\n\n      if (!leftValue) {\n        throw new UnsupportedError(\n          `Left side of WHERE clause '${operatorSymbol}' expression must be a constant`\n        )\n      }\n\n      const leftFilter: ColumnFilter = {\n        type: 'column',\n        column,\n        operator: 'gte',\n        negate: false,\n        value: leftValue,\n      }\n\n      if (!rightValue) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must be a constant`\n        )\n      }\n\n      const rightFilter: ColumnFilter = {\n        type: 'column',\n        column,\n        operator: 'lte',\n        negate: false,\n        value: rightValue,\n      }\n\n      return {\n        type: 'logical',\n        operator: 'and',\n        negate: operator.includes('not'),\n        values: [leftFilter, rightFilter],\n      }\n    } else if (\n      operator === 'like' ||\n      operator === 'ilike' ||\n      operator === 'match' ||\n      operator === 'imatch'\n    ) {\n      if (!expression.A_Expr.rexpr) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must be present`\n        )\n      }\n\n      if (\n        !('A_Const' in expression.A_Expr.rexpr) ||\n        !('sval' in expression.A_Expr.rexpr.A_Const) ||\n        !expression.A_Expr.rexpr.A_Const.sval?.sval\n      ) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operator}' expression must be a string constant`\n        )\n      }\n\n      const value = expression.A_Expr.rexpr.A_Const.sval.sval\n\n      return {\n        type: 'column',\n        column,\n        operator,\n        negate: false,\n        value,\n      }\n    } else if (operator === 'in') {\n      if (!expression.A_Expr.rexpr) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must be present`\n        )\n      }\n\n      if (\n        !('List' in expression.A_Expr.rexpr) ||\n        !expression.A_Expr.rexpr.List.items?.every((item) => 'A_Const' in item)\n      ) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operator}' expression must be a list of constants`\n        )\n      }\n\n      const value = expression.A_Expr.rexpr.List.items.map((item) => parseConstant(item.A_Const))\n\n      return {\n        type: 'column',\n        column,\n        operator,\n        negate: false,\n        value,\n      }\n    } else if (operator === 'fts') {\n      const supportedTextSearchFunctions = [\n        'to_tsquery',\n        'plainto_tsquery',\n        'phraseto_tsquery',\n        'websearch_to_tsquery',\n      ]\n\n      if (!expression.A_Expr.rexpr) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must be present`\n        )\n      }\n\n      if (!('FuncCall' in expression.A_Expr.rexpr) || !expression.A_Expr.rexpr.FuncCall.funcname) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must be one of these functions: ${supportedTextSearchFunctions.join(', ')}`\n        )\n      }\n\n      const functionName = renderFields(expression.A_Expr.rexpr.FuncCall.funcname, relations)\n\n      if (!supportedTextSearchFunctions.includes(functionName)) {\n        throw new UnsupportedError(\n          `Right side of WHERE clause '${operatorSymbol}' expression must be one of these functions: ${supportedTextSearchFunctions.join(', ')}`\n        )\n      }\n\n      if (\n        !expression.A_Expr.rexpr.FuncCall.args ||\n        expression.A_Expr.rexpr.FuncCall.args.length === 0 ||\n        expression.A_Expr.rexpr.FuncCall.args.length > 2\n      ) {\n        throw new UnsupportedError(`${functionName} requires 1 or 2 arguments`)\n      }\n\n      const args = expression.A_Expr.rexpr.FuncCall.args.map((arg) => {\n        if (!('A_Const' in arg) || !arg.A_Const.sval?.sval) {\n          throw new UnsupportedError(`${functionName} only accepts text arguments`)\n        }\n\n        return arg.A_Const.sval.sval\n      })\n\n      // config (eg. 'english') is the first argument if passed\n      const [config] = args.slice(-2, -1)\n\n      // query is always the last argument\n      const [query] = args.slice(-1)\n\n      if (!query) {\n        throw new UnsupportedError(`${functionName} requires a query argument`)\n      }\n\n      // Adjust operator based on FTS function\n      const operator = mapTextSearchFunction(functionName)\n\n      return {\n        type: 'column',\n        column,\n        operator,\n        config,\n        value: query,\n        negate: false,\n      }\n    } else {\n      throw new UnsupportedError(`Unsupported operator '${operatorSymbol}'`)\n    }\n  } else if ('NullTest' in expression) {\n    if (!expression.NullTest.arg || !('ColumnRef' in expression.NullTest.arg)) {\n      throw new UnsupportedError(`NullTest expression must have an argument of type ColumnRef`)\n    }\n\n    const { fields } = expression.NullTest.arg.ColumnRef\n\n    if (!fields) {\n      throw new UnsupportedError(`NullTest expression must reference a column`)\n    }\n\n    const column = renderFields(fields, relations)\n    const negate = expression.NullTest.nulltesttype === 'IS_NOT_NULL'\n    const operator = 'is'\n    const value = null\n\n    return {\n      type: 'column',\n      column,\n      operator,\n      negate,\n      value,\n    }\n  } else if ('BoolExpr' in expression) {\n    let operator: 'and' | 'or' | 'not'\n\n    if (expression.BoolExpr.boolop === 'AND_EXPR') {\n      operator = 'and'\n    } else if (expression.BoolExpr.boolop === 'OR_EXPR') {\n      operator = 'or'\n    } else if (expression.BoolExpr.boolop === 'NOT_EXPR') {\n      operator = 'not'\n    } else {\n      throw new UnsupportedError(`Unknown boolop '${expression.BoolExpr.boolop}'`)\n    }\n\n    if (!expression.BoolExpr.args) {\n      throw new UnsupportedError(`BoolExpr must have arguments`)\n    }\n\n    const values = expression.BoolExpr.args.map((arg) => processWhereClause(arg, relations))\n\n    // The 'not' operator is special - instead of wrapping its child,\n    // we just return the child directly and set negate=true on it.\n    if (operator === 'not') {\n      if (values.length > 1) {\n        throw new UnsupportedError(\n          `NOT expressions must have only 1 child, but received ${values.length} children`\n        )\n      }\n\n      const [filter] = values\n      if (!filter) {\n        throw new UnsupportedError(`NOT expression must have a child filter`)\n      }\n\n      filter.negate = true\n      return filter\n    }\n\n    return {\n      type: 'logical',\n      operator,\n      negate: false,\n      values,\n    }\n  } else {\n    throw new UnsupportedError(`The WHERE clause must contain an expression`)\n  }\n}\n\nfunction mapOperatorSymbol(kind: A_Expr_Kind, operatorSymbol: string) {\n  switch (kind) {\n    case 'AEXPR_OP': {\n      switch (operatorSymbol) {\n        case '=':\n          return 'eq'\n        case '<>':\n          return 'neq'\n        case '>':\n          return 'gt'\n        case '>=':\n          return 'gte'\n        case '<':\n          return 'lt'\n        case '<=':\n          return 'lte'\n        case '~':\n          return 'match'\n        case '~*':\n          return 'imatch'\n        case '@@':\n          // 'fts' isn't necessarily the final operator (there is also plfts, phfts, wfts)\n          // we adjust this downstream based on the tsquery function used\n          return 'fts'\n        default:\n          throw new UnsupportedError(`Unsupported operator '${operatorSymbol}'`)\n      }\n    }\n    case 'AEXPR_BETWEEN':\n    case 'AEXPR_BETWEEN_SYM':\n    case 'AEXPR_NOT_BETWEEN':\n    case 'AEXPR_NOT_BETWEEN_SYM': {\n      switch (operatorSymbol) {\n        case 'between':\n          return 'between'\n        case 'between symmetric':\n          return 'between symmetric'\n        case 'not between':\n          return 'not between'\n        case 'not between symmetric':\n          return 'not between symmetric'\n        default:\n          throw new UnsupportedError(`Unsupported operator '${operatorSymbol}'`)\n      }\n    }\n    case 'AEXPR_LIKE': {\n      switch (operatorSymbol) {\n        case '~~':\n          return 'like'\n        default:\n          throw new UnsupportedError(`Unsupported operator '${operatorSymbol}'`)\n      }\n    }\n    case 'AEXPR_ILIKE': {\n      switch (operatorSymbol) {\n        case '~~*':\n          return 'ilike'\n        default:\n          throw new UnsupportedError(`Unsupported operator '${operatorSymbol}'`)\n      }\n    }\n    case 'AEXPR_IN': {\n      switch (operatorSymbol) {\n        case '=':\n          return 'in'\n        default:\n          throw new UnsupportedError(`Unsupported operator '${operatorSymbol}'`)\n      }\n    }\n  }\n}\n\n/**\n * Maps text search query functions to the respective PostgREST operator.\n */\nfunction mapTextSearchFunction(functionName: string) {\n  switch (functionName) {\n    case 'to_tsquery':\n      return 'fts'\n    case 'plainto_tsquery':\n      return 'plfts'\n    case 'phraseto_tsquery':\n      return 'phfts'\n    case 'websearch_to_tsquery':\n      return 'wfts'\n    default:\n      throw new UnsupportedError(`Function '${functionName}' not supported for full-text search`)\n  }\n}\n","import type { SelectStmt } from '@supabase/pg-parser/17/types'\nimport { UnsupportedError } from '../errors.js'\nimport type { Limit } from './types.js'\n\nexport function processLimit(selectStmt: SelectStmt): Limit | undefined {\n  let count: number | undefined = undefined\n  let offset: number | undefined = undefined\n\n  if (selectStmt.limitCount) {\n    if (!('A_Const' in selectStmt.limitCount)) {\n      throw new UnsupportedError(`Limit count must be an A_Const`)\n    }\n\n    if (!('ival' in selectStmt.limitCount.A_Const)) {\n      throw new UnsupportedError(`Limit count must be an integer`)\n    }\n\n    if (!selectStmt.limitCount.A_Const.ival) {\n      throw new UnsupportedError(`Limit count must have an integer value`)\n    }\n\n    count = selectStmt.limitCount.A_Const.ival.ival\n  }\n\n  if (selectStmt.limitOffset) {\n    if (!('A_Const' in selectStmt.limitOffset)) {\n      throw new UnsupportedError(`Limit offset must be an A_Const`)\n    }\n\n    if (!('ival' in selectStmt.limitOffset.A_Const)) {\n      throw new UnsupportedError(`Limit offset must be an integer`)\n    }\n\n    if (!selectStmt.limitOffset.A_Const.ival) {\n      throw new UnsupportedError(`Limit offset must have an integer value`)\n    }\n\n    offset = selectStmt.limitOffset.A_Const.ival.ival\n  }\n\n  if (count === undefined && offset === undefined) {\n    return undefined\n  }\n\n  return {\n    count,\n    offset,\n  }\n}\n","import type { SortBy } from '@supabase/pg-parser/17/types'\nimport { UnsupportedError } from '../errors.js'\nimport type { Relations, Sort } from './types.js'\nimport { processJsonTarget, renderFields } from './util.js'\n\nexport function processSortClause(sorts: SortBy[], relations: Relations): Sort[] {\n  return sorts.map((sortBy) => {\n    let column: string\n\n    if (!sortBy.node) {\n      throw new UnsupportedError(`ORDER BY clause must reference a column`)\n    }\n\n    if ('A_Expr' in sortBy.node) {\n      try {\n        const target = processJsonTarget(sortBy.node.A_Expr, relations)\n        column = target.column\n      } catch (err) {\n        throw new UnsupportedError(`ORDER BY clause must reference a column`)\n      }\n    } else if ('ColumnRef' in sortBy.node) {\n      const { fields } = sortBy.node.ColumnRef\n      if (!fields) {\n        throw new UnsupportedError(`ORDER BY clause must reference a column`)\n      }\n      column = renderFields(fields, relations, 'parenthesis')\n    } else if ('TypeCast' in sortBy.node) {\n      throw new UnsupportedError('Casting is not supported in the ORDER BY clause')\n    } else {\n      throw new UnsupportedError(`ORDER BY clause must reference a column`)\n    }\n\n    if (!sortBy.sortby_dir) {\n      throw new UnsupportedError(`ORDER BY clause must specify a direction`)\n    }\n\n    const direction = mapSortByDirection(sortBy.sortby_dir)\n\n    if (!sortBy.sortby_nulls) {\n      throw new UnsupportedError(`ORDER BY clause must specify nulls handling`)\n    }\n\n    const nulls = mapSortByNulls(sortBy.sortby_nulls)\n\n    return {\n      column,\n      direction,\n      nulls,\n    }\n  })\n}\n\nfunction mapSortByDirection(direction: string) {\n  switch (direction) {\n    case 'SORTBY_ASC':\n      return 'asc'\n    case 'SORTBY_DESC':\n      return 'desc'\n    case 'SORTBY_DEFAULT':\n      return undefined\n    default:\n      throw new UnsupportedError(`Unknown sort by direction '${direction}'`)\n  }\n}\n\nfunction mapSortByNulls(nulls: string) {\n  switch (nulls) {\n    case 'SORTBY_NULLS_FIRST':\n      return 'first'\n    case 'SORTBY_NULLS_LAST':\n      return 'last'\n    case 'SORTBY_NULLS_DEFAULT':\n      return undefined\n    default:\n      throw new UnsupportedError(`Unknown sort by nulls '${nulls}'`)\n  }\n}\n","import type {\n  A_Expr,\n  ColumnRef,\n  FuncCall,\n  Node,\n  ResTarget,\n  SelectStmt,\n  String,\n  TypeCast,\n} from '@supabase/pg-parser/17/types'\nimport { UnsupportedError } from '../errors.js'\nimport { validateGroupClause } from './aggregate.js'\nimport { processWhereClause } from './filter.js'\nimport { processLimit } from './limit.js'\nimport { processSortClause } from './sort.js'\nimport type {\n  AggregateTarget,\n  ColumnTarget,\n  EmbeddedTarget,\n  JoinedColumn,\n  Relations,\n  Select,\n  Target,\n} from './types.js'\nimport { processJsonTarget, renderDataType, renderFields } from './util.js'\n\nexport const supportedAggregateFunctions = ['avg', 'count', 'max', 'min', 'sum']\n\nexport function processSelectStatement(stmt: SelectStmt): Select {\n  if (!stmt) {\n    throw new UnsupportedError('Expected a statement, but received an empty one')\n  }\n\n  if (!stmt.fromClause) {\n    throw new UnsupportedError('The query must have a from clause')\n  }\n\n  if (!stmt.targetList) {\n    throw new UnsupportedError('The query must have a target list')\n  }\n\n  if (stmt.fromClause.length > 1) {\n    throw new UnsupportedError('Only one FROM source is supported')\n  }\n\n  if (stmt.withClause) {\n    throw new UnsupportedError('CTEs are not supported')\n  }\n\n  if (stmt.distinctClause) {\n    throw new UnsupportedError('SELECT DISTINCT is not supported')\n  }\n\n  if (stmt.havingClause) {\n    throw new UnsupportedError('The HAVING clause is not supported')\n  }\n\n  const [fromClause] = stmt.fromClause\n\n  if (!fromClause) {\n    throw new UnsupportedError('The FROM clause must have a relation')\n  }\n\n  const relations = processFromClause(fromClause)\n\n  const from = relations.primary.name\n\n  const targetList = stmt.targetList.map((node) => {\n    if (!('ResTarget' in node)) {\n      throw new UnsupportedError('Target list must contain ResTarget nodes')\n    }\n    return node.ResTarget\n  })\n\n  const targets = processTargetList(targetList, relations)\n\n  const groupByColumns =\n    stmt.groupClause?.map((node) => {\n      if (!('ColumnRef' in node)) {\n        throw new UnsupportedError('Group by clause must contain column references')\n      }\n      return node.ColumnRef\n    }) ?? []\n\n  validateGroupClause(groupByColumns, targets, relations)\n\n  const filter = stmt.whereClause ? processWhereClause(stmt.whereClause, relations) : undefined\n\n  const sortByColumns =\n    stmt.sortClause?.map((sortBy) => {\n      if (!('SortBy' in sortBy)) {\n        throw new UnsupportedError('Sort clause must contain SortBy nodes')\n      }\n      return sortBy.SortBy\n    }) ?? []\n\n  const sorts = processSortClause(sortByColumns, relations)\n\n  const limit = processLimit(stmt)\n\n  return {\n    type: 'select',\n    from,\n    targets,\n    filter,\n    sorts,\n    limit,\n  }\n}\n\nfunction processFromClause(fromClause: Node): Relations {\n  if ('RangeVar' in fromClause) {\n    if (!fromClause.RangeVar.relname) {\n      throw new UnsupportedError('The FROM clause must have a relation name')\n    }\n\n    return {\n      primary: {\n        name: fromClause.RangeVar.relname,\n        alias: fromClause.RangeVar.alias?.aliasname,\n        get reference() {\n          return this.alias ?? this.name\n        },\n      },\n      joined: [],\n    }\n  } else if ('JoinExpr' in fromClause) {\n    if (!fromClause.JoinExpr.jointype) {\n      throw new UnsupportedError('Join expression must have a join type')\n    }\n\n    if (!fromClause.JoinExpr.larg || !fromClause.JoinExpr.rarg) {\n      throw new UnsupportedError('Join expression must have both left and right relations')\n    }\n    const joinType = mapJoinType(fromClause.JoinExpr.jointype)\n    const { primary, joined } = processFromClause(fromClause.JoinExpr.larg)\n\n    if (!('RangeVar' in fromClause.JoinExpr.rarg)) {\n      throw new UnsupportedError('Join expression must have a right relation of type RangeVar')\n    }\n\n    const joinedRelationAlias = fromClause.JoinExpr.rarg.RangeVar.alias?.aliasname\n    const joinedRelation = joinedRelationAlias ?? fromClause.JoinExpr.rarg.RangeVar.relname\n\n    const existingRelations = [\n      primary.reference,\n      ...joined.map((t) => t.alias ?? t.relation),\n      joinedRelation,\n    ]\n\n    if (!fromClause.JoinExpr.quals || !('A_Expr' in fromClause.JoinExpr.quals)) {\n      throw new UnsupportedError(`Join qualifier must be an expression comparing columns`)\n    }\n\n    let leftQualifierRelation\n    let rightQualifierRelation\n\n    const joinQualifierExpression = fromClause.JoinExpr.quals.A_Expr\n\n    if (!joinQualifierExpression.lexpr || !('ColumnRef' in joinQualifierExpression.lexpr)) {\n      throw new UnsupportedError(`Left side of join qualifier must be a column`)\n    }\n\n    if (\n      !joinQualifierExpression.lexpr.ColumnRef.fields ||\n      !joinQualifierExpression.lexpr.ColumnRef.fields.every(\n        (field): field is { String: String } => 'String' in field\n      )\n    ) {\n      throw new UnsupportedError(`Left side column of join qualifier must contain String fields`)\n    }\n\n    const leftColumnFields = joinQualifierExpression.lexpr.ColumnRef.fields.map(\n      (field) => field.String.sval\n    )\n\n    // Relation and column names are last two parts of the qualified name\n    const [leftRelationName] = leftColumnFields.slice(-2, -1)\n    const [leftColumnName] = leftColumnFields.slice(-1)\n\n    if (!leftColumnName) {\n      throw new UnsupportedError(`Left side of join qualifier must have a column name`)\n    }\n\n    if (!leftRelationName) {\n      leftQualifierRelation = primary.reference\n    } else if (existingRelations.includes(leftRelationName)) {\n      leftQualifierRelation = leftRelationName\n    } else if (leftRelationName === joinedRelation) {\n      leftQualifierRelation = joinedRelation\n    } else {\n      throw new UnsupportedError(\n        `Left side of join qualifier references a different relation (${leftRelationName}) than the join (${existingRelations.join(', ')})`\n      )\n    }\n\n    if (!joinQualifierExpression.rexpr) {\n      throw new UnsupportedError(`Join qualifier must have a right side expression`)\n    }\n\n    if (!('ColumnRef' in joinQualifierExpression.rexpr)) {\n      throw new UnsupportedError(`Right side of join qualifier must be a column`)\n    }\n\n    if (\n      !joinQualifierExpression.rexpr.ColumnRef.fields?.every(\n        (field): field is { String: String } => 'String' in field\n      )\n    ) {\n      throw new UnsupportedError(`Right side column of join qualifier must contain String fields`)\n    }\n\n    const rightColumnFields = joinQualifierExpression.rexpr.ColumnRef.fields.map(\n      (field) => field.String.sval\n    )\n\n    // Relation and column names are last two parts of the qualified name\n    const [rightRelationName] = rightColumnFields.slice(-2, -1)\n    const [rightColumnName] = rightColumnFields.slice(-1)\n\n    if (!rightColumnName) {\n      throw new UnsupportedError(`Right side of join qualifier must have a column name`)\n    }\n\n    if (!rightRelationName) {\n      rightQualifierRelation = primary.reference\n    } else if (existingRelations.includes(rightRelationName)) {\n      rightQualifierRelation = rightRelationName\n    } else if (rightRelationName === joinedRelation) {\n      rightQualifierRelation = joinedRelation\n    } else {\n      throw new UnsupportedError(\n        `Right side of join qualifier references a different relation (${rightRelationName}) than the join (${existingRelations.join(', ')})`\n      )\n    }\n\n    if (rightQualifierRelation === leftQualifierRelation) {\n      // TODO: support for recursive relationships\n      throw new UnsupportedError(`Join qualifier cannot compare columns from same relation`)\n    }\n\n    if (rightQualifierRelation !== joinedRelation && leftQualifierRelation !== joinedRelation) {\n      throw new UnsupportedError(`Join qualifier must reference a column from the joined table`)\n    }\n\n    if (!joinQualifierExpression.name) {\n      throw new UnsupportedError(`Join qualifier must have an operator`)\n    }\n\n    const [qualifierOperatorString] = joinQualifierExpression.name\n\n    if (!qualifierOperatorString || !('String' in qualifierOperatorString)) {\n      throw new UnsupportedError(`Join qualifier operator must be a string`)\n    }\n\n    if (qualifierOperatorString.String.sval !== '=') {\n      throw new UnsupportedError(`Join qualifier operator must be '='`)\n    }\n\n    let left: JoinedColumn\n    let right: JoinedColumn\n\n    // If left qualifier referenced the joined relation, swap left and right\n    if (rightQualifierRelation === joinedRelation) {\n      left = {\n        relation: leftQualifierRelation,\n        column: leftColumnName,\n      }\n      right = {\n        relation: rightQualifierRelation,\n        column: rightColumnName,\n      }\n    } else {\n      right = {\n        relation: leftQualifierRelation,\n        column: leftColumnName,\n      }\n      left = {\n        relation: rightQualifierRelation,\n        column: rightColumnName,\n      }\n    }\n\n    if (!fromClause.JoinExpr.rarg.RangeVar.relname) {\n      throw new UnsupportedError('Join expression must have a right relation name')\n    }\n\n    const embeddedTarget: EmbeddedTarget = {\n      type: 'embedded-target',\n      relation: fromClause.JoinExpr.rarg.RangeVar.relname,\n      alias: fromClause.JoinExpr.rarg.RangeVar.alias?.aliasname,\n      joinType,\n      targets: [], // these will be filled in later when processing the select target list\n      flatten: true,\n      joinedColumns: {\n        left,\n        right,\n      },\n    }\n\n    return {\n      primary,\n      joined: [...joined, embeddedTarget],\n    }\n  } else {\n    const [fieldType] = Object.keys(fromClause)\n    throw new UnsupportedError(`Unsupported FROM clause type '${fieldType}'`)\n  }\n}\n\nfunction processTargetList(targetList: ResTarget[], relations: Relations): Target[] {\n  // First pass: map each SQL target column to a PostgREST target 1-to-1\n  const flattenedColumnTargets: (ColumnTarget | AggregateTarget)[] = targetList.map((resTarget) => {\n    if (!resTarget.val) {\n      throw new UnsupportedError(`Target list item must have a value`)\n    }\n\n    const target = processTarget(resTarget.val, relations)\n    target.alias = resTarget.name\n\n    return target\n  })\n\n  // Second pass: transfer joined columns to `embeddedTargets`\n  const columnTargets = flattenedColumnTargets.filter((target) => {\n    // Account for the special case when the aggregate doesn't have a column attached\n    // ie. `count()`: should always be applied to the top level relation\n    if (target.type === 'aggregate-target' && !('column' in target)) {\n      return true\n    }\n\n    const qualifiedName = target.column.split('.')\n\n    // Relation and column names are last two parts of the qualified name\n    const [relationName] = qualifiedName.slice(-2, -1)\n    const [columnName] = qualifiedName.slice(-1)\n\n    // If there is no prefix, this column belongs to the primary relation at the top level\n    if (!relationName) {\n      return true\n    }\n\n    if (!columnName) {\n      throw new UnsupportedError(`Column name cannot be empty in target list`)\n    }\n\n    // If this column is part of a joined relation\n    if (relationName) {\n      const embeddedTarget = relations.joined.find(\n        (t) => (t.alias && !t.flatten ? t.alias : t.relation) === relationName\n      )\n\n      if (!embeddedTarget) {\n        throw new UnsupportedError(\n          `Found foreign column '${target.column}' in target list without a join to that relation`,\n          'Did you forget to join that relation or alias it to something else?'\n        )\n      }\n\n      // Strip relation from column name\n      target.column = columnName\n\n      // Nest the column in the embedded target\n      embeddedTarget.targets.push(target)\n\n      // Remove this column from the top level\n      return false\n    }\n\n    return true\n  })\n\n  // Third pass: nest embedded targets within each other based on the relations in their join qualifiers\n  const nestedEmbeddedTargets = relations.joined.reduce<EmbeddedTarget[]>(\n    (output, embeddedTarget) => {\n      // If the embedded target was joined with the primary relation, return it\n      if (embeddedTarget.joinedColumns.left.relation === relations.primary.reference) {\n        return [...output, embeddedTarget]\n      }\n\n      // Otherwise identify the correct parent and nest it within its targets\n      const parent = relations.joined.find(\n        (t) => (t.alias ?? t.relation) === embeddedTarget.joinedColumns.left.relation\n      )\n\n      if (!parent) {\n        throw new UnsupportedError(\n          `Something went wrong, could not find parent embedded target for nested embedded target '${embeddedTarget.relation}'`\n        )\n      }\n\n      parent.targets.push(embeddedTarget)\n      return output\n    },\n    []\n  )\n\n  return [...columnTargets, ...nestedEmbeddedTargets]\n}\n\nfunction processTarget(target: Node, relations: Relations): ColumnTarget | AggregateTarget {\n  if ('TypeCast' in target) {\n    return processCast(target.TypeCast, relations)\n  } else if ('ColumnRef' in target) {\n    return processColumn(target.ColumnRef, relations)\n  } else if ('A_Expr' in target) {\n    return processExpression(target.A_Expr, relations)\n  } else if ('FuncCall' in target) {\n    return processFunctionCall(target.FuncCall, relations)\n  } else {\n    throw new UnsupportedError(\n      'Only columns, JSON fields, and aggregates are supported as query targets'\n    )\n  }\n}\n\nfunction mapJoinType(joinType: string) {\n  switch (joinType) {\n    case 'JOIN_INNER':\n      return 'inner'\n    case 'JOIN_LEFT':\n      return 'left'\n    default:\n      throw new UnsupportedError(`Unsupported join type '${joinType}'`)\n  }\n}\n\nfunction processCast(target: TypeCast, relations: Relations) {\n  if (!target.typeName?.names) {\n    throw new UnsupportedError('Type cast must have a type name')\n  }\n\n  const names = target.typeName.names.map((name) => {\n    if (!('String' in name)) {\n      throw new UnsupportedError('Type cast name must be a string')\n    }\n    return name.String\n  })\n\n  const cast = renderDataType(names)\n\n  if (!target.arg) {\n    throw new UnsupportedError('Type cast must have an argument')\n  }\n\n  if ('A_Const' in target.arg) {\n    throw new UnsupportedError(\n      'Only columns, JSON fields, and aggregates are supported as query targets'\n    )\n  }\n\n  const nestedTarget = processTarget(target.arg, relations)\n\n  const { type } = nestedTarget\n\n  if (type === 'aggregate-target') {\n    return {\n      ...nestedTarget,\n      outputCast: cast,\n    }\n  } else if (type === 'column-target') {\n    return {\n      ...nestedTarget,\n      cast,\n    }\n  } else {\n    throw new UnsupportedError(`Cannot process target with type '${type}'`)\n  }\n}\n\nfunction processColumn(target: ColumnRef, relations: Relations): ColumnTarget {\n  if (!target.fields) {\n    throw new UnsupportedError('Column reference must have fields')\n  }\n\n  return {\n    type: 'column-target',\n    column: renderFields(target.fields, relations),\n  }\n}\n\nfunction processExpression(target: A_Expr, relations: Relations): ColumnTarget {\n  try {\n    return processJsonTarget(target, relations)\n  } catch (err) {\n    const maybeJsonHint =\n      err instanceof Error && err.message === 'Invalid JSON path'\n        ? 'Did you forget to quote a JSON path?'\n        : undefined\n    throw new UnsupportedError(`Expressions not supported as targets`, maybeJsonHint)\n  }\n}\n\nfunction processFunctionCall(target: FuncCall, relations: Relations): AggregateTarget {\n  if (!target.funcname) {\n    throw new UnsupportedError('Aggregate function must have a name')\n  }\n\n  const functionName = renderFields(target.funcname, relations)\n\n  if (!supportedAggregateFunctions.includes(functionName)) {\n    throw new UnsupportedError(\n      `Only the following aggregate functions are supported: ${JSON.stringify(supportedAggregateFunctions)}`\n    )\n  }\n\n  // The `count(*)` special case that has no columns attached\n  if (functionName === 'count' && !target.args && target.agg_star) {\n    return {\n      type: 'aggregate-target',\n      functionName,\n    }\n  }\n\n  if (!target.args) {\n    throw new UnsupportedError(`Aggregate function '${functionName}' requires a column argument`)\n  }\n\n  if (target.args && target.args.length > 1) {\n    throw new UnsupportedError(`Aggregate functions only accept one argument`)\n  }\n\n  const [arg] = target.args\n\n  if (!arg) {\n    throw new UnsupportedError(`Aggregate function '${functionName}' requires a column argument`)\n  }\n\n  const nestedTarget = processTarget(arg, relations)\n\n  if (nestedTarget.type === 'aggregate-target') {\n    throw new UnsupportedError(`Aggregate functions cannot contain another function`)\n  }\n\n  const { cast, ...columnTarget } = nestedTarget\n\n  return {\n    ...columnTarget,\n    type: 'aggregate-target',\n    functionName,\n    inputCast: cast,\n  }\n}\n","/**\n * @class TemplateTag\n * @classdesc Consumes a pipeline of composable transformer plugins and produces a template tag.\n */\nexport default class TemplateTag {\n  /**\n   * constructs a template tag\n   * @constructs TemplateTag\n   * @param  {...Object} [...transformers] - an array or arguments list of transformers\n   * @return {Function}                    - a template tag\n   */\n  constructor(...transformers) {\n    // if first argument is an array, extrude it as a list of transformers\n    if (transformers.length > 0 && Array.isArray(transformers[0])) {\n      transformers = transformers[0];\n    }\n\n    // if any transformers are functions, this means they are not initiated - automatically initiate them\n    this.transformers = transformers.map(transformer => {\n      return typeof transformer === 'function' ? transformer() : transformer;\n    });\n\n    // return an ES2015 template tag\n    return this.tag;\n  }\n\n  /**\n   * Applies all transformers to a template literal tagged with this method.\n   * If a function is passed as the first argument, assumes the function is a template tag\n   * and applies it to the template, returning a template tag.\n   * @param  {(Function|String|Array<String>)} strings        - Either a template tag or an array containing template strings separated by identifier\n   * @param  {...*}                            ...expressions - Optional list of substitution values.\n   * @return {(String|Function)}                              - Either an intermediary tag function or the results of processing the template.\n   */\n  tag = (strings, ...expressions) => {\n    if (typeof strings === 'function') {\n      // if the first argument passed is a function, assume it is a template tag and return\n      // an intermediary tag that processes the template using the aforementioned tag, passing the\n      // result to our tag\n      return this.interimTag.bind(this, strings);\n    }\n\n    if (typeof strings === 'string') {\n      // if the first argument passed is a string, just transform it\n      return this.transformEndResult(strings);\n    }\n\n    // else, return a transformed end result of processing the template with our tag\n    strings = strings.map(this.transformString.bind(this));\n    return this.transformEndResult(\n      strings.reduce(this.processSubstitutions.bind(this, expressions)),\n    );\n  };\n\n  /**\n   * An intermediary template tag that receives a template tag and passes the result of calling the template with the received\n   * template tag to our own template tag.\n   * @param  {Function}        nextTag          - the received template tag\n   * @param  {Array<String>}   template         - the template to process\n   * @param  {...*}            ...substitutions - `substitutions` is an array of all substitutions in the template\n   * @return {*}                                - the final processed value\n   */\n  interimTag(previousTag, template, ...substitutions) {\n    return this.tag`${previousTag(template, ...substitutions)}`;\n  }\n\n  /**\n   * Performs bulk processing on the tagged template, transforming each substitution and then\n   * concatenating the resulting values into a string.\n   * @param  {Array<*>} substitutions - an array of all remaining substitutions present in this template\n   * @param  {String}   resultSoFar   - this iteration's result string so far\n   * @param  {String}   remainingPart - the template chunk after the current substitution\n   * @return {String}                 - the result of joining this iteration's processed substitution with the result\n   */\n  processSubstitutions(substitutions, resultSoFar, remainingPart) {\n    const substitution = this.transformSubstitution(\n      substitutions.shift(),\n      resultSoFar,\n    );\n    return ''.concat(resultSoFar, substitution, remainingPart);\n  }\n\n  /**\n   * Iterate through each transformer, applying the transformer's `onString` method to the template\n   * strings before all substitutions are processed.\n   * @param {String}  str - The input string\n   * @return {String}     - The final results of processing each transformer\n   */\n  transformString(str) {\n    const cb = (res, transform) =>\n      transform.onString ? transform.onString(res) : res;\n    return this.transformers.reduce(cb, str);\n  }\n\n  /**\n   * When a substitution is encountered, iterates through each transformer and applies the transformer's\n   * `onSubstitution` method to the substitution.\n   * @param  {*}      substitution - The current substitution\n   * @param  {String} resultSoFar  - The result up to and excluding this substitution.\n   * @return {*}                   - The final result of applying all substitution transformations.\n   */\n  transformSubstitution(substitution, resultSoFar) {\n    const cb = (res, transform) =>\n      transform.onSubstitution\n        ? transform.onSubstitution(res, resultSoFar)\n        : res;\n    return this.transformers.reduce(cb, substitution);\n  }\n\n  /**\n   * Iterates through each transformer, applying the transformer's `onEndResult` method to the\n   * template literal after all substitutions have finished processing.\n   * @param  {String} endResult - The processed template, just before it is returned from the tag\n   * @return {String}           - The final results of processing each transformer\n   */\n  transformEndResult(endResult) {\n    const cb = (res, transform) =>\n      transform.onEndResult ? transform.onEndResult(res) : res;\n    return this.transformers.reduce(cb, endResult);\n  }\n}\n","/**\n * TemplateTag transformer that trims whitespace on the end result of a tagged template\n * @param  {String} side = '' - The side of the string to trim. Can be 'start' or 'end' (alternatively 'left' or 'right')\n * @return {Object}           - a TemplateTag transformer\n */\nconst trimResultTransformer = (side = '') => ({\n  onEndResult(endResult) {\n    if (side === '') {\n      return endResult.trim();\n    }\n\n    side = side.toLowerCase();\n\n    if (side === 'start' || side === 'left') {\n      return endResult.replace(/^\\s*/, '');\n    }\n\n    if (side === 'end' || side === 'right') {\n      return endResult.replace(/\\s*$/, '');\n    }\n\n    throw new Error(`Side not supported: ${side}`);\n  },\n});\n\nexport default trimResultTransformer;\n","/**\n * strips indentation from a template literal\n * @param  {String} type = 'initial' - whether to remove all indentation or just leading indentation. can be 'all' or 'initial'\n * @return {Object}                  - a TemplateTag transformer\n */\nconst stripIndentTransformer = (type = 'initial') => ({\n  onEndResult(endResult) {\n    if (type === 'initial') {\n      // remove the shortest leading indentation from each line\n      const match = endResult.match(/^[^\\S\\n]*(?=\\S)/gm);\n      const indent = match && Math.min(...match.map(el => el.length));\n      if (indent) {\n        const regexp = new RegExp(`^.{${indent}}`, 'gm');\n        return endResult.replace(regexp, '');\n      }\n      return endResult;\n    }\n    if (type === 'all') {\n      // remove all indentation from each line\n      return endResult.replace(/^[^\\S\\n]+/gm, '');\n    }\n    throw new Error(`Unknown type: ${type}`);\n  },\n});\n\nexport default stripIndentTransformer;\n","/**\n * Replaces tabs, newlines and spaces with the chosen value when they occur in sequences\n * @param  {(String|RegExp)} replaceWhat - the value or pattern that should be replaced\n * @param  {*}               replaceWith - the replacement value\n * @return {Object}                      - a TemplateTag transformer\n */\nconst replaceResultTransformer = (replaceWhat, replaceWith) => ({\n  onEndResult(endResult) {\n    if (replaceWhat == null || replaceWith == null) {\n      throw new Error(\n        'replaceResultTransformer requires at least 2 arguments.',\n      );\n    }\n    return endResult.replace(replaceWhat, replaceWith);\n  },\n});\n\nexport default replaceResultTransformer;\n","const replaceSubstitutionTransformer = (replaceWhat, replaceWith) => ({\n  onSubstitution(substitution, resultSoFar) {\n    if (replaceWhat == null || replaceWith == null) {\n      throw new Error(\n        'replaceSubstitutionTransformer requires at least 2 arguments.',\n      );\n    }\n\n    // Do not touch if null or undefined\n    if (substitution == null) {\n      return substitution;\n    } else {\n      return substitution.toString().replace(replaceWhat, replaceWith);\n    }\n  },\n});\n\nexport default replaceSubstitutionTransformer;\n","const defaults = {\n  separator: '',\n  conjunction: '',\n  serial: false,\n};\n\n/**\n * Converts an array substitution to a string containing a list\n * @param  {String} [opts.separator = ''] - the character that separates each item\n * @param  {String} [opts.conjunction = '']  - replace the last separator with this\n * @param  {Boolean} [opts.serial = false] - include the separator before the conjunction? (Oxford comma use-case)\n *\n * @return {Object}                     - a TemplateTag transformer\n */\nconst inlineArrayTransformer = (opts = defaults) => ({\n  onSubstitution(substitution, resultSoFar) {\n    // only operate on arrays\n    if (Array.isArray(substitution)) {\n      const arrayLength = substitution.length;\n      const separator = opts.separator;\n      const conjunction = opts.conjunction;\n      const serial = opts.serial;\n      // join each item in the array into a string where each item is separated by separator\n      // be sure to maintain indentation\n      const indent = resultSoFar.match(/(\\n?[^\\S\\n]+)$/);\n      if (indent) {\n        substitution = substitution.join(separator + indent[1]);\n      } else {\n        substitution = substitution.join(separator + ' ');\n      }\n      // if conjunction is set, replace the last separator with conjunction, but only if there is more than one substitution\n      if (conjunction && arrayLength > 1) {\n        const separatorIndex = substitution.lastIndexOf(separator);\n        substitution =\n          substitution.slice(0, separatorIndex) +\n          (serial ? separator : '') +\n          ' ' +\n          conjunction +\n          substitution.slice(separatorIndex + 1);\n      }\n    }\n    return substitution;\n  },\n});\n\nexport default inlineArrayTransformer;\n","const splitStringTransformer = splitBy => ({\n  onSubstitution(substitution, resultSoFar) {\n    if (splitBy != null && typeof splitBy === 'string') {\n      if (typeof substitution === 'string' && substitution.includes(splitBy)) {\n        substitution = substitution.split(splitBy);\n      }\n    } else {\n      throw new Error('You need to specify a string character to split by.');\n    }\n    return substitution;\n  },\n});\n\nexport default splitStringTransformer;\n","const isValidValue = x =>\n  x != null && !Number.isNaN(x) && typeof x !== 'boolean';\n\nconst removeNonPrintingValuesTransformer = () => ({\n  onSubstitution(substitution) {\n    if (Array.isArray(substitution)) {\n      return substitution.filter(isValidValue);\n    }\n    if (isValidValue(substitution)) {\n      return substitution;\n    }\n    return '';\n  },\n});\n\nexport default removeNonPrintingValuesTransformer;\n","import TemplateTag from '../TemplateTag';\nimport stripIndentTransformer from '../stripIndentTransformer';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\n\nconst commaLists = new TemplateTag(\n  inlineArrayTransformer({ separator: ',' }),\n  stripIndentTransformer,\n  trimResultTransformer,\n);\n\nexport default commaLists;\n","import TemplateTag from '../TemplateTag';\nimport stripIndentTransformer from '../stripIndentTransformer';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\n\nconst commaListsAnd = new TemplateTag(\n  inlineArrayTransformer({ separator: ',', conjunction: 'and' }),\n  stripIndentTransformer,\n  trimResultTransformer,\n);\n\nexport default commaListsAnd;\n","import TemplateTag from '../TemplateTag';\nimport stripIndentTransformer from '../stripIndentTransformer';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\n\nconst commaListsOr = new TemplateTag(\n  inlineArrayTransformer({ separator: ',', conjunction: 'or' }),\n  stripIndentTransformer,\n  trimResultTransformer,\n);\n\nexport default commaListsOr;\n","import TemplateTag from '../TemplateTag';\nimport stripIndentTransformer from '../stripIndentTransformer';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\nimport splitStringTransformer from '../splitStringTransformer';\nimport removeNonPrintingValuesTransformer from '../removeNonPrintingValuesTransformer';\n\nconst html = new TemplateTag(\n  splitStringTransformer('\\n'),\n  removeNonPrintingValuesTransformer,\n  inlineArrayTransformer,\n  stripIndentTransformer,\n  trimResultTransformer,\n);\n\nexport default html;\n","import TemplateTag from '../TemplateTag';\nimport stripIndentTransformer from '../stripIndentTransformer';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\nimport splitStringTransformer from '../splitStringTransformer';\nimport replaceSubstitutionTransformer from '../replaceSubstitutionTransformer';\n\nconst safeHtml = new TemplateTag(\n  splitStringTransformer('\\n'),\n  inlineArrayTransformer,\n  stripIndentTransformer,\n  trimResultTransformer,\n  replaceSubstitutionTransformer(/&/g, '&amp;'),\n  replaceSubstitutionTransformer(/</g, '&lt;'),\n  replaceSubstitutionTransformer(/>/g, '&gt;'),\n  replaceSubstitutionTransformer(/\"/g, '&quot;'),\n  replaceSubstitutionTransformer(/'/g, '&#x27;'),\n  replaceSubstitutionTransformer(/`/g, '&#x60;'),\n);\n\nexport default safeHtml;\n","import TemplateTag from '../TemplateTag';\nimport trimResultTransformer from '../trimResultTransformer';\nimport replaceResultTransformer from '../replaceResultTransformer';\n\nconst oneLine = new TemplateTag(\n  replaceResultTransformer(/(?:\\n(?:\\s*))+/g, ' '),\n  trimResultTransformer,\n);\n\nexport default oneLine;\n","import TemplateTag from '../TemplateTag';\nimport trimResultTransformer from '../trimResultTransformer';\nimport replaceResultTransformer from '../replaceResultTransformer';\n\nconst oneLineTrim = new TemplateTag(\n  replaceResultTransformer(/(?:\\n\\s*)/g, ''),\n  trimResultTransformer,\n);\n\nexport default oneLineTrim;\n","import TemplateTag from '../TemplateTag';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\nimport replaceResultTransformer from '../replaceResultTransformer';\n\nconst oneLineCommaLists = new TemplateTag(\n  inlineArrayTransformer({ separator: ',' }),\n  replaceResultTransformer(/(?:\\s+)/g, ' '),\n  trimResultTransformer,\n);\n\nexport default oneLineCommaLists;\n","import TemplateTag from '../TemplateTag';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\nimport replaceResultTransformer from '../replaceResultTransformer';\n\nconst oneLineCommaListsOr = new TemplateTag(\n  inlineArrayTransformer({ separator: ',', conjunction: 'or' }),\n  replaceResultTransformer(/(?:\\s+)/g, ' '),\n  trimResultTransformer,\n);\n\nexport default oneLineCommaListsOr;\n","import TemplateTag from '../TemplateTag';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\nimport replaceResultTransformer from '../replaceResultTransformer';\n\nconst oneLineCommaListsAnd = new TemplateTag(\n  inlineArrayTransformer({ separator: ',', conjunction: 'and' }),\n  replaceResultTransformer(/(?:\\s+)/g, ' '),\n  trimResultTransformer,\n);\n\nexport default oneLineCommaListsAnd;\n","import TemplateTag from '../TemplateTag';\nimport stripIndentTransformer from '../stripIndentTransformer';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\n\nconst inlineLists = new TemplateTag(\n  inlineArrayTransformer,\n  stripIndentTransformer,\n  trimResultTransformer,\n);\n\nexport default inlineLists;\n","import TemplateTag from '../TemplateTag';\nimport inlineArrayTransformer from '../inlineArrayTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\nimport replaceResultTransformer from '../replaceResultTransformer';\n\nconst oneLineInlineLists = new TemplateTag(\n  inlineArrayTransformer,\n  replaceResultTransformer(/(?:\\s+)/g, ' '),\n  trimResultTransformer,\n);\n\nexport default oneLineInlineLists;\n","import TemplateTag from '../TemplateTag';\nimport stripIndentTransformer from '../stripIndentTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\n\nconst stripIndent = new TemplateTag(\n  stripIndentTransformer,\n  trimResultTransformer,\n);\n\nexport default stripIndent;\n","import TemplateTag from '../TemplateTag';\nimport stripIndentTransformer from '../stripIndentTransformer';\nimport trimResultTransformer from '../trimResultTransformer';\n\nconst stripIndents = new TemplateTag(\n  stripIndentTransformer('all'),\n  trimResultTransformer,\n);\n\nexport default stripIndents;\n","import type { Filter, Target } from '../processor/index.js'\n\n// TODO: format multiline targets downstream instead of here\nexport function renderTargets(\n  targets: Target[],\n  multiline?: { initialIndent: number; indent: number }\n) {\n  const indentation = multiline ? ' '.repeat(multiline.initialIndent) : ''\n  const maybeNewline = multiline ? '\\n' : ''\n\n  return targets\n    .map((target) => {\n      // Regular columns\n      if (target.type === 'column-target') {\n        const { column, alias, cast } = target\n        let value = column\n\n        if (alias && alias !== column) {\n          value = `${alias}:${value}`\n        }\n\n        if (cast) {\n          value = `${value}::${cast}`\n        }\n\n        value = `${indentation}${value}`\n\n        return value\n      }\n      // Special case for `count()` that has no column attached\n      else if (target.type === 'aggregate-target' && !('column' in target)) {\n        const { functionName, alias, outputCast } = target\n        let value = `${functionName}()`\n\n        if (alias) {\n          value = `${alias}:${value}`\n        }\n\n        if (outputCast) {\n          value = `${value}::${outputCast}`\n        }\n\n        value = `${indentation}${value}`\n\n        return value\n      }\n      // Aggregate functions\n      else if (target.type === 'aggregate-target') {\n        const { column, alias, functionName, inputCast, outputCast } = target\n        let value = column\n\n        if (alias && alias !== column) {\n          value = `${alias}:${value}`\n        }\n\n        if (inputCast) {\n          value = `${value}::${inputCast}`\n        }\n\n        value = `${value}.${functionName}()`\n\n        if (outputCast) {\n          value = `${value}::${outputCast}`\n        }\n\n        value = `${indentation}${value}`\n\n        return value\n      }\n      // Resource embeddings (joined tables)\n      else if (target.type === 'embedded-target') {\n        const { relation, alias, joinType, targets, flatten } = target\n        let value = relation\n\n        if (joinType === 'inner') {\n          value = `${value}!inner`\n        }\n\n        // Resource embeddings can't have aliases when they're spread (flattened)\n        if (alias && alias !== relation && !flatten) {\n          value = `${alias}:${value}`\n        }\n\n        if (flatten) {\n          value = `...${value}`\n        }\n\n        if (targets.length > 0) {\n          value = `${indentation}${value}(${maybeNewline}${renderTargets(targets, multiline ? { ...multiline, initialIndent: multiline.initialIndent + multiline.indent } : undefined)}${maybeNewline}${indentation})`\n        } else {\n          value = `${indentation}${value}()`\n        }\n\n        return value\n      }\n    })\n    .join(',' + maybeNewline)\n}\n\n/**\n * Renders a filter in PostgREST syntax.\n *\n * @returns A key-value pair that can be used either directly\n * in query params (for HTTP rendering), or to render nested\n * filters (@see `renderNestedFilter`).\n */\nexport function renderFilter(\n  filter: Filter,\n  urlSafe: boolean = true,\n  delimiter = ','\n): [key: string, value: string] {\n  const { type } = filter\n  const maybeNot = filter.negate ? 'not.' : ''\n\n  // Column filter, eg. \"title.eq.Cheese\"\n  if (type === 'column') {\n    if (filter.operator === 'like' || filter.operator === 'ilike') {\n      // Optionally convert '%' to URL-safe '*'\n      const value = urlSafe ? filter.value.replaceAll('%', '*') : filter.value\n\n      return [filter.column, `${maybeNot}${filter.operator}.${value}`]\n    } else if (filter.operator === 'in') {\n      const value = filter.value\n        .map((value) => {\n          // If an 'in' value contains a comma, wrap in double quotes\n          if (value.toString().includes(',')) {\n            return `\"${value}\"`\n          }\n          return value\n        })\n        .join(',')\n      return [filter.column, `${maybeNot}${filter.operator}.(${value})`]\n    } else if (\n      filter.operator === 'fts' ||\n      filter.operator === 'plfts' ||\n      filter.operator === 'phfts' ||\n      filter.operator === 'wfts'\n    ) {\n      const maybeConfig = filter.config ? `(${filter.config})` : ''\n      return [filter.column, `${maybeNot}${filter.operator}${maybeConfig}.${filter.value}`]\n    } else {\n      return [filter.column, `${maybeNot}${filter.operator}.${filter.value}`]\n    }\n  }\n  // Logical operator filter, eg. \"or(title.eq.Cheese,title.eq.Salsa)\"\"\n  else if (type === 'logical') {\n    return [\n      `${maybeNot}${filter.operator}`,\n      `(${filter.values\n        .map((subFilter) => renderNestedFilter(subFilter, urlSafe, delimiter))\n        .join(delimiter)})`,\n    ]\n  } else {\n    throw new Error(`Unknown filter type '${type}'`)\n  }\n}\n\n/**\n * Renders a filter in PostgREST syntax with key-values combined\n * for use within a nested filter.\n *\n * @returns A string containing the nested filter.\n */\nexport function renderNestedFilter(filter: Filter, urlSafe: boolean = true, delimiter = ',') {\n  const [key, value] = renderFilter(filter, urlSafe, delimiter)\n  const { type } = filter\n\n  if (type === 'column') {\n    return `${key}.${value}`\n  } else if (type === 'logical') {\n    return `${key}${value}`\n  } else {\n    throw new Error(`Unknown filter type '${type}'`)\n  }\n}\n\nexport const defaultCharacterWhitelist = ['*', '(', ')', ',', ':', '!', '>', '-', '[', ']']\n\n/**\n * URI encodes query parameters with an optional character whitelist\n * that should not be encoded.\n */\nexport function uriEncodeParams(\n  params: URLSearchParams,\n  characterWhitelist: string[] = defaultCharacterWhitelist\n) {\n  return uriDecodeCharacters(params.toString(), characterWhitelist)\n}\n\n/**\n * URI encodes a string with an optional character whitelist\n * that should not be encoded.\n */\nexport function uriEncode(value: string, characterWhitelist: string[] = defaultCharacterWhitelist) {\n  return uriDecodeCharacters(encodeURIComponent(value), characterWhitelist)\n}\n\nfunction uriDecodeCharacters(value: string, characterWhitelist: string[]) {\n  let newValue = value\n\n  // Convert whitelisted characters back from their hex representation (eg. '%2A' -> '*')\n  for (const char of characterWhitelist) {\n    const hexCode = char.charCodeAt(0).toString(16).toUpperCase()\n    newValue = newValue.replaceAll(`%${hexCode}`, char)\n  }\n\n  return newValue\n}\n","import { stripIndent } from 'common-tags'\nimport { RenderError } from '../errors.js'\nimport type { Filter, Select, Statement } from '../processor/index.js'\nimport { renderFilter, renderTargets, uriEncode, uriEncodeParams } from './util.js'\n\nexport type HttpRequest = {\n  method: 'GET'\n  path: string\n  params: URLSearchParams\n  fullPath: string\n}\n\n/**\n * Renders a `Statement` as an HTTP request.\n */\nexport async function renderHttp(processed: Statement): Promise<HttpRequest> {\n  switch (processed.type) {\n    case 'select':\n      return formatSelect(processed)\n    default:\n      throw new RenderError(`Unsupported statement type '${processed.type}'`, 'http')\n  }\n}\n\nasync function formatSelect(select: Select): Promise<HttpRequest> {\n  const { from, targets, filter, sorts, limit } = select\n  const params = new URLSearchParams()\n\n  if (targets.length > 0) {\n    const [firstTarget] = targets\n\n    // Exclude \"select=*\" if it's the only target\n    if (\n      firstTarget!.type !== 'column-target' ||\n      firstTarget!.column !== '*' ||\n      targets.length !== 1\n    ) {\n      params.set('select', renderTargets(targets))\n    }\n  }\n\n  if (filter) {\n    renderFilterRoot(params, filter)\n  }\n\n  if (sorts) {\n    const columns = []\n\n    for (const sort of sorts) {\n      let value = sort.column\n\n      if (sort.direction) {\n        value += `.${sort.direction}`\n      }\n      if (sort.nulls) {\n        value += `.nulls${sort.nulls}`\n      }\n\n      columns.push(value)\n    }\n\n    if (columns.length > 0) {\n      params.set('order', columns.join(','))\n    }\n  }\n\n  if (limit) {\n    if (limit.count !== undefined) {\n      params.set('limit', limit.count.toString())\n    }\n    if (limit.offset !== undefined) {\n      params.set('offset', limit.offset.toString())\n    }\n  }\n\n  const path = `/${from}`\n\n  return {\n    method: 'GET',\n    path,\n    params,\n    get fullPath() {\n      // params.size not available in older runtimes\n      if (Array.from(params).length > 0) {\n        return `${path}?${uriEncodeParams(params)}`\n      }\n      return path\n    },\n  }\n}\n\nfunction renderFilterRoot(params: URLSearchParams, filter: Filter) {\n  const { type } = filter\n\n  // The `and` operator is a special case where we can format each nested\n  // filter as a separate query param as long as the `and` is not negated\n  if (type === 'logical' && filter.operator === 'and' && !filter.negate) {\n    for (const subFilter of filter.values) {\n      renderFilterRoot(params, subFilter)\n    }\n  }\n  // Otherwise render as normal\n  else {\n    const [key, value] = renderFilter(filter)\n    params.append(key, value)\n  }\n}\n\nexport function formatHttp(baseUrl: string, httpRequest: HttpRequest) {\n  const { method, fullPath } = httpRequest\n  const baseUrlObject = new URL(baseUrl)\n\n  return stripIndent`\n    ${method} ${baseUrlObject.pathname}${fullPath} HTTP/1.1\n    Host: ${baseUrlObject.host}\n  `\n}\n\nexport function formatCurl(baseUrl: string, httpRequest: HttpRequest) {\n  const { method, path, params } = httpRequest\n  const lines: string[] = []\n  const baseUrlObject = new URL(baseUrl)\n  const formattedBaseUrl = (baseUrlObject.origin + baseUrlObject.pathname).replace(/\\/+$/, '')\n  const maybeGFlag = params.size > 0 ? '-G ' : ''\n\n  if (method === 'GET') {\n    lines.push(`curl ${maybeGFlag}${formattedBaseUrl}${path}`)\n    for (const [key, value] of params) {\n      lines.push(`  -d \"${uriEncode(key)}=${uriEncode(value)}\"`)\n    }\n  }\n\n  return lines.join(' \\\\\\n')\n}\n","import type { Plugin } from 'prettier'\nimport * as babel from 'prettier/plugins/babel'\nimport * as estree from 'prettier/plugins/estree'\nimport * as prettier from 'prettier/standalone'\nimport { RenderError } from '../errors.js'\nimport type { Filter, Select, Statement } from '../processor/index.js'\nimport { renderNestedFilter, renderTargets } from './util.js'\n\nexport type SupabaseJsQuery = {\n  code: string\n}\n\n/**\n * Renders a `Statement` as a supabase-js query.\n */\nexport async function renderSupabaseJs(processed: Statement): Promise<SupabaseJsQuery> {\n  switch (processed.type) {\n    case 'select':\n      return formatSelect(processed)\n    default:\n      throw new RenderError(`Unsupported statement type '${processed.type}'`, 'supabase-js')\n  }\n}\n\nasync function formatSelect(select: Select): Promise<SupabaseJsQuery> {\n  const { from, targets, filter, sorts, limit } = select\n  const lines = ['const { data, error } = await supabase', `.from('${from}')`]\n\n  if (targets.length > 0) {\n    const [firstTarget] = targets\n\n    // Remove '*' from select() if it's the only target\n    if (\n      firstTarget!.type === 'column-target' &&\n      firstTarget!.column === '*' &&\n      targets.length === 1\n    ) {\n      lines.push('.select()')\n    } else if (targets.length > 1) {\n      lines.push(\n        `.select(\\n    \\`\\n${renderTargets(targets, { initialIndent: 4, indent: 2 })}\\n    \\`\\n )`\n      )\n    } else {\n      lines.push(`.select(${JSON.stringify(renderTargets(targets))})`)\n    }\n  }\n\n  if (filter) {\n    renderFilterRoot(lines, filter)\n  }\n\n  if (sorts) {\n    for (const sort of sorts) {\n      if (!sort.direction && !sort.nulls) {\n        lines.push(`.order(${JSON.stringify(sort.column)})`)\n      } else {\n        const options = {\n          ascending: sort.direction ? sort.direction === 'asc' : undefined,\n          nullsFirst: sort.nulls ? sort.nulls === 'first' : undefined,\n        }\n\n        lines.push(`.order(${JSON.stringify(sort.column)}, ${JSON.stringify(options)})`)\n      }\n    }\n  }\n\n  if (limit) {\n    if (limit.count !== undefined && limit.offset === undefined) {\n      lines.push(`.limit(${limit.count})`)\n    } else if (limit.count === undefined && limit.offset !== undefined) {\n      throw new RenderError(`supabase-js doesn't support an offset without a limit`, 'supabase-js')\n    } else if (limit.count !== undefined && limit.offset !== undefined) {\n      lines.push(`.range(${limit.offset}, ${limit.offset + limit.count})`)\n    }\n  }\n\n  // Join lines together and format\n  const code = await prettier.format(lines.join('\\n'), {\n    parser: 'babel',\n    plugins: [babel, estree as Plugin],\n    printWidth: 40,\n    semi: false,\n    singleQuote: true,\n    trailingComma: 'all',\n  })\n\n  return {\n    code: code.trim(),\n  }\n}\n\nfunction renderFilterRoot(lines: string[], filter: Filter) {\n  const { type } = filter\n\n  if (filter.negate) {\n    if (filter.type === 'column') {\n      // Full-text search operators can have an optional config arg\n      if (\n        filter.operator === 'fts' ||\n        filter.operator === 'plfts' ||\n        filter.operator === 'phfts' ||\n        filter.operator === 'wfts'\n      ) {\n        const maybeConfig = filter.config ? `(${filter.config})` : ''\n        lines.push(\n          `.not(${JSON.stringify(filter.column)}, ${JSON.stringify(`${filter.operator}${maybeConfig}`)}, ${JSON.stringify(filter.value)})`\n        )\n      } else {\n        lines.push(\n          `.not(${JSON.stringify(filter.column)}, ${JSON.stringify(filter.operator)}, ${JSON.stringify(filter.value)})`\n        )\n      }\n    }\n    // supabase-js doesn't support negated logical operators.\n    // We work around this by wrapping the filter in an 'or'\n    // with only 1 value (so the 'or' is a no-op, but we get nested PostgREST syntax)\n    else if (filter.type === 'logical') {\n      lines.push(`.or(${JSON.stringify(renderNestedFilter(filter, false, ', '))})`)\n    }\n    return\n  }\n\n  // Column filter, eg. .eq('title', 'Cheese')\n  if (type === 'column') {\n    if (\n      filter.operator === 'fts' ||\n      filter.operator === 'plfts' ||\n      filter.operator === 'phfts' ||\n      filter.operator === 'wfts'\n    ) {\n      const maybeOptions =\n        filter.operator !== 'fts' || filter.config !== undefined\n          ? `, ${JSON.stringify({\n              type: mapTextSearchType(filter.operator),\n              config: filter.config,\n            })}`\n          : ''\n\n      lines.push(\n        `.textSearch(${JSON.stringify(filter.column)}, ${JSON.stringify(filter.value)}${maybeOptions})`\n      )\n    } else {\n      lines.push(\n        `.${filter.operator}(${JSON.stringify(filter.column)}, ${JSON.stringify(filter.value)})`\n      )\n    }\n  }\n\n  // Logical operator filter, eg. .or('title.eq.Cheese,title.eq.Salsa')\n  else if (type === 'logical') {\n    // The `and` operator is a a special case where we can format each nested\n    // filter as a separate filter method\n    if (filter.operator === 'and') {\n      for (const subFilter of filter.values) {\n        renderFilterRoot(lines, subFilter)\n      }\n    }\n    // Otherwise use the .or(...) method\n    else if (filter.operator === 'or') {\n      lines.push(\n        `.or(${JSON.stringify(\n          filter.values.map((subFilter) => renderNestedFilter(subFilter, false, ', ')).join(', ')\n        )})`\n      )\n    }\n  } else {\n    throw new RenderError(`Unknown filter type '${type}'`, 'supabase-js')\n  }\n}\n\nfunction mapTextSearchType(operator: 'fts' | 'plfts' | 'phfts' | 'wfts') {\n  switch (operator) {\n    case 'plfts':\n      return 'plain'\n    case 'phfts':\n      return 'phrase'\n    case 'wfts':\n      return 'websearch'\n    default:\n      return undefined\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","ParsingError","RenderError","UnimplementedError","UnsupportedError","everyTarget","flattenTargets","formatCurl","formatHttp","getParsingErrorHint","processSql","renderHttp","renderSupabaseJs","sentenceCase","someFilter","someTarget","supportedAggregateFunctions","__toCommonJS","ParsingError","message","hint","sentenceCase","UnimplementedError","UnsupportedError","RenderError","renderer","value","getParsingErrorHint","import_pg_parser","processJsonTarget","expression","relations","UnsupportedError","name","operator","cast","left","right","parseConstant","column","renderFields","renderDataType","n","fields","syntax","nameSegments","field","internalType","relationOrAliasName","columnName","joinedRelation","t","joinedRelationName","qualifiedName","names","first","rest","constant","flattenTargets","targets","target","type","someFilter","filter","predicate","f","everyTarget","parent","someTarget","validateGroupClause","groupClause","targets","relations","groupByColumns","columnRef","UnsupportedError","renderFields","column","someTarget","target","parent","everyTarget","qualifiedName","processWhereClause","expression","relations","column","UnsupportedError","kind","name","operatorSymbol","operator","mapOperatorSymbol","processJsonTarget","fields","renderFields","functionName","arg","value","parseConstant","leftValue","rightValue","item","temp","leftFilter","rightFilter","supportedTextSearchFunctions","args","config","query","mapTextSearchFunction","negate","values","filter","processLimit","selectStmt","count","offset","UnsupportedError","processSortClause","sorts","relations","sortBy","column","UnsupportedError","processJsonTarget","fields","renderFields","direction","mapSortByDirection","nulls","mapSortByNulls","supportedAggregateFunctions","processSelectStatement","stmt","UnsupportedError","fromClause","relations","processFromClause","from","targetList","node","targets","processTargetList","groupByColumns","validateGroupClause","filter","processWhereClause","sortByColumns","sortBy","sorts","processSortClause","limit","processLimit","joinType","mapJoinType","primary","joined","joinedRelation","existingRelations","t","leftQualifierRelation","rightQualifierRelation","joinQualifierExpression","field","leftColumnFields","leftRelationName","leftColumnName","rightColumnFields","rightRelationName","rightColumnName","qualifierOperatorString","left","right","embeddedTarget","fieldType","columnTargets","resTarget","target","processTarget","qualifiedName","relationName","columnName","nestedEmbeddedTargets","output","parent","processCast","processColumn","processExpression","processFunctionCall","names","name","cast","renderDataType","nestedTarget","type","renderFields","processJsonTarget","err","maybeJsonHint","functionName","arg","columnTarget","parser","processSql","sql","result","UnsupportedError","statement","stmt","processStatement","err","hint","getParsingErrorHint","parsingError","ParsingError","processSelectStatement","UnimplementedError","stmtType","statementType","TemplateTag","_this","_len","transformers","_key","_classCallCheck","tag","strings","_len2","expressions","_key2","interimTag","bind","transformEndResult","map","transformString","reduce","processSubstitutions","length","Array","isArray","transformer","previousTag","template","_len3","substitutions","_key3","_templateObject","resultSoFar","remainingPart","substitution","transformSubstitution","shift","concat","str","cb","res","transform","onString","onSubstitution","endResult","onEndResult","trimResultTransformer","side","onEndResult","endResult","trim","toLowerCase","replace","Error","trimResultTransformer_default","stripIndentTransformer","type","onEndResult","endResult","match","indent","Math","min","_toConsumableArray","map","el","length","regexp","RegExp","replace","Error","stripIndentTransformer_default","replaceResultTransformer","replaceWhat","replaceWith","onEndResult","endResult","Error","replace","replaceResultTransformer_default","replaceSubstitutionTransformer","replaceWhat","replaceWith","onSubstitution","substitution","resultSoFar","Error","toString","replace","replaceSubstitutionTransformer_default","defaults","separator","conjunction","serial","inlineArrayTransformer","opts","onSubstitution","substitution","resultSoFar","Array","isArray","arrayLength","length","indent","match","join","separatorIndex","lastIndexOf","slice","inlineArrayTransformer_default","splitStringTransformer","splitBy","onSubstitution","substitution","resultSoFar","includes","split","Error","splitStringTransformer_default","isValidValue","x","Number","isNaN","removeNonPrintingValuesTransformer","onSubstitution","substitution","Array","isArray","filter","removeNonPrintingValuesTransformer_default","commaLists","TemplateTag","inlineArrayTransformer","separator","stripIndentTransformer","trimResultTransformer","commaListsAnd","TemplateTag","inlineArrayTransformer","separator","conjunction","stripIndentTransformer","trimResultTransformer","commaListsOr","TemplateTag","inlineArrayTransformer","separator","conjunction","stripIndentTransformer","trimResultTransformer","html","TemplateTag","splitStringTransformer","removeNonPrintingValuesTransformer","inlineArrayTransformer","stripIndentTransformer","trimResultTransformer","safeHtml","TemplateTag","splitStringTransformer","inlineArrayTransformer","stripIndentTransformer","trimResultTransformer","replaceSubstitutionTransformer","oneLine","TemplateTag","replaceResultTransformer","trimResultTransformer","oneLineTrim","TemplateTag","replaceResultTransformer","trimResultTransformer","oneLineCommaLists","TemplateTag","inlineArrayTransformer","separator","replaceResultTransformer","trimResultTransformer","oneLineCommaListsOr","TemplateTag","inlineArrayTransformer","separator","conjunction","replaceResultTransformer","trimResultTransformer","oneLineCommaListsAnd","TemplateTag","inlineArrayTransformer","separator","conjunction","replaceResultTransformer","trimResultTransformer","inlineLists","TemplateTag","inlineArrayTransformer","stripIndentTransformer","trimResultTransformer","oneLineInlineLists","TemplateTag","inlineArrayTransformer","replaceResultTransformer","trimResultTransformer","stripIndent","TemplateTag","stripIndentTransformer","trimResultTransformer","stripIndent_default","stripIndents","TemplateTag","stripIndentTransformer","trimResultTransformer","renderTargets","targets","multiline","indentation","maybeNewline","target","column","alias","cast","value","functionName","outputCast","inputCast","relation","joinType","flatten","renderFilter","filter","urlSafe","delimiter","type","maybeNot","maybeConfig","subFilter","renderNestedFilter","key","defaultCharacterWhitelist","uriEncodeParams","params","characterWhitelist","uriDecodeCharacters","uriEncode","newValue","char","hexCode","renderHttp","processed","formatSelect","RenderError","select","from","targets","filter","sorts","limit","params","firstTarget","renderTargets","renderFilterRoot","columns","sort","value","path","uriEncodeParams","type","subFilter","key","renderFilter","formatHttp","baseUrl","httpRequest","method","fullPath","baseUrlObject","stripIndent_default","formatCurl","lines","formattedBaseUrl","maybeGFlag","uriEncode","babel","estree","prettier","renderSupabaseJs","processed","formatSelect","RenderError","select","from","targets","filter","sorts","limit","lines","firstTarget","renderTargets","renderFilterRoot","sort","options","babel","estree","type","maybeConfig","renderNestedFilter","maybeOptions","mapTextSearchType","subFilter","operator"]}