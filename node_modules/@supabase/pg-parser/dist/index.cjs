"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } var _class;// src/errors.ts
var ParseError = (_class = class extends Error {
  __init() {this.name = "ParseError"}
  /**
   * The type of parse error. Possible values are:
   *
   * - `syntax`: A lexical or syntactic error, such as mismatched parentheses,
   *   unterminated quotes, invalid tokens, or incorrect SQL statement structure.
   *   Most SQL errors will fall into this category.
   *
   * - `semantic`: These are rare, but can occur during specific validations like
   *   numeric range checking (e.g., column numbers must be between 1 and 32767
   *   in ALTER INDEX statements).
   *
   * - `unknown`: An unknown error type, typically representing an internal parser error.
   *
   * Note: The vast majority of semantic validation (type checking, schema validation,
   * constraint validation, etc.) happens after parsing and is not represented in these error types.
   */
  
  /**
   * The position of the error in the SQL string.
   * This is a zero-based index, so the first character is at position 0.
   * Points to the character where the error was detected.
   */
  
  constructor(message, { type, position }) {
    super(message);_class.prototype.__init.call(this);;
    this.type = type;
    this.position = position;
  }
}, _class);
function getParseErrorType(fileName) {
  switch (fileName) {
    case "scan.l":
      return "syntax";
    case "gram.y":
      return "semantic";
    default:
      return "unknown";
  }
}

// src/constants.ts
var SUPPORTED_VERSIONS = [15, 16, 17];

// src/util.ts
async function unwrapParseResult(result) {
  const resolved = await result;
  if (resolved.error) {
    throw resolved.error;
  }
  return resolved.tree;
}
function getSupportedVersions() {
  return SUPPORTED_VERSIONS;
}
function isSupportedVersion(version) {
  return SUPPORTED_VERSIONS.includes(version);
}
function isParseResultVersion(result, version) {
  if (!result.version) {
    return false;
  }
  const versionString = result.version.toString();
  try {
    const majorVersion = parseInt(versionString.slice(0, -4), 10);
    return majorVersion === version;
  } catch (error) {
    return false;
  }
}
function unwrapNode(wrappedNode) {
  const keys = Object.keys(wrappedNode);
  if (keys.length === 0) {
    throw new Error("node has no keys, expected a single key");
  }
  if (keys.length > 1) {
    throw new Error(
      `node has multiple keys, expected a single key: ${keys.join(", ")}`
    );
  }
  const [type] = keys;
  if (!type) {
    throw new Error("node has no keys, expected a single key");
  }
  const node = wrappedNode[type];
  return { type, node };
}

// src/pg-parser.ts
var PgParser = class {
  
  
  #module;
  /**
   * Creates a new PgParser instance with the given options.
   */
  constructor({ version = 17 } = {}) {
    if (!isSupportedVersion(version)) {
      throw new Error(`unsupported version: ${version}`);
    }
    this.#module = this.#init(version);
    this.ready = this.#module.then();
    this.version = version;
  }
  /**
   * Initializes the WASM module.
   */
  async #init(version) {
    const createModule = await this.#loadFactory(version);
    return await createModule();
  }
  /**
   * Loads the WASM module factory for the given version.
   *
   * Note we intentionally don't use template strings on a single import
   * statement to avoid bundling issues that occur during static analysis.
   */
  async #loadFactory(version) {
    switch (version) {
      case 15:
        return await Promise.resolve().then(() => _interopRequireWildcard(require("../wasm/15/pg-parser.js"))).then((module) => module.default);
      case 16:
        return await Promise.resolve().then(() => _interopRequireWildcard(require("../wasm/16/pg-parser.js"))).then((module) => module.default);
      case 17:
        return await Promise.resolve().then(() => _interopRequireWildcard(require("../wasm/17/pg-parser.js"))).then((module) => module.default);
      default:
        throw new Error(`unsupported version: ${version}`);
    }
  }
  /**
   * Parses the given SQL string to a Postgres AST.
   */
  async parse(sql) {
    const module = await this.#module;
    const sqlPtr = module._malloc(sql.length + 1);
    module.stringToUTF8(sql, sqlPtr, sql.length + 1);
    const resultPtr = module._parse_sql(sqlPtr);
    module._free(sqlPtr);
    const parseResult = await this.#parsePgQueryParseResult(resultPtr);
    module._free_parse_result(resultPtr);
    return parseResult;
  }
  /**
   * Parses a PgQueryParseResult struct from a pointer
   */
  async #parsePgQueryParseResult(resultPtr) {
    const module = await this.#module;
    const parseTreePtr = module.getValue(resultPtr, "i32");
    const stderrBufferPtr = module.getValue(resultPtr + 4, "i32");
    const errorPtr = module.getValue(resultPtr + 8, "i32");
    const tree = parseTreePtr ? JSON.parse(module.UTF8ToString(parseTreePtr)) : void 0;
    const stderrBuffer = stderrBufferPtr ? module.UTF8ToString(stderrBufferPtr) : void 0;
    const error = errorPtr ? await this.#parsePgQueryError(errorPtr) : void 0;
    if (error) {
      return {
        tree: void 0,
        error
      };
    }
    if (!tree) {
      throw new Error("both parse tree and error are undefined");
    }
    return {
      tree,
      error: void 0
    };
  }
  /**
   * Parses a PgQueryError struct from a pointer.
   *
   * The struct fields are defined in the C code as:
   * ```c
   * typedef struct {
   *   char *message;
   *   char *funcname;
   *   char *filename;
   *   int lineno;
   *   int cursorpos;
   *   char *context;
   * } PgQueryError;
   * ```
   *
   * We only care about the message and cursorpos fields, along with
   * filename to determine the error type (syntax vs semantic).
   */
  async #parsePgQueryError(errorPtr) {
    const module = await this.#module;
    const messagePtr = module.getValue(errorPtr, "i32");
    const fileNamePtr = module.getValue(errorPtr + 8, "i32");
    const position = module.getValue(errorPtr + 16, "i32") - 1;
    const message = messagePtr ? module.UTF8ToString(messagePtr) : "unknown error";
    const type = fileNamePtr ? getParseErrorType(module.UTF8ToString(fileNamePtr)) : "unknown";
    const error = new ParseError(message, {
      type,
      position
    });
    return error;
  }
};








exports.ParseError = ParseError; exports.PgParser = PgParser; exports.getSupportedVersions = getSupportedVersions; exports.isParseResultVersion = isParseResultVersion; exports.isSupportedVersion = isSupportedVersion; exports.unwrapNode = unwrapNode; exports.unwrapParseResult = unwrapParseResult;
//# sourceMappingURL=index.cjs.map