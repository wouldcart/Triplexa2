import App from './app/index.js';
export { default as App } from './app/index.js';
import * as _Messages from './app/messages.gen.js';
export declare const Messages: typeof _Messages;
export { SanitizeLevel } from './app/sanitizer.js';
import FeatureFlags, { IFeatureFlag } from './modules/featureFlags.js';
import type { Options as AppOptions } from './app/index.js';
import type { Options as ConsoleOptions } from './modules/console.js';
import type { Options as ExceptionOptions } from './modules/exception.js';
import type { Options as InputOptions } from './modules/input.js';
import type { Options as PerformanceOptions } from './modules/performance.js';
import type { Options as TimingOptions } from './modules/timing.js';
import type { Options as NetworkOptions } from './modules/network.js';
import type { MouseHandlerOptions } from './modules/mouse.js';
import type { SessionInfo } from './app/session.js';
import type { StartOptions } from './app/index.js';
import type { StartPromiseReturn } from './app/index.js';
export type Options = Partial<AppOptions & ConsoleOptions & ExceptionOptions & InputOptions & PerformanceOptions & TimingOptions> & {
    projectID?: number;
    projectKey: string;
    sessionToken?: string;
    respectDoNotTrack?: boolean;
    autoResetOnWindowOpen?: boolean;
    resetTabOnWindowOpen?: boolean;
    network?: Partial<NetworkOptions>;
    mouse?: Partial<MouseHandlerOptions>;
    flags?: {
        onFlagsLoad?: (flags: IFeatureFlag[]) => void;
    };
    __DISABLE_SECURE_MODE?: boolean;
};
export default class API {
    private readonly options;
    featureFlags: FeatureFlags;
    private readonly app;
    constructor(options: Options);
    checkDoNotTrack: () => boolean | undefined;
    signalStartIssue: (reason: string, missingApi: string[]) => void;
    isFlagEnabled(flagName: string): boolean;
    onFlagsLoad(callback: (flags: IFeatureFlag[]) => void): void;
    clearPersistFlags(): void;
    reloadFlags(): Promise<void> | undefined;
    getFeatureFlag(flagName: string): IFeatureFlag | undefined;
    getAllFeatureFlags(): IFeatureFlag[] | undefined;
    restartCanvasTracking: () => void;
    use<T>(fn: (app: App | null, options?: Options) => T): T;
    isActive(): boolean;
    /**
     * Creates a named hook that expects event name, data string and msg direction (up/down),
     * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
     * msg direction is "down" (incoming) by default
     *
     * @returns {(msgType: string, data: string, dir: 'up' | 'down') => void}
     * */
    trackWs(channelName: string): ((msgType: string, data: string, dir: "up" | "down") => void) | undefined;
    start(startOpts?: Partial<StartOptions>): Promise<StartPromiseReturn>;
    browserEnvCheck(): boolean;
    /**
     * start buffering messages without starting the actual session, which gives user 30 seconds to "activate" and record
     * session by calling start() on conditional trigger and we will then send buffered batch, so it won't get lost
     * */
    coldStart(startOpts?: Partial<StartOptions>, conditional?: boolean): Promise<never> | undefined;
    /**
     * Starts offline session recording. Keep in mind that only user device time will be used for timestamps.
     * (no backend delay sync)
     *
     * @param {Object} startOpts - options for session start, same as .start()
     * @param {Function} onSessionSent - callback that will be called once session is fully sent
     * @returns methods to manipulate buffer:
     *
     * saveBuffer - to save it in localStorage
     *
     * getBuffer - returns current buffer
     *
     * setBuffer - replaces current buffer with given
     * */
    startOfflineRecording(startOpts: Partial<StartOptions>, onSessionSent: () => void): Promise<never> | {
        saveBuffer: () => void;
        getBuffer: () => import("./common/messages.gen.js").default[];
        setBuffer: (buffer: import("./common/messages.gen.js").default[]) => void;
    };
    /**
     * Uploads the stored session buffer to backend
     * @returns promise that resolves once messages are loaded, it has to be awaited
     * so the session can be uploaded properly
     * @resolve - if messages were loaded into service worker successfully
     * @reject {string} - error message
     * */
    uploadOfflineRecording(): Promise<void> | undefined;
    stop(): string | undefined;
    forceFlushBatch(): void;
    getSessionToken(): string | null | undefined;
    getSessionInfo(): SessionInfo | null;
    getSessionID(): string | null | undefined;
    getTabId(): string | null;
    getUxId(): number | null;
    sessionID(): string | null | undefined;
    getSessionURL(options?: {
        withCurrentTime?: boolean;
    }): string | undefined;
    setUserID(id: string): void;
    userID(id: string): void;
    setUserAnonymousID(id: string): void;
    userAnonymousID(id: string): void;
    setMetadata(key: string, value: string): void;
    metadata(key: string, value: string): void;
    event(key: string, payload?: any, issue?: boolean): void;
    issue(key: string, payload?: any): void;
    handleError: (e: Error | ErrorEvent | PromiseRejectionEvent, metadata?: Record<string, any>) => void;
}
