-- Create user_roles table and sync with profiles.role
-- Idempotent and RLS-safe. Requires service role key for admin operations.

BEGIN;

-- 1) Create table if missing
CREATE TABLE IF NOT EXISTS public.user_roles (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL,
  role text NOT NULL,
  source text DEFAULT 'profile_sync',
  assigned_by uuid,
  created_at timestamp without time zone DEFAULT now(),
  updated_at timestamp without time zone DEFAULT now(),
  CONSTRAINT user_roles_user_role_unique UNIQUE (user_id, role)
);

-- 2) Foreign key to profiles (keeps alignment with other tables)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'user_roles_user_id_fkey'
  ) THEN
    ALTER TABLE public.user_roles
      ADD CONSTRAINT user_roles_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
  END IF;
END $$;

-- 3) Helpful index for lookups
CREATE INDEX IF NOT EXISTS user_roles_user_id_idx ON public.user_roles USING btree (user_id);

-- 4) Enable RLS
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- 5) Policies
-- Drop existing policies if any (to allow re-application)
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'user_roles' AND policyname = 'Users can read own roles'
  ) THEN
    DROP POLICY "Users can read own roles" ON public.user_roles;
  END IF;

  IF EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'user_roles' AND policyname = 'Users can insert their own roles'
  ) THEN
    DROP POLICY "Users can insert their own roles" ON public.user_roles;
  END IF;

  IF EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'user_roles' AND policyname = 'Users can update their own roles'
  ) THEN
    DROP POLICY "Users can update their own roles" ON public.user_roles;
  END IF;

  IF EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'user_roles' AND policyname = 'Service role full access to user_roles'
  ) THEN
    DROP POLICY "Service role full access to user_roles" ON public.user_roles;
  END IF;
END $$;

-- Recreate policies
CREATE POLICY "Users can read own roles" ON public.user_roles
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own roles" ON public.user_roles
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own roles" ON public.user_roles
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Service role full access to user_roles" ON public.user_roles
  FOR ALL
  TO service_role
  USING (true)
  WITH CHECK (true);

-- 6) Sync function and triggers from profiles.role
DROP FUNCTION IF EXISTS public.sync_user_roles_from_profiles() CASCADE;

CREATE OR REPLACE FUNCTION public.sync_user_roles_from_profiles()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NEW.role IS NOT NULL AND NEW.role <> '' THEN
    INSERT INTO public.user_roles (user_id, role, source, assigned_by, created_at, updated_at)
    VALUES (NEW.id, NEW.role, 'profile_sync', NULL, NOW(), NOW())
    ON CONFLICT (user_id, role) DO UPDATE SET updated_at = NOW();
  END IF;
  RETURN NEW;
END;
$$;

-- Attach triggers to profiles
DROP TRIGGER IF EXISTS profiles_role_sync_insert ON public.profiles;
DROP TRIGGER IF EXISTS profiles_role_sync_update ON public.profiles;

CREATE TRIGGER profiles_role_sync_insert
AFTER INSERT ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.sync_user_roles_from_profiles();

CREATE TRIGGER profiles_role_sync_update
AFTER UPDATE OF role ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.sync_user_roles_from_profiles();

COMMIT;